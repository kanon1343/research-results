2023-08-14 22:34:18 [main] [WARN] Configuration$Builder - The directory where kGenProg is running is different from the root directory of the given target project.
2023-08-14 22:34:18 [main] [WARN]  Configuration$Builder - If the target project includes test cases with file I/O, such test cases won't run correctly.
2023-08-14 22:34:18 [main] [WARN] Configuration$Builder - We recommend you running kGenProg with the root directory of the target project as the current directory.
2023-08-14 22:34:19 [main] [INFO] KGenProgMain -
==================== kGenProg Configuration ====================
configPath = /Users/fse/Downloads/kGenProg/example/math80/kgenprog-80.toml (set by command line)
rootDir = /Users/fse/Downloads/kGenProg/example/math80 (set in config file)
productPaths = [/Users/fse/Downloads/kGenProg/example/math80/src/main] (set in config file)
testPaths = [/Users/fse/Downloads/kGenProg/example/math80/src/test] (set in config file)
classPaths = []
executionTests = [org.apache.commons.math.linear.EigenDecompositionImplTest] (set in config file)
outDir = kgenprog-out
logLevel = INFO (set in config file)
mutationGeneratingCount = 50 (set in config file)
crossoverGeneratingCount = 50 (set in config file)
headcount = 25
maxGeneration = 500 (set in config file)
timeLimit = PT24H (set in config file)
testTimeLimit = PT3M (set in config file)
requiredSolutionsCount = 100 (set in config file)
randomSeed = 9 (set by command line)
scope = PACKAGE
faultLocalization = Zoltar (set in config file)
mutationType = Simple
crossoverType = Random
firstVariantSelectionStrategy = Random
secondVariantSelectionStrategy = Random
isPatchOutput = true (set in config file)
isHistoryRecord = false
currentDirectory = /Users/fse/Desktop/afterResearch
version = 1.8.2
================================================================
2023-08-14 22:34:39 [main] [INFO] KGenProgMain - initial failed tests (1/18)
org.apache.commons.math.linear.EigenDecompositionImplTest.testMathpbx02: null

2023-08-14 22:34:40 [main] [INFO] KGenProgMain - GA started
2023-08-14 22:34:40 [main] [INFO] KGenProgMain - entered the era of 1st generation.
2023-08-14 22:34:51 [main] [INFO] KGenProgMain -

---

Elapsed time: 10 seconds
Variants: generated 50, build-succeeded 6, build-failed 34, syntax-invalid 3, redundant 7
Fitness: max 0.944(6), min 0.944(6), ave 0.944
Test execution time: sum 3626 ms, max 834 ms, min 373 ms

---

2023-08-14 22:34:51 [main] [INFO] KGenProgMain - entered the era of 2nd generation.
2023-08-14 22:35:04 [main] [INFO] KGenProgMain -

---

Elapsed time: 24 seconds
Variants: generated 50, build-succeeded 16, build-failed 29, syntax-invalid 3, redundant 2
Fitness: max 1(1), min 0(1), ave 0.885
Test execution time: sum 6316 ms, max 681 ms, min 269 ms

---

2023-08-14 22:35:04 [main] [INFO] KGenProgMain - entered the era of 3rd generation.
2023-08-14 22:35:21 [main] [INFO] KGenProgMain -

---

Elapsed time: 41 seconds
Variants: generated 100, build-succeeded 27, build-failed 36, syntax-invalid 1, redundant 36
Fitness: max 0.944(25), min 0(2), ave 0.874
Test execution time: sum 8308 ms, max 447 ms, min 249 ms

---

2023-08-14 22:35:21 [main] [INFO] KGenProgMain - entered the era of 4th generation.
2023-08-14 22:35:36 [main] [INFO] KGenProgMain -

---

Elapsed time: 56 seconds
Variants: generated 100, build-succeeded 28, build-failed 35, syntax-invalid 8, redundant 29
Fitness: max 0.944(26), min 0.5(1), ave 0.925
Test execution time: sum 8206 ms, max 373 ms, min 252 ms

---

2023-08-14 22:35:36 [main] [INFO] KGenProgMain - entered the era of 5th generation.
2023-08-14 22:35:50 [main] [INFO] KGenProgMain -

---

Elapsed time: 1 minutes 10 seconds
Variants: generated 100, build-succeeded 26, build-failed 41, syntax-invalid 4, redundant 29
Fitness: max 0.944(25), min 0.833(1), ave 0.94
Test execution time: sum 7724 ms, max 500 ms, min 229 ms

---

2023-08-14 22:35:50 [main] [INFO] KGenProgMain - entered the era of 6th generation.
2023-08-14 22:36:08 [main] [INFO] KGenProgMain -

---

Elapsed time: 1 minutes 28 seconds
Variants: generated 100, build-succeeded 35, build-failed 41, syntax-invalid 2, redundant 22
Fitness: max 0.944(34), min 0.833(1), ave 0.941
Test execution time: sum 10748 ms, max 460 ms, min 234 ms

---

2023-08-14 22:36:08 [main] [INFO] KGenProgMain - entered the era of 7th generation.
2023-08-14 22:36:32 [main] [INFO] KGenProgMain -

---

Elapsed time: 1 minutes 52 seconds
Variants: generated 100, build-succeeded 41, build-failed 32, syntax-invalid 8, redundant 19
Fitness: max 0.944(40), min 0.611(1), ave 0.936
Test execution time: sum 13983 ms, max 691 ms, min 243 ms

---

2023-08-14 22:36:32 [main] [INFO] KGenProgMain - entered the era of 8th generation.
2023-08-14 22:36:54 [main] [INFO] KGenProgMain -

---

Elapsed time: 2 minutes 14 seconds
Variants: generated 100, build-succeeded 47, build-failed 23, syntax-invalid 9, redundant 21
Fitness: max 0.944(46), min 0.833(1), ave 0.942
Test execution time: sum 14051 ms, max 464 ms, min 224 ms

---

2023-08-14 22:36:54 [main] [INFO] KGenProgMain - entered the era of 9th generation.
2023-08-14 22:37:22 [main] [INFO] KGenProgMain -

---

Elapsed time: 2 minutes 41 seconds
Variants: generated 100, build-succeeded 53, build-failed 32, syntax-invalid 5, redundant 10
Fitness: max 0.944(51), min 0.5(1), ave 0.929
Test execution time: sum 17876 ms, max 626 ms, min 217 ms

---

2023-08-14 22:37:22 [main] [INFO] KGenProgMain - entered the era of 10th generation.
2023-08-14 22:37:48 [main] [INFO] KGenProgMain -

---

Elapsed time: 3 minutes 8 seconds
Variants: generated 100, build-succeeded 50, build-failed 35, syntax-invalid 2, redundant 13
Fitness: max 0.944(50), min 0.944(50), ave 0.944
Test execution time: sum 16320 ms, max 638 ms, min 224 ms

---

2023-08-14 22:37:48 [main] [INFO] KGenProgMain - entered the era of 11th generation.
2023-08-14 22:38:12 [main] [INFO] KGenProgMain -

---

Elapsed time: 3 minutes 32 seconds
Variants: generated 100, build-succeeded 51, build-failed 39, syntax-invalid 4, redundant 6
Fitness: max 0.944(51), min 0.944(51), ave 0.944
Test execution time: sum 14373 ms, max 403 ms, min 220 ms

---

2023-08-14 22:38:12 [main] [INFO] KGenProgMain - entered the era of 12th generation.
2023-08-14 22:47:35 [main] [INFO] KGenProgMain -

---

Elapsed time: 12 minutes 55 seconds
Variants: generated 100, build-succeeded 49, build-failed 37, syntax-invalid 10, redundant 4
Fitness: max 0.944(46), min 0.722(1), ave 0.937
Test execution time: sum 553817 ms, max 360201 ms, min 222 ms

---

2023-08-14 22:47:35 [main] [INFO] KGenProgMain - entered the era of 13th generation.
2023-08-14 22:47:58 [main] [INFO] KGenProgMain -

---

Elapsed time: 13 minutes 17 seconds
Variants: generated 100, build-succeeded 55, build-failed 32, syntax-invalid 8, redundant 5
Fitness: max 1(1), min 0.5(1), ave 0.934
Test execution time: sum 14369 ms, max 450 ms, min 216 ms

---

2023-08-14 22:47:58 [main] [INFO] KGenProgMain - entered the era of 14th generation.
2023-08-14 22:48:21 [main] [INFO] KGenProgMain -

---

Elapsed time: 13 minutes 41 seconds
Variants: generated 100, build-succeeded 55, build-failed 35, syntax-invalid 6, redundant 4
Fitness: max 1(1), min 0.889(1), ave 0.944
Test execution time: sum 15514 ms, max 487 ms, min 226 ms

---

2023-08-14 22:48:21 [main] [INFO] KGenProgMain - entered the era of 15th generation.
2023-08-14 22:48:42 [main] [INFO] KGenProgMain -

---

Elapsed time: 14 minutes 2 seconds
Variants: generated 100, build-succeeded 47, build-failed 38, syntax-invalid 10, redundant 5
Fitness: max 0.944(46), min 0.833(1), ave 0.942
Test execution time: sum 12355 ms, max 451 ms, min 219 ms

---

2023-08-14 22:48:42 [main] [INFO] KGenProgMain - entered the era of 16th generation.
2023-08-14 22:49:06 [main] [INFO] KGenProgMain -

---

Elapsed time: 14 minutes 26 seconds
Variants: generated 100, build-succeeded 52, build-failed 36, syntax-invalid 10, redundant 2
Fitness: max 1(1), min 0.611(1), ave 0.937
Test execution time: sum 14368 ms, max 468 ms, min 220 ms

---

2023-08-14 22:49:06 [main] [INFO] KGenProgMain - entered the era of 17th generation.
2023-08-14 22:49:28 [main] [INFO] KGenProgMain -

---

Elapsed time: 14 minutes 47 seconds
Variants: generated 100, build-succeeded 48, build-failed 36, syntax-invalid 11, redundant 5
Fitness: max 0.944(47), min 0.444(1), ave 0.934
Test execution time: sum 13000 ms, max 443 ms, min 216 ms

---

2023-08-14 22:49:28 [main] [INFO] KGenProgMain - entered the era of 18th generation.
2023-08-14 22:49:48 [main] [INFO] KGenProgMain -

---

Elapsed time: 15 minutes 7 seconds
Variants: generated 100, build-succeeded 44, build-failed 38, syntax-invalid 15, redundant 3
Fitness: max 0.944(43), min 0.833(1), ave 0.942
Test execution time: sum 11799 ms, max 549 ms, min 216 ms

---

2023-08-14 22:49:48 [main] [INFO] KGenProgMain - entered the era of 19th generation.
2023-08-14 22:50:10 [main] [INFO] KGenProgMain -

---

Elapsed time: 15 minutes 30 seconds
Variants: generated 100, build-succeeded 47, build-failed 34, syntax-invalid 15, redundant 4
Fitness: max 0.944(46), min 0.833(1), ave 0.942
Test execution time: sum 13164 ms, max 405 ms, min 218 ms

---

2023-08-14 22:50:10 [main] [INFO] KGenProgMain - entered the era of 20th generation.
2023-08-14 22:50:32 [main] [INFO] KGenProgMain -

---

Elapsed time: 15 minutes 52 seconds
Variants: generated 100, build-succeeded 46, build-failed 37, syntax-invalid 16, redundant 1
Fitness: max 0.944(45), min 0.833(1), ave 0.942
Test execution time: sum 12666 ms, max 516 ms, min 219 ms

---

2023-08-14 22:50:32 [main] [INFO] KGenProgMain - entered the era of 21st generation.
2023-08-14 22:56:53 [main] [INFO] KGenProgMain -

---

Elapsed time: 22 minutes 12 seconds
Variants: generated 100, build-succeeded 47, build-failed 34, syntax-invalid 13, redundant 6
Fitness: max 0.944(45), min 0.833(1), ave 0.941
Test execution time: sum 372238 ms, max 360169 ms, min 212 ms

---

2023-08-14 22:56:53 [main] [INFO] KGenProgMain - entered the era of 22nd generation.
2023-08-14 23:00:15 [main] [INFO] KGenProgMain -

---

Elapsed time: 25 minutes 34 seconds
Variants: generated 100, build-succeeded 48, build-failed 38, syntax-invalid 11, redundant 3
Fitness: max 1(1), min 0.5(1), ave 0.934
Test execution time: sum 193398 ms, max 180235 ms, min 217 ms

---

2023-08-14 23:00:15 [main] [INFO] KGenProgMain - entered the era of 23rd generation.
2023-08-14 23:09:34 [main] [INFO] KGenProgMain -

---

Elapsed time: 34 minutes 54 seconds
Variants: generated 100, build-succeeded 43, build-failed 32, syntax-invalid 23, redundant 2
Fitness: max 1(1), min 0.889(1), ave 0.944
Test execution time: sum 551036 ms, max 180266 ms, min 218 ms

---

2023-08-14 23:09:34 [main] [INFO] KGenProgMain - entered the era of 24th generation.
2023-08-14 23:18:54 [main] [INFO] KGenProgMain -

---

Elapsed time: 44 minutes 14 seconds
Variants: generated 100, build-succeeded 46, build-failed 32, syntax-invalid 21, redundant 1
Fitness: max 0.944(45), min 0.5(1), ave 0.935
Test execution time: sum 552451 ms, max 180315 ms, min 219 ms

---

2023-08-14 23:18:54 [main] [INFO] KGenProgMain - entered the era of 25th generation.
2023-08-14 23:25:17 [main] [INFO] KGenProgMain -

---

Elapsed time: 50 minutes 36 seconds
Variants: generated 100, build-succeeded 47, build-failed 34, syntax-invalid 17, redundant 2
Fitness: max 0.944(45), min 0.778(1), ave 0.94
Test execution time: sum 373305 ms, max 180320 ms, min 202 ms

---

2023-08-14 23:25:17 [main] [INFO] KGenProgMain - entered the era of 26th generation.
2023-08-14 23:52:41 [main] [INFO] KGenProgMain -

---

Elapsed time: 1 hours 18 minutes 0 seconds
Variants: generated 100, build-succeeded 49, build-failed 33, syntax-invalid 17, redundant 1
Fitness: max 1(1), min 0.444(1), ave 0.93
Test execution time: sum 1633387 ms, max 1440231 ms, min 218 ms

---

2023-08-14 23:52:41 [main] [INFO] KGenProgMain - entered the era of 27th generation.
2023-08-14 23:52:59 [main] [INFO] KGenProgMain -

---

Elapsed time: 1 hours 18 minutes 19 seconds
Variants: generated 100, build-succeeded 37, build-failed 38, syntax-invalid 24, redundant 1
Fitness: max 0.944(37), min 0.944(37), ave 0.944
Test execution time: sum 9711 ms, max 403 ms, min 213 ms

---

2023-08-14 23:52:59 [main] [INFO] KGenProgMain - entered the era of 28th generation.
2023-08-14 23:53:21 [main] [INFO] KGenProgMain -

---

Elapsed time: 1 hours 18 minutes 40 seconds
Variants: generated 100, build-succeeded 43, build-failed 40, syntax-invalid 13, redundant 4
Fitness: max 0.944(42), min 0.556(1), ave 0.935
Test execution time: sum 11948 ms, max 454 ms, min 214 ms

---

2023-08-14 23:53:21 [main] [INFO] KGenProgMain - entered the era of 29th generation.
2023-08-14 23:53:43 [main] [INFO] KGenProgMain -

---

Elapsed time: 1 hours 19 minutes 2 seconds
Variants: generated 100, build-succeeded 46, build-failed 34, syntax-invalid 16, redundant 4
Fitness: max 1(1), min 0.889(1), ave 0.944
Test execution time: sum 12902 ms, max 626 ms, min 213 ms

---

2023-08-14 23:53:43 [main] [INFO] KGenProgMain - entered the era of 30th generation.
2023-08-14 23:54:02 [main] [INFO] KGenProgMain -

---

Elapsed time: 1 hours 19 minutes 21 seconds
Variants: generated 100, build-succeeded 33, build-failed 43, syntax-invalid 20, redundant 4
Fitness: max 0.944(33), min 0.944(33), ave 0.944
Test execution time: sum 8721 ms, max 506 ms, min 218 ms

---

2023-08-14 23:54:02 [main] [INFO] KGenProgMain - entered the era of 31st generation.
2023-08-14 23:54:25 [main] [INFO] KGenProgMain -

---

Elapsed time: 1 hours 19 minutes 44 seconds
Variants: generated 100, build-succeeded 42, build-failed 35, syntax-invalid 18, redundant 5
Fitness: max 1(1), min 0.5(1), ave 0.933
Test execution time: sum 12990 ms, max 505 ms, min 224 ms

---

2023-08-14 23:54:25 [main] [INFO] KGenProgMain - entered the era of 32nd generation.
2023-08-15 00:00:48 [main] [INFO] KGenProgMain -

---

Elapsed time: 1 hours 26 minutes 7 seconds
Variants: generated 100, build-succeeded 42, build-failed 34, syntax-invalid 22, redundant 2
Fitness: max 1(1), min 0.944(41), ave 0.946
Test execution time: sum 372393 ms, max 180618 ms, min 213 ms

---

2023-08-15 00:00:48 [main] [INFO] KGenProgMain - entered the era of 33rd generation.
2023-08-15 00:37:10 [main] [INFO] KGenProgMain -

---

Elapsed time: 2 hours 2 minutes 29 seconds
Variants: generated 100, build-succeeded 42, build-failed 34, syntax-invalid 22, redundant 2
Fitness: max 1(1), min 0.444(1), ave 0.923
Test execution time: sum 2172199 ms, max 1800212 ms, min 213 ms

---

2023-08-15 00:37:10 [main] [INFO] KGenProgMain - entered the era of 34th generation.
2023-08-15 00:43:32 [main] [INFO] KGenProgMain -

---

Elapsed time: 2 hours 8 minutes 51 seconds
Variants: generated 100, build-succeeded 41, build-failed 43, syntax-invalid 16, redundant 0
Fitness: max 0.944(40), min 0.833(1), ave 0.942
Test execution time: sum 371544 ms, max 180285 ms, min 227 ms

---

2023-08-15 00:43:32 [main] [INFO] KGenProgMain - entered the era of 35th generation.
2023-08-15 00:52:54 [main] [INFO] KGenProgMain -

---

Elapsed time: 2 hours 18 minutes 14 seconds
Variants: generated 100, build-succeeded 39, build-failed 35, syntax-invalid 22, redundant 4
Fitness: max 0.944(38), min 0.833(1), ave 0.942
Test execution time: sum 550726 ms, max 180346 ms, min 221 ms

---

2023-08-15 00:52:54 [main] [INFO] KGenProgMain - entered the era of 36th generation.
2023-08-15 01:14:19 [main] [INFO] KGenProgMain -

---

Elapsed time: 2 hours 39 minutes 38 seconds
Variants: generated 100, build-succeeded 46, build-failed 36, syntax-invalid 16, redundant 2
Fitness: max 0.944(46), min 0.944(46), ave 0.944
Test execution time: sum 1273663 ms, max 180414 ms, min 228 ms

---

2023-08-15 01:14:19 [main] [INFO] KGenProgMain - entered the era of 37th generation.
2023-08-15 01:32:43 [main] [INFO] KGenProgMain -

---

Elapsed time: 2 hours 58 minutes 2 seconds
Variants: generated 100, build-succeeded 43, build-failed 42, syntax-invalid 13, redundant 2
Fitness: max 0.944(41), min 0.611(1), ave 0.934
Test execution time: sum 1093103 ms, max 180433 ms, min 218 ms

---

2023-08-15 01:32:43 [main] [INFO] KGenProgMain - entered the era of 38th generation.
2023-08-15 01:39:02 [main] [INFO] KGenProgMain -

---

Elapsed time: 3 hours 4 minutes 22 seconds
Variants: generated 100, build-succeeded 33, build-failed 39, syntax-invalid 24, redundant 4
Fitness: max 0.944(33), min 0.944(33), ave 0.944
Test execution time: sum 369697 ms, max 180320 ms, min 231 ms

---

2023-08-15 01:39:02 [main] [INFO] KGenProgMain - entered the era of 39th generation.
2023-08-15 01:48:24 [main] [INFO] KGenProgMain -

---

Elapsed time: 3 hours 13 minutes 43 seconds
Variants: generated 100, build-succeeded 45, build-failed 33, syntax-invalid 20, redundant 2
Fitness: max 0.944(45), min 0.944(45), ave 0.944
Test execution time: sum 552019 ms, max 180470 ms, min 217 ms

---

2023-08-15 01:48:24 [main] [INFO] KGenProgMain - entered the era of 40th generation.
2023-08-15 01:54:46 [main] [INFO] KGenProgMain -

---

Elapsed time: 3 hours 20 minutes 6 seconds
Variants: generated 100, build-succeeded 42, build-failed 33, syntax-invalid 21, redundant 4
Fitness: max 0.944(39), min 0.556(1), ave 0.931
Test execution time: sum 371405 ms, max 180241 ms, min 222 ms

---

2023-08-15 01:54:46 [main] [INFO] KGenProgMain - entered the era of 41st generation.
2023-08-15 02:07:07 [main] [INFO] KGenProgMain -

---

Elapsed time: 3 hours 32 minutes 27 seconds
Variants: generated 100, build-succeeded 38, build-failed 37, syntax-invalid 24, redundant 1
Fitness: max 1(1), min 0.556(1), ave 0.936
Test execution time: sum 730761 ms, max 180369 ms, min 221 ms

---

2023-08-15 02:07:07 [main] [INFO] KGenProgMain - entered the era of 42nd generation.
2023-08-15 02:28:26 [main] [INFO] KGenProgMain -

---

Elapsed time: 3 hours 53 minutes 45 seconds
Variants: generated 100, build-succeeded 31, build-failed 36, syntax-invalid 29, redundant 4
Fitness: max 0.944(31), min 0.944(31), ave 0.944
Test execution time: sum 1269322 ms, max 180411 ms, min 224 ms

---

2023-08-15 02:28:26 [main] [INFO] KGenProgMain - entered the era of 43rd generation.
2023-08-15 02:58:49 [main] [INFO] KGenProgMain -

---

Elapsed time: 4 hours 24 minutes 8 seconds
Variants: generated 100, build-succeeded 43, build-failed 38, syntax-invalid 18, redundant 1
Fitness: max 1(1), min 0.944(42), ave 0.946
Test execution time: sum 1811981 ms, max 180329 ms, min 207 ms

---

2023-08-15 02:58:49 [main] [INFO] KGenProgMain - entered the era of 44th generation.
2023-08-15 03:05:09 [main] [INFO] KGenProgMain -

---

Elapsed time: 4 hours 30 minutes 28 seconds
Variants: generated 100, build-succeeded 30, build-failed 45, syntax-invalid 25, redundant 0
Fitness: max 0.944(29), min 0.833(1), ave 0.941
Test execution time: sum 369197 ms, max 180254 ms, min 222 ms

---

2023-08-15 03:05:09 [main] [INFO] KGenProgMain - entered the era of 45th generation.
2023-08-15 03:08:39 [main] [INFO] KGenProgMain -

---

Elapsed time: 4 hours 33 minutes 58 seconds
Variants: generated 100, build-succeeded 47, build-failed 38, syntax-invalid 15, redundant 0
Fitness: max 0.944(45), min 0.889(2), ave 0.942
Test execution time: sum 195792 ms, max 180308 ms, min 243 ms

---

2023-08-15 03:08:39 [main] [INFO] KGenProgMain - entered the era of 46th generation.
2023-08-15 03:30:02 [main] [INFO] KGenProgMain -

---

Elapsed time: 4 hours 55 minutes 22 seconds
Variants: generated 100, build-succeeded 45, build-failed 34, syntax-invalid 16, redundant 5
Fitness: max 1(1), min 0.944(44), ave 0.946
Test execution time: sum 1272685 ms, max 180513 ms, min 229 ms

---

2023-08-15 03:30:02 [main] [INFO] KGenProgMain - entered the era of 47th generation.
2023-08-15 03:42:24 [main] [INFO] KGenProgMain -

---

Elapsed time: 5 hours 7 minutes 43 seconds
Variants: generated 100, build-succeeded 41, build-failed 35, syntax-invalid 23, redundant 1
Fitness: max 0.944(39), min 0.833(2), ave 0.939
Test execution time: sum 731541 ms, max 180534 ms, min 212 ms

---

2023-08-15 03:42:24 [main] [INFO] KGenProgMain - entered the era of 48th generation.
2023-08-15 03:54:46 [main] [INFO] KGenProgMain -

---

Elapsed time: 5 hours 20 minutes 5 seconds
Variants: generated 100, build-succeeded 31, build-failed 44, syntax-invalid 24, redundant 1
Fitness: max 0.944(31), min 0.944(31), ave 0.944
Test execution time: sum 729333 ms, max 180343 ms, min 222 ms

---

2023-08-15 03:54:46 [main] [INFO] KGenProgMain - entered the era of 49th generation.
2023-08-15 04:01:06 [main] [INFO] KGenProgMain -

---

Elapsed time: 5 hours 26 minutes 25 seconds
Variants: generated 100, build-succeeded 26, build-failed 42, syntax-invalid 30, redundant 2
Fitness: max 1(1), min 0.944(25), ave 0.947
Test execution time: sum 367782 ms, max 180307 ms, min 222 ms

---

2023-08-15 04:01:06 [main] [INFO] KGenProgMain - entered the era of 50th generation.
2023-08-15 04:04:29 [main] [INFO] KGenProgMain -

---

Elapsed time: 5 hours 29 minutes 49 seconds
Variants: generated 100, build-succeeded 42, build-failed 32, syntax-invalid 24, redundant 2
Fitness: max 1(1), min 0.889(1), ave 0.944
Test execution time: sum 191901 ms, max 180248 ms, min 232 ms

---

2023-08-15 04:04:29 [main] [INFO] KGenProgMain - entered the era of 51st generation.
2023-08-15 04:10:48 [main] [INFO] KGenProgMain -

---

Elapsed time: 5 hours 36 minutes 7 seconds
Variants: generated 100, build-succeeded 30, build-failed 35, syntax-invalid 32, redundant 3
Fitness: max 0.944(30), min 0.944(30), ave 0.944
Test execution time: sum 368434 ms, max 180257 ms, min 229 ms

---

2023-08-15 04:10:48 [main] [INFO] KGenProgMain - entered the era of 52nd generation.
2023-08-15 04:29:10 [main] [INFO] KGenProgMain -

---

Elapsed time: 5 hours 54 minutes 30 seconds
Variants: generated 100, build-succeeded 41, build-failed 28, syntax-invalid 29, redundant 2
Fitness: max 0.944(41), min 0.944(41), ave 0.944
Test execution time: sum 1091306 ms, max 180292 ms, min 223 ms

---

2023-08-15 04:29:10 [main] [INFO] KGenProgMain - entered the era of 53rd generation.
2023-08-15 04:44:31 [main] [INFO] KGenProgMain -

---

Elapsed time: 6 hours 9 minutes 51 seconds
Variants: generated 100, build-succeeded 31, build-failed 41, syntax-invalid 27, redundant 1
Fitness: max 1(1), min 0.611(1), ave 0.932
Test execution time: sum 908704 ms, max 180477 ms, min 219 ms

---

2023-08-15 04:44:31 [main] [INFO] KGenProgMain - entered the era of 54th generation.
2023-08-15 05:02:58 [main] [INFO] KGenProgMain -

---

Elapsed time: 6 hours 28 minutes 17 seconds
Variants: generated 100, build-succeeded 43, build-failed 31, syntax-invalid 26, redundant 0
Fitness: max 0.944(41), min 0.5(1), ave 0.932
Test execution time: sum 1093704 ms, max 180536 ms, min 214 ms

---

2023-08-15 05:02:58 [main] [INFO] KGenProgMain - entered the era of 55th generation.
2023-08-15 05:18:18 [main] [INFO] KGenProgMain -

---

Elapsed time: 6 hours 43 minutes 37 seconds
Variants: generated 100, build-succeeded 34, build-failed 28, syntax-invalid 36, redundant 2
Fitness: max 0.944(34), min 0.944(34), ave 0.944
Test execution time: sum 909932 ms, max 180516 ms, min 225 ms

---

2023-08-15 05:18:18 [main] [INFO] KGenProgMain - entered the era of 56th generation.
2023-08-15 05:27:36 [main] [INFO] KGenProgMain -

---

Elapsed time: 6 hours 52 minutes 55 seconds
Variants: generated 100, build-succeeded 24, build-failed 46, syntax-invalid 28, redundant 2
Fitness: max 0.944(24), min 0.944(24), ave 0.944
Test execution time: sum 546687 ms, max 180355 ms, min 204 ms

---

2023-08-15 05:27:36 [main] [INFO] KGenProgMain - entered the era of 57th generation.
2023-08-15 05:30:55 [main] [INFO] KGenProgMain -

---

Elapsed time: 6 hours 56 minutes 15 seconds
Variants: generated 100, build-succeeded 33, build-failed 33, syntax-invalid 31, redundant 3
Fitness: max 1(1), min 0.722(1), ave 0.938
Test execution time: sum 188505 ms, max 180230 ms, min 223 ms

---

2023-08-15 05:30:55 [main] [INFO] KGenProgMain - entered the era of 58th generation.
2023-08-15 05:40:12 [main] [INFO] KGenProgMain -

---

Elapsed time: 7 hours 5 minutes 31 seconds
Variants: generated 100, build-succeeded 20, build-failed 44, syntax-invalid 35, redundant 1
Fitness: max 1(1), min 0.944(19), ave 0.947
Test execution time: sum 545618 ms, max 180366 ms, min 211 ms

---

2023-08-15 05:40:12 [main] [INFO] KGenProgMain - entered the era of 59th generation.
2023-08-15 05:46:33 [main] [INFO] KGenProgMain -

---

Elapsed time: 7 hours 11 minutes 53 seconds
Variants: generated 100, build-succeeded 35, build-failed 37, syntax-invalid 26, redundant 2
Fitness: max 0.944(33), min 0(1), ave 0.916
Test execution time: sum 369846 ms, max 180276 ms, min 79 ms

---

2023-08-15 05:46:33 [main] [INFO] KGenProgMain - entered the era of 60th generation.
2023-08-15 05:55:54 [main] [INFO] KGenProgMain -

---

Elapsed time: 7 hours 21 minutes 13 seconds
Variants: generated 100, build-succeeded 32, build-failed 33, syntax-invalid 33, redundant 2
Fitness: max 0.944(31), min 0.556(1), ave 0.932
Test execution time: sum 549246 ms, max 180272 ms, min 224 ms

---

2023-08-15 05:55:54 [main] [INFO] KGenProgMain - entered the era of 61st generation.
2023-08-15 06:08:15 [main] [INFO] KGenProgMain -

---

Elapsed time: 7 hours 33 minutes 34 seconds
Variants: generated 100, build-succeeded 35, build-failed 32, syntax-invalid 31, redundant 2
Fitness: max 0.944(34), min 0.5(1), ave 0.932
Test execution time: sum 730053 ms, max 180338 ms, min 210 ms

---

2023-08-15 06:08:15 [main] [INFO] KGenProgMain - entered the era of 62nd generation.
2023-08-15 06:14:36 [main] [INFO] KGenProgMain -

---

Elapsed time: 7 hours 39 minutes 56 seconds
Variants: generated 100, build-succeeded 35, build-failed 32, syntax-invalid 31, redundant 2
Fitness: max 0.944(33), min 0.833(2), ave 0.938
Test execution time: sum 370041 ms, max 180407 ms, min 202 ms

---

2023-08-15 06:14:36 [main] [INFO] KGenProgMain - entered the era of 63rd generation.
2023-08-15 06:33:04 [main] [INFO] KGenProgMain -

---

Elapsed time: 7 hours 58 minutes 23 seconds
Variants: generated 100, build-succeeded 44, build-failed 30, syntax-invalid 26, redundant 0
Fitness: max 0.944(41), min 0.5(1), ave 0.929
Test execution time: sum 1094600 ms, max 180380 ms, min 216 ms

---

2023-08-15 06:33:04 [main] [INFO] KGenProgMain - entered the era of 64th generation.
2023-08-15 06:42:25 [main] [INFO] KGenProgMain -

---

Elapsed time: 8 hours 7 minutes 44 seconds
Variants: generated 100, build-succeeded 33, build-failed 30, syntax-invalid 33, redundant 4
Fitness: max 0.944(33), min 0.944(33), ave 0.944
Test execution time: sum 549361 ms, max 180366 ms, min 214 ms

---

2023-08-15 06:42:25 [main] [INFO] KGenProgMain - entered the era of 65th generation.
2023-08-15 06:54:45 [main] [INFO] KGenProgMain -

---

Elapsed time: 8 hours 20 minutes 4 seconds
Variants: generated 100, build-succeeded 30, build-failed 36, syntax-invalid 31, redundant 3
Fitness: max 1(1), min 0.833(1), ave 0.943
Test execution time: sum 728092 ms, max 180301 ms, min 211 ms

---

2023-08-15 06:54:45 [main] [INFO] KGenProgMain - entered the era of 66th generation.
2023-08-15 06:58:09 [main] [INFO] KGenProgMain -

---

Elapsed time: 8 hours 23 minutes 28 seconds
Variants: generated 100, build-succeeded 30, build-failed 35, syntax-invalid 34, redundant 1
Fitness: max 0.944(28), min 0.833(2), ave 0.937
Test execution time: sum 189767 ms, max 180229 ms, min 232 ms

---

2023-08-15 06:58:09 [main] [INFO] KGenProgMain - entered the era of 67th generation.
2023-08-15 06:58:26 [main] [INFO] KGenProgMain -

---

Elapsed time: 8 hours 23 minutes 45 seconds
Variants: generated 100, build-succeeded 16, build-failed 39, syntax-invalid 43, redundant 2
Fitness: max 0.944(16), min 0.944(16), ave 0.944
Test execution time: sum 4680 ms, max 479 ms, min 219 ms

---

2023-08-15 06:58:26 [main] [INFO] KGenProgMain - entered the era of 68th generation.
2023-08-15 07:04:44 [main] [INFO] KGenProgMain -

---

Elapsed time: 8 hours 30 minutes 3 seconds
Variants: generated 100, build-succeeded 26, build-failed 36, syntax-invalid 36, redundant 2
Fitness: max 0.944(24), min 0.833(2), ave 0.936
Test execution time: sum 366886 ms, max 180373 ms, min 220 ms

---

2023-08-15 07:04:44 [main] [INFO] KGenProgMain - entered the era of 69th generation.
2023-08-15 07:26:03 [main] [INFO] KGenProgMain -

---

Elapsed time: 8 hours 51 minutes 22 seconds
Variants: generated 100, build-succeeded 27, build-failed 34, syntax-invalid 37, redundant 2
Fitness: max 1(1), min 0.556(1), ave 0.92
Test execution time: sum 1267522 ms, max 180378 ms, min 214 ms

---

2023-08-15 07:26:03 [main] [INFO] KGenProgMain - entered the era of 70th generation.
2023-08-15 07:47:25 [main] [INFO] KGenProgMain -

---

Elapsed time: 9 hours 12 minutes 45 seconds
Variants: generated 100, build-succeeded 29, build-failed 32, syntax-invalid 38, redundant 1
Fitness: max 0.944(29), min 0.944(29), ave 0.944
Test execution time: sum 1268371 ms, max 180341 ms, min 218 ms

---

2023-08-15 07:47:25 [main] [INFO] KGenProgMain - entered the era of 71st generation.
2023-08-15 08:08:47 [main] [INFO] KGenProgMain -

---

Elapsed time: 9 hours 34 minutes 6 seconds
Variants: generated 100, build-succeeded 32, build-failed 31, syntax-invalid 35, redundant 2
Fitness: max 0.944(32), min 0.944(32), ave 0.944
Test execution time: sum 1269004 ms, max 180345 ms, min 208 ms

---

2023-08-15 08:08:47 [main] [INFO] KGenProgMain - entered the era of 72nd generation.
2023-08-15 08:18:03 [main] [INFO] KGenProgMain -

---

Elapsed time: 9 hours 43 minutes 22 seconds
Variants: generated 100, build-succeeded 21, build-failed 38, syntax-invalid 36, redundant 5
Fitness: max 0.944(21), min 0.944(21), ave 0.944
Test execution time: sum 545669 ms, max 180430 ms, min 218 ms

---

2023-08-15 08:18:03 [main] [INFO] KGenProgMain - entered the era of 73rd generation.
2023-08-15 08:45:23 [main] [INFO] KGenProgMain -

---

Elapsed time: 10 hours 10 minutes 43 seconds
Variants: generated 100, build-succeeded 29, build-failed 38, syntax-invalid 32, redundant 1
Fitness: max 0.944(29), min 0.944(29), ave 0.944
Test execution time: sum 1628197 ms, max 180450 ms, min 217 ms

---

2023-08-15 08:45:23 [main] [INFO] KGenProgMain - entered the era of 74th generation.
2023-08-15 09:24:47 [main] [INFO] KGenProgMain -

---

Elapsed time: 10 hours 50 minutes 6 seconds
Variants: generated 100, build-succeeded 38, build-failed 26, syntax-invalid 34, redundant 2
Fitness: max 0.944(36), min 0.5(1), ave 0.924
Test execution time: sum 2350622 ms, max 180495 ms, min 216 ms

---

2023-08-15 09:24:47 [main] [INFO] KGenProgMain - entered the era of 75th generation.
2023-08-15 09:46:12 [main] [INFO] KGenProgMain -

---

Elapsed time: 11 hours 11 minutes 31 seconds
Variants: generated 100, build-succeeded 26, build-failed 24, syntax-invalid 48, redundant 2
Fitness: max 1(1), min 0.889(1), ave 0.944
Test execution time: sum 1269270 ms, max 180484 ms, min 215 ms

---

2023-08-15 09:46:12 [main] [INFO] KGenProgMain - entered the era of 76th generation.
2023-08-15 10:16:29 [main] [INFO] KGenProgMain -

---

Elapsed time: 11 hours 41 minutes 48 seconds
Variants: generated 100, build-succeeded 21, build-failed 34, syntax-invalid 44, redundant 1
Fitness: max 0.944(20), min 0.833(1), ave 0.939
Test execution time: sum 1806082 ms, max 540238 ms, min 221 ms

---

2023-08-15 10:16:29 [main] [INFO] KGenProgMain - entered the era of 77th generation.
2023-08-15 10:37:46 [main] [INFO] KGenProgMain -

---

Elapsed time: 12 hours 3 minutes 5 seconds
Variants: generated 100, build-succeeded 20, build-failed 36, syntax-invalid 42, redundant 2
Fitness: max 0.944(20), min 0.944(20), ave 0.944
Test execution time: sum 1265267 ms, max 180395 ms, min 206 ms

---

2023-08-15 10:37:46 [main] [INFO] KGenProgMain - entered the era of 78th generation.
2023-08-15 10:53:06 [main] [INFO] KGenProgMain -

---

Elapsed time: 12 hours 18 minutes 24 seconds
Variants: generated 100, build-succeeded 24, build-failed 34, syntax-invalid 42, redundant 0
Fitness: max 0.944(24), min 0.944(24), ave 0.944
Test execution time: sum 906888 ms, max 180640 ms, min 211 ms

---

2023-08-15 10:53:06 [main] [INFO] KGenProgMain - entered the era of 79th generation.
2023-08-15 11:02:26 [main] [INFO] KGenProgMain -

---

Elapsed time: 12 hours 27 minutes 45 seconds
Variants: generated 100, build-succeeded 24, build-failed 34, syntax-invalid 39, redundant 3
Fitness: max 1(1), min 0.833(2), ave 0.938
Test execution time: sum 547086 ms, max 180290 ms, min 217 ms

---

2023-08-15 11:02:26 [main] [INFO] KGenProgMain - entered the era of 80th generation.
2023-08-15 11:20:51 [main] [INFO] KGenProgMain -

---

Elapsed time: 12 hours 46 minutes 9 seconds
Variants: generated 100, build-succeeded 36, build-failed 32, syntax-invalid 29, redundant 3
Fitness: max 0.944(34), min 0.833(2), ave 0.938
Test execution time: sum 1090093 ms, max 180455 ms, min 211 ms

---

2023-08-15 11:20:51 [main] [INFO] KGenProgMain - entered the era of 81st generation.
2023-08-15 11:36:11 [main] [INFO] KGenProgMain -

---

Elapsed time: 13 hours 1 minutes 29 seconds
Variants: generated 100, build-succeeded 24, build-failed 35, syntax-invalid 40, redundant 1
Fitness: max 1(1), min 0.944(23), ave 0.947
Test execution time: sum 906712 ms, max 180335 ms, min 219 ms

---

2023-08-15 11:36:11 [main] [INFO] KGenProgMain - entered the era of 82nd generation.
2023-08-15 11:42:29 [main] [INFO] KGenProgMain -

---

Elapsed time: 13 hours 7 minutes 48 seconds
Variants: generated 100, build-succeeded 18, build-failed 37, syntax-invalid 43, redundant 2
Fitness: max 1(1), min 0.722(1), ave 0.929
Test execution time: sum 365294 ms, max 180411 ms, min 228 ms

---

2023-08-15 11:42:29 [main] [INFO] KGenProgMain - entered the era of 83rd generation.
2023-08-15 11:51:48 [main] [INFO] KGenProgMain -

---

Elapsed time: 13 hours 17 minutes 7 seconds
Variants: generated 100, build-succeeded 20, build-failed 35, syntax-invalid 43, redundant 2
Fitness: max 0.944(19), min 0.889(1), ave 0.942
Test execution time: sum 545580 ms, max 180305 ms, min 221 ms

---

2023-08-15 11:51:48 [main] [INFO] KGenProgMain - entered the era of 84th generation.
2023-08-15 12:13:11 [main] [INFO] KGenProgMain -

---

Elapsed time: 13 hours 38 minutes 30 seconds
Variants: generated 100, build-succeeded 28, build-failed 28, syntax-invalid 42, redundant 2
Fitness: max 0.944(26), min 0.833(2), ave 0.937
Test execution time: sum 1268132 ms, max 180308 ms, min 211 ms

---

2023-08-15 12:13:11 [main] [INFO] KGenProgMain - entered the era of 85th generation.
2023-08-15 12:34:32 [main] [INFO] KGenProgMain -

---

Elapsed time: 13 hours 59 minutes 51 seconds
Variants: generated 100, build-succeeded 27, build-failed 30, syntax-invalid 42, redundant 1
Fitness: max 1(1), min 0.556(2), ave 0.912
Test execution time: sum 1267133 ms, max 360345 ms, min 213 ms

---

2023-08-15 12:34:32 [main] [INFO] KGenProgMain - entered the era of 86th generation.
2023-08-15 12:55:50 [main] [INFO] KGenProgMain -

---

Elapsed time: 14 hours 21 minutes 8 seconds
Variants: generated 100, build-succeeded 19, build-failed 40, syntax-invalid 41, redundant 0
Fitness: max 0.944(18), min 0.833(1), ave 0.939
Test execution time: sum 1264725 ms, max 360165 ms, min 216 ms

---

2023-08-15 12:55:50 [main] [INFO] KGenProgMain - entered the era of 87th generation.
2023-08-15 13:11:08 [main] [INFO] KGenProgMain -

---

Elapsed time: 14 hours 36 minutes 27 seconds
Variants: generated 100, build-succeeded 22, build-failed 36, syntax-invalid 40, redundant 2
Fitness: max 1(1), min 0.833(1), ave 0.942
Test execution time: sum 906008 ms, max 180406 ms, min 218 ms

---

2023-08-15 13:11:08 [main] [INFO] KGenProgMain - entered the era of 88th generation.
2023-08-15 13:23:28 [main] [INFO] KGenProgMain -

---

Elapsed time: 14 hours 48 minutes 47 seconds
Variants: generated 100, build-succeeded 30, build-failed 24, syntax-invalid 44, redundant 2
Fitness: max 1(1), min 0.5(1), ave 0.917
Test execution time: sum 727919 ms, max 180372 ms, min 218 ms

---

2023-08-15 13:23:28 [main] [INFO] KGenProgMain - entered the era of 89th generation.
2023-08-15 13:32:44 [main] [INFO] KGenProgMain -

---

Elapsed time: 14 hours 58 minutes 3 seconds
Variants: generated 100, build-succeeded 12, build-failed 41, syntax-invalid 46, redundant 1
Fitness: max 0.944(11), min 0.833(1), ave 0.935
Test execution time: sum 543242 ms, max 180237 ms, min 213 ms

---

2023-08-15 13:32:44 [main] [INFO] KGenProgMain - entered the era of 90th generation.
2023-08-15 13:33:04 [main] [INFO] KGenProgMain -

---

Elapsed time: 14 hours 58 minutes 22 seconds
Variants: generated 100, build-succeeded 28, build-failed 27, syntax-invalid 43, redundant 2
Fitness: max 1(1), min 0.944(27), ave 0.946
Test execution time: sum 7426 ms, max 371 ms, min 215 ms

---

2023-08-15 13:33:04 [main] [INFO] KGenProgMain - entered the era of 91st generation.
2023-08-15 13:36:24 [main] [INFO] KGenProgMain -

---

Elapsed time: 15 hours 1 minutes 43 seconds
Variants: generated 100, build-succeeded 26, build-failed 32, syntax-invalid 37, redundant 5
Fitness: max 1(1), min 0.944(25), ave 0.947
Test execution time: sum 187184 ms, max 180254 ms, min 212 ms

---

2023-08-15 13:36:24 [main] [INFO] KGenProgMain - entered the era of 92nd generation.
2023-08-15 13:36:49 [main] [INFO] KGenProgMain -

---

Elapsed time: 15 hours 2 minutes 8 seconds
Variants: generated 100, build-succeeded 19, build-failed 37, syntax-invalid 42, redundant 2
Fitness: max 0.944(19), min 0.944(19), ave 0.944
Test execution time: sum 6031 ms, max 539 ms, min 219 ms

---

2023-08-15 13:36:49 [main] [INFO] KGenProgMain - entered the era of 93rd generation.
2023-08-15 13:40:06 [main] [INFO] KGenProgMain -

---

Elapsed time: 15 hours 5 minutes 24 seconds
Variants: generated 100, build-succeeded 19, build-failed 29, syntax-invalid 48, redundant 4
Fitness: max 1(1), min 0.778(1), ave 0.939
Test execution time: sum 184954 ms, max 180345 ms, min 213 ms

---

2023-08-15 13:40:06 [main] [INFO] KGenProgMain - entered the era of 94th generation.
2023-08-15 13:40:24 [main] [INFO] KGenProgMain -

---

Elapsed time: 15 hours 5 minutes 42 seconds
Variants: generated 100, build-succeeded 20, build-failed 37, syntax-invalid 42, redundant 1
Fitness: max 0.944(19), min 0.833(1), ave 0.939
Test execution time: sum 5755 ms, max 616 ms, min 216 ms

---

2023-08-15 13:40:24 [main] [INFO] KGenProgMain - entered the era of 95th generation.
2023-08-15 13:40:41 [main] [INFO] KGenProgMain -

---

Elapsed time: 15 hours 6 minutes 0 seconds
Variants: generated 100, build-succeeded 16, build-failed 35, syntax-invalid 45, redundant 4
Fitness: max 0.944(15), min 0.556(1), ave 0.92
Test execution time: sum 4208 ms, max 504 ms, min 218 ms

---

2023-08-15 13:40:41 [main] [INFO] KGenProgMain - entered the era of 96th generation.
2023-08-15 13:46:59 [main] [INFO] KGenProgMain -

---

Elapsed time: 15 hours 12 minutes 17 seconds
Variants: generated 100, build-succeeded 20, build-failed 33, syntax-invalid 47, redundant 0
Fitness: max 1(1), min 0.889(1), ave 0.944
Test execution time: sum 365194 ms, max 360161 ms, min 217 ms

---

2023-08-15 13:46:59 [main] [INFO] KGenProgMain - entered the era of 97th generation.
2023-08-15 13:59:15 [main] [INFO] KGenProgMain -

---

Elapsed time: 15 hours 24 minutes 34 seconds
Variants: generated 100, build-succeeded 16, build-failed 34, syntax-invalid 48, redundant 2
Fitness: max 0.944(14), min 0.5(2), ave 0.889
Test execution time: sum 724113 ms, max 360181 ms, min 218 ms

---

2023-08-15 13:59:15 [main] [INFO] KGenProgMain - entered the era of 98th generation.
2023-08-15 13:59:31 [main] [INFO] KGenProgMain -

---

Elapsed time: 15 hours 24 minutes 50 seconds
Variants: generated 100, build-succeeded 17, build-failed 36, syntax-invalid 45, redundant 2
Fitness: max 0.944(17), min 0.944(17), ave 0.944
Test execution time: sum 4140 ms, max 418 ms, min 211 ms

---

2023-08-15 13:59:31 [main] [INFO] KGenProgMain - entered the era of 99th generation.
2023-08-15 13:59:48 [main] [INFO] KGenProgMain -

---

Elapsed time: 15 hours 25 minutes 6 seconds
Variants: generated 100, build-succeeded 17, build-failed 31, syntax-invalid 48, redundant 4
Fitness: max 0.944(17), min 0.944(17), ave 0.944
Test execution time: sum 4195 ms, max 437 ms, min 208 ms

---

2023-08-15 13:59:48 [main] [INFO] KGenProgMain - entered the era of 100th generation.
2023-08-15 14:00:05 [main] [INFO] KGenProgMain -

---

Elapsed time: 15 hours 25 minutes 24 seconds
Variants: generated 100, build-succeeded 18, build-failed 32, syntax-invalid 48, redundant 2
Fitness: max 0.944(16), min 0.833(2), ave 0.932
Test execution time: sum 4804 ms, max 443 ms, min 217 ms

---

2023-08-15 14:00:05 [main] [INFO] KGenProgMain - entered the era of 101st generation.
2023-08-15 14:03:21 [main] [INFO] KGenProgMain -

---

Elapsed time: 15 hours 28 minutes 40 seconds
Variants: generated 100, build-succeeded 15, build-failed 36, syntax-invalid 49, redundant 0
Fitness: max 0.944(14), min 0.889(1), ave 0.941
Test execution time: sum 183984 ms, max 180252 ms, min 214 ms

---

2023-08-15 14:03:21 [main] [INFO] KGenProgMain - entered the era of 102nd generation.
2023-08-15 14:03:37 [main] [INFO] KGenProgMain -

---

Elapsed time: 15 hours 28 minutes 55 seconds
Variants: generated 100, build-succeeded 13, build-failed 37, syntax-invalid 49, redundant 1
Fitness: max 0.944(11), min 0.833(2), ave 0.927
Test execution time: sum 3658 ms, max 490 ms, min 224 ms

---

2023-08-15 14:03:37 [main] [INFO] KGenProgMain - entered the era of 103rd generation.
2023-08-15 14:03:52 [main] [INFO] KGenProgMain -

---

Elapsed time: 15 hours 29 minutes 11 seconds
Variants: generated 100, build-succeeded 11, build-failed 36, syntax-invalid 52, redundant 1
Fitness: max 0.944(10), min 0.833(1), ave 0.934
Test execution time: sum 2759 ms, max 337 ms, min 222 ms

---

2023-08-15 14:03:52 [main] [INFO] KGenProgMain - entered the era of 104th generation.
2023-08-15 14:04:07 [main] [INFO] KGenProgMain -

---

Elapsed time: 15 hours 29 minutes 26 seconds
Variants: generated 100, build-succeeded 12, build-failed 35, syntax-invalid 52, redundant 1
Fitness: max 0.944(12), min 0.944(12), ave 0.944
Test execution time: sum 3214 ms, max 395 ms, min 230 ms

---

2023-08-15 14:04:07 [main] [INFO] KGenProgMain - entered the era of 105th generation.
2023-08-15 14:04:24 [main] [INFO] KGenProgMain -

---

Elapsed time: 15 hours 29 minutes 43 seconds
Variants: generated 100, build-succeeded 12, build-failed 33, syntax-invalid 51, redundant 4
Fitness: max 1(1), min 0.833(1), ave 0.94
Test execution time: sum 3664 ms, max 580 ms, min 229 ms

---

2023-08-15 14:04:24 [main] [INFO] KGenProgMain - entered the era of 106th generation.
2023-08-15 14:07:39 [main] [INFO] KGenProgMain -

---

Elapsed time: 15 hours 32 minutes 58 seconds
Variants: generated 100, build-succeeded 16, build-failed 33, syntax-invalid 50, redundant 1
Fitness: max 1(1), min 0.833(1), ave 0.941
Test execution time: sum 184173 ms, max 180250 ms, min 213 ms

---

2023-08-15 14:07:39 [main] [INFO] KGenProgMain - entered the era of 107th generation.
2023-08-15 14:10:54 [main] [INFO] KGenProgMain -

---

Elapsed time: 15 hours 36 minutes 13 seconds
Variants: generated 100, build-succeeded 11, build-failed 34, syntax-invalid 54, redundant 1
Fitness: max 0.944(11), min 0.944(11), ave 0.944
Test execution time: sum 182728 ms, max 180244 ms, min 206 ms

---

2023-08-15 14:10:54 [main] [INFO] KGenProgMain - entered the era of 108th generation.
2023-08-15 14:20:10 [main] [INFO] KGenProgMain -

---

Elapsed time: 15 hours 45 minutes 29 seconds
Variants: generated 100, build-succeeded 14, build-failed 33, syntax-invalid 51, redundant 2
Fitness: max 0.944(14), min 0.944(14), ave 0.944
Test execution time: sum 543844 ms, max 180295 ms, min 219 ms

---

2023-08-15 14:20:10 [main] [INFO] KGenProgMain - entered the era of 109th generation.
2023-08-15 14:20:29 [main] [INFO] KGenProgMain -

---

Elapsed time: 15 hours 45 minutes 47 seconds
Variants: generated 100, build-succeeded 11, build-failed 37, syntax-invalid 49, redundant 3
Fitness: max 0.944(10), min 0.833(1), ave 0.934
Test execution time: sum 6125 ms, max 3260 ms, min 229 ms

---

2023-08-15 14:20:29 [main] [INFO] KGenProgMain - entered the era of 110th generation.
2023-08-15 14:29:47 [main] [INFO] KGenProgMain -

---

Elapsed time: 15 hours 55 minutes 6 seconds
Variants: generated 100, build-succeeded 20, build-failed 26, syntax-invalid 50, redundant 4
Fitness: max 0.944(15), min 0.5(2), ave 0.886
Test execution time: sum 545799 ms, max 180365 ms, min 230 ms

---

2023-08-15 14:29:47 [main] [INFO] KGenProgMain - entered the era of 111th generation.
2023-08-15 14:33:05 [main] [INFO] KGenProgMain -

---

Elapsed time: 15 hours 58 minutes 24 seconds
Variants: generated 100, build-succeeded 14, build-failed 31, syntax-invalid 54, redundant 1
Fitness: max 0.944(11), min 0.5(1), ave 0.897
Test execution time: sum 184220 ms, max 180308 ms, min 230 ms

---

2023-08-15 14:33:05 [main] [INFO] KGenProgMain - entered the era of 112th generation.
2023-08-15 14:42:23 [main] [INFO] KGenProgMain -

---

Elapsed time: 16 hours 7 minutes 41 seconds
Variants: generated 100, build-succeeded 13, build-failed 34, syntax-invalid 52, redundant 1
Fitness: max 1(1), min 0.833(1), ave 0.94
Test execution time: sum 543830 ms, max 360320 ms, min 232 ms

---

2023-08-15 14:42:23 [main] [INFO] KGenProgMain - entered the era of 113th generation.
2023-08-15 14:42:40 [main] [INFO] KGenProgMain -

---

Elapsed time: 16 hours 7 minutes 58 seconds
Variants: generated 100, build-succeeded 15, build-failed 28, syntax-invalid 54, redundant 3
Fitness: max 1(1), min 0.889(1), ave 0.944
Test execution time: sum 4124 ms, max 406 ms, min 238 ms

---

2023-08-15 14:42:40 [main] [INFO] KGenProgMain - entered the era of 114th generation.
2023-08-15 14:42:58 [main] [INFO] KGenProgMain -

---

Elapsed time: 16 hours 8 minutes 16 seconds
Variants: generated 100, build-succeeded 15, build-failed 32, syntax-invalid 50, redundant 3
Fitness: max 1(1), min 0.5(1), ave 0.919
Test execution time: sum 3976 ms, max 375 ms, min 230 ms

---

2023-08-15 14:42:58 [main] [INFO] KGenProgMain - entered the era of 115th generation.
2023-08-15 14:46:15 [main] [INFO] KGenProgMain -

---

Elapsed time: 16 hours 11 minutes 34 seconds
Variants: generated 100, build-succeeded 15, build-failed 35, syntax-invalid 49, redundant 1
Fitness: max 0.944(14), min 0(1), ave 0.881
Test execution time: sum 183682 ms, max 180333 ms, min 83 ms

---

2023-08-15 14:46:15 [main] [INFO] KGenProgMain - entered the era of 116th generation.
2023-08-15 14:46:33 [main] [INFO] KGenProgMain -

---

Elapsed time: 16 hours 11 minutes 52 seconds
Variants: generated 100, build-succeeded 16, build-failed 31, syntax-invalid 52, redundant 1
Fitness: max 0.944(16), min 0.944(16), ave 0.944
Test execution time: sum 4105 ms, max 318 ms, min 229 ms

---

2023-08-15 14:46:33 [main] [INFO] KGenProgMain - entered the era of 117th generation.
2023-08-15 14:46:50 [main] [INFO] KGenProgMain -

---

Elapsed time: 16 hours 12 minutes 8 seconds
Variants: generated 100, build-succeeded 10, build-failed 35, syntax-invalid 51, redundant 4
Fitness: max 0.944(10), min 0.944(10), ave 0.944
Test execution time: sum 2922 ms, max 485 ms, min 232 ms

---

2023-08-15 14:46:50 [main] [INFO] KGenProgMain - entered the era of 118th generation.
2023-08-15 14:47:09 [main] [INFO] KGenProgMain -

---

Elapsed time: 16 hours 12 minutes 28 seconds
Variants: generated 100, build-succeeded 18, build-failed 32, syntax-invalid 49, redundant 1
Fitness: max 1(2), min 0.5(1), ave 0.904
Test execution time: sum 4856 ms, max 359 ms, min 239 ms

---

2023-08-15 14:47:09 [main] [INFO] KGenProgMain - entered the era of 119th generation.
2023-08-15 15:17:27 [main] [INFO] KGenProgMain -

---

Elapsed time: 16 hours 42 minutes 45 seconds
Variants: generated 100, build-succeeded 13, build-failed 34, syntax-invalid 52, redundant 1
Fitness: max 1(2), min 0.444(1), ave 0.915
Test execution time: sum 1803893 ms, max 1800245 ms, min 234 ms

---

2023-08-15 15:17:27 [main] [INFO] KGenProgMain - entered the era of 120th generation.
2023-08-15 15:23:46 [main] [INFO] KGenProgMain -

---

Elapsed time: 16 hours 49 minutes 5 seconds
Variants: generated 100, build-succeeded 14, build-failed 31, syntax-invalid 51, redundant 4
Fitness: max 0.944(12), min 0.833(2), ave 0.929
Test execution time: sum 363731 ms, max 180246 ms, min 222 ms

---

2023-08-15 15:23:46 [main] [INFO] KGenProgMain - entered the era of 121st generation.
2023-08-15 15:30:10 [main] [INFO] KGenProgMain -

---

Elapsed time: 16 hours 55 minutes 29 seconds
Variants: generated 100, build-succeeded 13, build-failed 36, syntax-invalid 51, redundant 0
Fitness: max 0.944(12), min 0.889(1), ave 0.94
Test execution time: sum 364594 ms, max 180336 ms, min 227 ms

---

2023-08-15 15:30:10 [main] [INFO] KGenProgMain - entered the era of 122nd generation.
2023-08-15 15:30:35 [main] [INFO] KGenProgMain -

---

Elapsed time: 16 hours 55 minutes 54 seconds
Variants: generated 100, build-succeeded 17, build-failed 36, syntax-invalid 45, redundant 2
Fitness: max 0.944(15), min 0.833(1), ave 0.935
Test execution time: sum 4949 ms, max 385 ms, min 229 ms

---

2023-08-15 15:30:35 [main] [INFO] KGenProgMain - entered the era of 123rd generation.
2023-08-15 15:30:52 [main] [INFO] KGenProgMain -

---

Elapsed time: 16 hours 56 minutes 11 seconds
Variants: generated 100, build-succeeded 13, build-failed 36, syntax-invalid 51, redundant 0
Fitness: max 0.944(12), min 0.889(1), ave 0.94
Test execution time: sum 3208 ms, max 296 ms, min 218 ms

---

2023-08-15 15:30:52 [main] [INFO] KGenProgMain - entered the era of 124th generation.
2023-08-15 15:34:09 [main] [INFO] KGenProgMain -

---

Elapsed time: 16 hours 59 minutes 28 seconds
Variants: generated 100, build-succeeded 11, build-failed 36, syntax-invalid 51, redundant 2
Fitness: max 0.944(11), min 0.944(11), ave 0.944
Test execution time: sum 183055 ms, max 180256 ms, min 226 ms

---

2023-08-15 15:34:09 [main] [INFO] KGenProgMain - entered the era of 125th generation.
2023-08-15 15:37:26 [main] [INFO] KGenProgMain -

---

Elapsed time: 17 hours 2 minutes 45 seconds
Variants: generated 100, build-succeeded 17, build-failed 28, syntax-invalid 53, redundant 2
Fitness: max 0.944(17), min 0.944(17), ave 0.944
Test execution time: sum 184485 ms, max 180241 ms, min 212 ms

---

2023-08-15 15:37:26 [main] [INFO] KGenProgMain - entered the era of 126th generation.
2023-08-15 15:40:43 [main] [INFO] KGenProgMain -

---

Elapsed time: 17 hours 6 minutes 2 seconds
Variants: generated 100, build-succeeded 16, build-failed 33, syntax-invalid 48, redundant 3
Fitness: max 1(1), min 0.833(1), ave 0.941
Test execution time: sum 183876 ms, max 180220 ms, min 208 ms

---

2023-08-15 15:40:43 [main] [INFO] KGenProgMain - entered the era of 127th generation.
2023-08-15 15:41:02 [main] [INFO] KGenProgMain -

---

Elapsed time: 17 hours 6 minutes 21 seconds
Variants: generated 100, build-succeeded 18, build-failed 30, syntax-invalid 51, redundant 1
Fitness: max 0.944(18), min 0.944(18), ave 0.944
Test execution time: sum 4272 ms, max 310 ms, min 203 ms

---

2023-08-15 15:41:02 [main] [INFO] KGenProgMain - entered the era of 128th generation.
2023-08-15 15:41:21 [main] [INFO] KGenProgMain -

---

Elapsed time: 17 hours 6 minutes 39 seconds
Variants: generated 100, build-succeeded 13, build-failed 33, syntax-invalid 51, redundant 3
Fitness: max 0.944(13), min 0.944(13), ave 0.944
Test execution time: sum 3491 ms, max 383 ms, min 203 ms

---

2023-08-15 15:41:21 [main] [INFO] KGenProgMain - entered the era of 129th generation.
2023-08-15 15:41:37 [main] [INFO] KGenProgMain -

---

Elapsed time: 17 hours 6 minutes 56 seconds
Variants: generated 100, build-succeeded 8, build-failed 40, syntax-invalid 52, redundant 0
Fitness: max 1(1), min 0.833(1), ave 0.938
Test execution time: sum 2057 ms, max 387 ms, min 218 ms

---

2023-08-15 15:41:37 [main] [INFO] KGenProgMain - entered the era of 130th generation.
2023-08-15 15:41:54 [main] [INFO] KGenProgMain -

---

Elapsed time: 17 hours 7 minutes 13 seconds
Variants: generated 100, build-succeeded 12, build-failed 32, syntax-invalid 51, redundant 5
Fitness: max 1(1), min 0.833(1), ave 0.94
Test execution time: sum 3096 ms, max 350 ms, min 225 ms

---

2023-08-15 15:41:54 [main] [INFO] KGenProgMain - entered the era of 131st generation.
2023-08-15 15:42:14 [main] [INFO] KGenProgMain -

---

Elapsed time: 17 hours 7 minutes 32 seconds
Variants: generated 100, build-succeeded 20, build-failed 28, syntax-invalid 51, redundant 1
Fitness: max 0.944(19), min 0.5(1), ave 0.922
Test execution time: sum 5185 ms, max 355 ms, min 218 ms

---

2023-08-15 15:42:14 [main] [INFO] KGenProgMain - entered the era of 132nd generation.
2023-08-15 15:42:33 [main] [INFO] KGenProgMain -

---

Elapsed time: 17 hours 7 minutes 52 seconds
Variants: generated 100, build-succeeded 16, build-failed 27, syntax-invalid 56, redundant 1
Fitness: max 0.944(15), min 0.556(1), ave 0.92
Test execution time: sum 4275 ms, max 356 ms, min 221 ms

---

2023-08-15 15:42:33 [main] [INFO] KGenProgMain - entered the era of 133rd generation.
2023-08-15 15:42:51 [main] [INFO] KGenProgMain -

---

Elapsed time: 17 hours 8 minutes 10 seconds
Variants: generated 100, build-succeeded 14, build-failed 31, syntax-invalid 52, redundant 3
Fitness: max 0.944(13), min 0(1), ave 0.877
Test execution time: sum 3836 ms, max 473 ms, min 79 ms

---

2023-08-15 15:42:51 [main] [INFO] KGenProgMain - entered the era of 134th generation.
2023-08-15 15:46:08 [main] [INFO] KGenProgMain -

---

Elapsed time: 17 hours 11 minutes 27 seconds
Variants: generated 100, build-succeeded 8, build-failed 36, syntax-invalid 52, redundant 4
Fitness: max 0.944(7), min 0.833(1), ave 0.931
Test execution time: sum 182263 ms, max 180284 ms, min 221 ms

---

2023-08-15 15:46:08 [main] [INFO] KGenProgMain - entered the era of 135th generation.
2023-08-15 15:46:27 [main] [INFO] KGenProgMain -

---

Elapsed time: 17 hours 11 minutes 46 seconds
Variants: generated 100, build-succeeded 16, build-failed 33, syntax-invalid 49, redundant 2
Fitness: max 1(1), min 0.444(1), ave 0.906
Test execution time: sum 4411 ms, max 511 ms, min 221 ms

---

2023-08-15 15:46:27 [main] [INFO] KGenProgMain - entered the era of 136th generation.
2023-08-15 15:46:48 [main] [INFO] KGenProgMain -

---

Elapsed time: 17 hours 12 minutes 6 seconds
Variants: generated 100, build-succeeded 9, build-failed 32, syntax-invalid 56, redundant 3
Fitness: max 0.944(9), min 0.944(9), ave 0.944
Test execution time: sum 2449 ms, max 353 ms, min 238 ms

---

2023-08-15 15:46:48 [main] [INFO] KGenProgMain - entered the era of 137th generation.
2023-08-15 15:47:10 [main] [INFO] KGenProgMain -

---

Elapsed time: 17 hours 12 minutes 29 seconds
Variants: generated 100, build-succeeded 14, build-failed 36, syntax-invalid 50, redundant 0
Fitness: max 0.944(13), min 0.889(1), ave 0.94
Test execution time: sum 4299 ms, max 513 ms, min 224 ms

---

2023-08-15 15:47:10 [main] [INFO] KGenProgMain - entered the era of 138th generation.
2023-08-15 15:47:30 [main] [INFO] KGenProgMain -

---

Elapsed time: 17 hours 12 minutes 48 seconds
Variants: generated 100, build-succeeded 14, build-failed 34, syntax-invalid 50, redundant 2
Fitness: max 1(1), min 0.833(1), ave 0.94
Test execution time: sum 3344 ms, max 254 ms, min 222 ms

---

2023-08-15 15:47:30 [main] [INFO] KGenProgMain - entered the era of 139th generation.
2023-08-15 15:50:49 [main] [INFO] KGenProgMain -

---

Elapsed time: 17 hours 16 minutes 8 seconds
Variants: generated 100, build-succeeded 11, build-failed 34, syntax-invalid 54, redundant 1
Fitness: max 0.944(9), min 0.833(1), ave 0.929
Test execution time: sum 182875 ms, max 180264 ms, min 227 ms

---

2023-08-15 15:50:49 [main] [INFO] KGenProgMain - entered the era of 140th generation.
2023-08-15 15:57:07 [main] [INFO] KGenProgMain -

---

Elapsed time: 17 hours 22 minutes 26 seconds
Variants: generated 100, build-succeeded 12, build-failed 33, syntax-invalid 52, redundant 3
Fitness: max 0.944(10), min 0.5(1), ave 0.898
Test execution time: sum 362804 ms, max 360141 ms, min 215 ms

---

2023-08-15 15:57:07 [main] [INFO] KGenProgMain - entered the era of 141st generation.
2023-08-15 15:57:26 [main] [INFO] KGenProgMain -

---

Elapsed time: 17 hours 22 minutes 44 seconds
Variants: generated 100, build-succeeded 13, build-failed 34, syntax-invalid 53, redundant 0
Fitness: max 1(2), min 0.944(11), ave 0.953
Test execution time: sum 3340 ms, max 414 ms, min 219 ms

---

2023-08-15 15:57:26 [main] [INFO] KGenProgMain - entered the era of 142nd generation.
2023-08-15 16:00:45 [main] [INFO] KGenProgMain -

---

Elapsed time: 17 hours 26 minutes 4 seconds
Variants: generated 100, build-succeeded 13, build-failed 35, syntax-invalid 51, redundant 1
Fitness: max 0.944(11), min 0.556(1), ave 0.91
Test execution time: sum 183160 ms, max 180222 ms, min 208 ms

---

2023-08-15 16:00:45 [main] [INFO] KGenProgMain - entered the era of 143rd generation.
2023-08-15 16:01:06 [main] [INFO] KGenProgMain -

---

Elapsed time: 17 hours 26 minutes 24 seconds
Variants: generated 100, build-succeeded 15, build-failed 29, syntax-invalid 52, redundant 4
Fitness: max 0.944(14), min 0.833(1), ave 0.937
Test execution time: sum 3708 ms, max 346 ms, min 215 ms

---

2023-08-15 16:01:06 [main] [INFO] KGenProgMain - entered the era of 144th generation.
2023-08-15 16:01:24 [main] [INFO] KGenProgMain -

---

Elapsed time: 17 hours 26 minutes 43 seconds
Variants: generated 100, build-succeeded 12, build-failed 32, syntax-invalid 55, redundant 1
Fitness: max 0.944(10), min 0.833(1), ave 0.931
Test execution time: sum 3095 ms, max 365 ms, min 225 ms

---

2023-08-15 16:01:24 [main] [INFO] KGenProgMain - entered the era of 145th generation.
2023-08-15 16:01:44 [main] [INFO] KGenProgMain -

---

Elapsed time: 17 hours 27 minutes 3 seconds
Variants: generated 100, build-succeeded 15, build-failed 33, syntax-invalid 50, redundant 2
Fitness: max 0.944(15), min 0.944(15), ave 0.944
Test execution time: sum 3820 ms, max 340 ms, min 217 ms

---

2023-08-15 16:01:44 [main] [INFO] KGenProgMain - entered the era of 146th generation.
2023-08-15 16:02:04 [main] [INFO] KGenProgMain -

---

Elapsed time: 17 hours 27 minutes 23 seconds
Variants: generated 100, build-succeeded 12, build-failed 34, syntax-invalid 53, redundant 1
Fitness: max 0.944(12), min 0.944(12), ave 0.944
Test execution time: sum 3319 ms, max 481 ms, min 222 ms

---

2023-08-15 16:02:04 [main] [INFO] KGenProgMain - entered the era of 147th generation.
2023-08-15 16:02:25 [main] [INFO] KGenProgMain -

---

Elapsed time: 17 hours 27 minutes 44 seconds
Variants: generated 100, build-succeeded 13, build-failed 31, syntax-invalid 52, redundant 4
Fitness: max 0.944(10), min 0.444(1), ave 0.863
Test execution time: sum 3362 ms, max 363 ms, min 221 ms

---

2023-08-15 16:02:25 [main] [INFO] KGenProgMain - entered the era of 148th generation.
2023-08-15 16:02:47 [main] [INFO] KGenProgMain -

---

Elapsed time: 17 hours 28 minutes 5 seconds
Variants: generated 100, build-succeeded 18, build-failed 29, syntax-invalid 51, redundant 2
Fitness: max 1(2), min 0.833(1), ave 0.944
Test execution time: sum 4605 ms, max 473 ms, min 214 ms

---

2023-08-15 16:02:47 [main] [INFO] KGenProgMain - entered the era of 149th generation.
2023-08-15 16:03:07 [main] [INFO] KGenProgMain -

---

Elapsed time: 17 hours 28 minutes 25 seconds
Variants: generated 100, build-succeeded 13, build-failed 32, syntax-invalid 52, redundant 3
Fitness: max 0.944(12), min 0.833(1), ave 0.936
Test execution time: sum 3467 ms, max 374 ms, min 225 ms

---

2023-08-15 16:03:07 [main] [INFO] KGenProgMain - entered the era of 150th generation.
2023-08-15 16:06:26 [main] [INFO] KGenProgMain -

---

Elapsed time: 17 hours 31 minutes 45 seconds
Variants: generated 100, build-succeeded 14, build-failed 29, syntax-invalid 54, redundant 3
Fitness: max 0.944(12), min 0.833(2), ave 0.929
Test execution time: sum 183454 ms, max 180362 ms, min 221 ms

---

2023-08-15 16:06:26 [main] [INFO] KGenProgMain - entered the era of 151st generation.
2023-08-15 16:09:46 [main] [INFO] KGenProgMain -

---

Elapsed time: 17 hours 35 minutes 5 seconds
Variants: generated 100, build-succeeded 13, build-failed 31, syntax-invalid 54, redundant 2
Fitness: max 1(1), min 0.833(1), ave 0.94
Test execution time: sum 183142 ms, max 180219 ms, min 213 ms

---

2023-08-15 16:09:46 [main] [INFO] KGenProgMain - entered the era of 152nd generation.
2023-08-15 16:10:07 [main] [INFO] KGenProgMain -

---

Elapsed time: 17 hours 35 minutes 26 seconds
Variants: generated 100, build-succeeded 15, build-failed 29, syntax-invalid 54, redundant 2
Fitness: max 1(1), min 0.833(1), ave 0.941
Test execution time: sum 4010 ms, max 476 ms, min 215 ms

---

2023-08-15 16:10:07 [main] [INFO] KGenProgMain - entered the era of 153rd generation.
2023-08-15 16:10:29 [main] [INFO] KGenProgMain -

---

Elapsed time: 17 hours 35 minutes 47 seconds
Variants: generated 100, build-succeeded 15, build-failed 29, syntax-invalid 53, redundant 3
Fitness: max 1(1), min 0.833(2), ave 0.93
Test execution time: sum 3952 ms, max 453 ms, min 214 ms

---

2023-08-15 16:10:29 [main] [INFO] KGenProgMain - entered the era of 154th generation.
2023-08-15 16:10:50 [main] [INFO] KGenProgMain -

---

Elapsed time: 17 hours 36 minutes 9 seconds
Variants: generated 100, build-succeeded 13, build-failed 35, syntax-invalid 52, redundant 0
Fitness: max 0.944(9), min 0.5(1), ave 0.889
Test execution time: sum 3793 ms, max 473 ms, min 216 ms

---

2023-08-15 16:10:50 [main] [INFO] KGenProgMain - entered the era of 155th generation.
2023-08-15 16:11:09 [main] [INFO] KGenProgMain -

---

Elapsed time: 17 hours 36 minutes 28 seconds
Variants: generated 100, build-succeeded 10, build-failed 31, syntax-invalid 53, redundant 6
Fitness: max 0.944(9), min 0.611(1), ave 0.911
Test execution time: sum 2798 ms, max 505 ms, min 231 ms

---

2023-08-15 16:11:09 [main] [INFO] KGenProgMain - entered the era of 156th generation.
2023-08-15 16:11:31 [main] [INFO] KGenProgMain -

---

Elapsed time: 17 hours 36 minutes 50 seconds
Variants: generated 100, build-succeeded 13, build-failed 34, syntax-invalid 49, redundant 4
Fitness: max 0.944(13), min 0.944(13), ave 0.944
Test execution time: sum 3790 ms, max 454 ms, min 223 ms

---

2023-08-15 16:11:31 [main] [INFO] KGenProgMain - entered the era of 157th generation.
2023-08-15 16:11:53 [main] [INFO] KGenProgMain -

---

Elapsed time: 17 hours 37 minutes 11 seconds
Variants: generated 100, build-succeeded 13, build-failed 30, syntax-invalid 54, redundant 3
Fitness: max 0.944(12), min 0.5(1), ave 0.91
Test execution time: sum 3471 ms, max 343 ms, min 230 ms

---

2023-08-15 16:11:53 [main] [INFO] KGenProgMain - entered the era of 158th generation.
2023-08-15 16:12:13 [main] [INFO] KGenProgMain -

---

Elapsed time: 17 hours 37 minutes 32 seconds
Variants: generated 100, build-succeeded 13, build-failed 31, syntax-invalid 53, redundant 3
Fitness: max 0.944(10), min 0.667(1), ave 0.91
Test execution time: sum 3174 ms, max 271 ms, min 224 ms

---

2023-08-15 16:12:13 [main] [INFO] KGenProgMain - entered the era of 159th generation.
2023-08-15 16:15:32 [main] [INFO] KGenProgMain -

---

Elapsed time: 17 hours 40 minutes 51 seconds
Variants: generated 100, build-succeeded 9, build-failed 37, syntax-invalid 52, redundant 2
Fitness: max 0.944(7), min 0.5(1), ave 0.883
Test execution time: sum 182508 ms, max 180270 ms, min 230 ms

---

2023-08-15 16:15:32 [main] [INFO] KGenProgMain - entered the era of 160th generation.
2023-08-15 16:15:54 [main] [INFO] KGenProgMain -

---

Elapsed time: 17 hours 41 minutes 13 seconds
Variants: generated 100, build-succeeded 16, build-failed 31, syntax-invalid 51, redundant 2
Fitness: max 0.944(12), min 0.5(2), ave 0.858
Test execution time: sum 4153 ms, max 451 ms, min 212 ms

---

2023-08-15 16:15:54 [main] [INFO] KGenProgMain - entered the era of 161st generation.
2023-08-15 16:16:14 [main] [INFO] KGenProgMain -

---

Elapsed time: 17 hours 41 minutes 33 seconds
Variants: generated 100, build-succeeded 8, build-failed 30, syntax-invalid 59, redundant 3
Fitness: max 0.944(5), min 0.5(1), ave 0.861
Test execution time: sum 2051 ms, max 329 ms, min 222 ms

---

2023-08-15 16:16:14 [main] [INFO] KGenProgMain - entered the era of 162nd generation.
2023-08-15 16:16:35 [main] [INFO] KGenProgMain -

---

Elapsed time: 17 hours 41 minutes 54 seconds
Variants: generated 100, build-succeeded 14, build-failed 32, syntax-invalid 53, redundant 1
Fitness: max 0.944(11), min 0.611(2), ave 0.893
Test execution time: sum 3456 ms, max 325 ms, min 216 ms

---

2023-08-15 16:16:35 [main] [INFO] KGenProgMain - entered the era of 163rd generation.
2023-08-15 16:16:55 [main] [INFO] KGenProgMain -

---

Elapsed time: 17 hours 42 minutes 14 seconds
Variants: generated 100, build-succeeded 16, build-failed 29, syntax-invalid 54, redundant 1
Fitness: max 0.944(13), min 0.5(1), ave 0.889
Test execution time: sum 4747 ms, max 410 ms, min 225 ms

---

2023-08-15 16:16:55 [main] [INFO] KGenProgMain - entered the era of 164th generation.
2023-08-15 16:17:16 [main] [INFO] KGenProgMain -

---

Elapsed time: 17 hours 42 minutes 34 seconds
Variants: generated 100, build-succeeded 13, build-failed 27, syntax-invalid 54, redundant 6
Fitness: max 0.944(12), min 0.889(1), ave 0.94
Test execution time: sum 3414 ms, max 416 ms, min 217 ms

---

2023-08-15 16:17:16 [main] [INFO] KGenProgMain - entered the era of 165th generation.
2023-08-15 16:17:39 [main] [INFO] KGenProgMain -

---

Elapsed time: 17 hours 42 minutes 58 seconds
Variants: generated 100, build-succeeded 12, build-failed 32, syntax-invalid 54, redundant 2
Fitness: max 0.944(12), min 0.944(12), ave 0.944
Test execution time: sum 3346 ms, max 403 ms, min 220 ms

---

2023-08-15 16:17:39 [main] [INFO] KGenProgMain - entered the era of 166th generation.
2023-08-15 16:18:06 [main] [INFO] KGenProgMain -

---

Elapsed time: 17 hours 43 minutes 25 seconds
Variants: generated 100, build-succeeded 6, build-failed 40, syntax-invalid 50, redundant 4
Fitness: max 0.944(6), min 0.944(6), ave 0.944
Test execution time: sum 1960 ms, max 618 ms, min 239 ms

---

2023-08-15 16:18:06 [main] [INFO] KGenProgMain - entered the era of 167th generation.
2023-08-15 16:18:27 [main] [INFO] KGenProgMain -

---

Elapsed time: 17 hours 43 minutes 46 seconds
Variants: generated 100, build-succeeded 10, build-failed 29, syntax-invalid 58, redundant 3
Fitness: max 0.944(10), min 0.944(10), ave 0.944
Test execution time: sum 2593 ms, max 368 ms, min 225 ms

---

2023-08-15 16:18:27 [main] [INFO] KGenProgMain - entered the era of 168th generation.
2023-08-15 16:18:48 [main] [INFO] KGenProgMain -

---

Elapsed time: 17 hours 44 minutes 7 seconds
Variants: generated 100, build-succeeded 9, build-failed 36, syntax-invalid 54, redundant 1
Fitness: max 0.944(8), min 0.833(1), ave 0.932
Test execution time: sum 2155 ms, max 284 ms, min 220 ms

---

2023-08-15 16:18:48 [main] [INFO] KGenProgMain - entered the era of 169th generation.
2023-08-15 16:19:07 [main] [INFO] KGenProgMain -

---

Elapsed time: 17 hours 44 minutes 26 seconds
Variants: generated 100, build-succeeded 8, build-failed 32, syntax-invalid 55, redundant 5
Fitness: max 0.944(8), min 0.944(8), ave 0.944
Test execution time: sum 2052 ms, max 326 ms, min 215 ms

---

2023-08-15 16:19:07 [main] [INFO] KGenProgMain - entered the era of 170th generation.
2023-08-15 16:19:27 [main] [INFO] KGenProgMain -

---

Elapsed time: 17 hours 44 minutes 46 seconds
Variants: generated 100, build-succeeded 10, build-failed 31, syntax-invalid 55, redundant 4
Fitness: max 0.944(9), min 0.5(1), ave 0.9
Test execution time: sum 2561 ms, max 361 ms, min 220 ms

---

2023-08-15 16:19:27 [main] [INFO] KGenProgMain - entered the era of 171st generation.
2023-08-15 16:19:47 [main] [INFO] KGenProgMain -

---

Elapsed time: 17 hours 45 minutes 6 seconds
Variants: generated 100, build-succeeded 11, build-failed 34, syntax-invalid 53, redundant 2
Fitness: max 0.944(9), min 0.722(1), ave 0.914
Test execution time: sum 3220 ms, max 488 ms, min 232 ms

---

2023-08-15 16:19:47 [main] [INFO] KGenProgMain - entered the era of 172nd generation.
2023-08-15 16:20:07 [main] [INFO] KGenProgMain -

---

Elapsed time: 17 hours 45 minutes 25 seconds
Variants: generated 100, build-succeeded 6, build-failed 39, syntax-invalid 53, redundant 2
Fitness: max 1(1), min 0.944(5), ave 0.954
Test execution time: sum 1567 ms, max 346 ms, min 236 ms

---

2023-08-15 16:20:07 [main] [INFO] KGenProgMain - entered the era of 173rd generation.
2023-08-15 16:20:27 [main] [INFO] KGenProgMain -

---

Elapsed time: 17 hours 45 minutes 45 seconds
Variants: generated 100, build-succeeded 11, build-failed 32, syntax-invalid 54, redundant 3
Fitness: max 0.944(9), min 0.611(1), ave 0.904
Test execution time: sum 2975 ms, max 370 ms, min 219 ms

---

2023-08-15 16:20:27 [main] [INFO] KGenProgMain - entered the era of 174th generation.
2023-08-15 16:23:48 [main] [INFO] KGenProgMain -

---

Elapsed time: 17 hours 49 minutes 6 seconds
Variants: generated 100, build-succeeded 9, build-failed 36, syntax-invalid 53, redundant 2
Fitness: max 0.944(7), min 0.833(2), ave 0.92
Test execution time: sum 182163 ms, max 180226 ms, min 216 ms

---

2023-08-15 16:23:48 [main] [INFO] KGenProgMain - entered the era of 175th generation.
2023-08-15 16:24:09 [main] [INFO] KGenProgMain -

---

Elapsed time: 17 hours 49 minutes 28 seconds
Variants: generated 100, build-succeeded 13, build-failed 31, syntax-invalid 51, redundant 5
Fitness: max 0.944(11), min 0.833(2), ave 0.927
Test execution time: sum 3452 ms, max 353 ms, min 224 ms

---

2023-08-15 16:24:09 [main] [INFO] KGenProgMain - entered the era of 176th generation.
2023-08-15 16:24:33 [main] [INFO] KGenProgMain -

---

Elapsed time: 17 hours 49 minutes 52 seconds
Variants: generated 100, build-succeeded 13, build-failed 31, syntax-invalid 56, redundant 0
Fitness: max 0.944(13), min 0.944(13), ave 0.944
Test execution time: sum 3636 ms, max 512 ms, min 214 ms

---

2023-08-15 16:24:33 [main] [INFO] KGenProgMain - entered the era of 177th generation.
2023-08-15 16:27:58 [main] [INFO] KGenProgMain -

---

Elapsed time: 17 hours 53 minutes 17 seconds
Variants: generated 100, build-succeeded 11, build-failed 33, syntax-invalid 54, redundant 2
Fitness: max 0.944(8), min 0.833(3), ave 0.914
Test execution time: sum 183206 ms, max 180485 ms, min 227 ms

---

2023-08-15 16:27:58 [main] [INFO] KGenProgMain - entered the era of 178th generation.
2023-08-15 16:31:25 [main] [INFO] KGenProgMain -

---

Elapsed time: 17 hours 56 minutes 44 seconds
Variants: generated 100, build-succeeded 16, build-failed 29, syntax-invalid 54, redundant 1
Fitness: max 0.944(11), min 0.722(1), ave 0.91
Test execution time: sum 184040 ms, max 180218 ms, min 215 ms

---

2023-08-15 16:31:25 [main] [INFO] KGenProgMain - entered the era of 179th generation.
2023-08-15 16:31:46 [main] [INFO] KGenProgMain -

---

Elapsed time: 17 hours 57 minutes 4 seconds
Variants: generated 100, build-succeeded 9, build-failed 33, syntax-invalid 55, redundant 3
Fitness: max 0.944(7), min 0.611(1), ave 0.901
Test execution time: sum 2505 ms, max 359 ms, min 232 ms

---

2023-08-15 16:31:46 [main] [INFO] KGenProgMain - entered the era of 180th generation.
2023-08-15 16:35:06 [main] [INFO] KGenProgMain -

---

Elapsed time: 18 hours 25 seconds
Variants: generated 100, build-succeeded 7, build-failed 34, syntax-invalid 54, redundant 5
Fitness: max 0.944(6), min 0.5(1), ave 0.881
Test execution time: sum 181896 ms, max 180231 ms, min 215 ms

---

2023-08-15 16:35:06 [main] [INFO] KGenProgMain - entered the era of 181st generation.
2023-08-15 16:35:26 [main] [INFO] KGenProgMain -

---

Elapsed time: 18 hours 45 seconds
Variants: generated 100, build-succeeded 6, build-failed 41, syntax-invalid 53, redundant 0
Fitness: max 0.944(3), min 0.444(1), ave 0.769
Test execution time: sum 1477 ms, max 328 ms, min 211 ms

---

2023-08-15 16:35:26 [main] [INFO] KGenProgMain - entered the era of 182nd generation.
2023-08-15 16:35:48 [main] [INFO] KGenProgMain -

---

Elapsed time: 18 hours 1 minutes 7 seconds
Variants: generated 100, build-succeeded 15, build-failed 28, syntax-invalid 55, redundant 2
Fitness: max 0.944(14), min 0.833(1), ave 0.937
Test execution time: sum 3999 ms, max 425 ms, min 226 ms

---

2023-08-15 16:35:48 [main] [INFO] KGenProgMain - entered the era of 183rd generation.
2023-08-15 16:36:10 [main] [INFO] KGenProgMain -

---

Elapsed time: 18 hours 1 minutes 29 seconds
Variants: generated 100, build-succeeded 9, build-failed 34, syntax-invalid 56, redundant 1
Fitness: max 0.944(7), min 0.833(2), ave 0.92
Test execution time: sum 2270 ms, max 297 ms, min 219 ms

---

2023-08-15 16:36:10 [main] [INFO] KGenProgMain - entered the era of 184th generation.
2023-08-15 16:36:33 [main] [INFO] KGenProgMain -

---

Elapsed time: 18 hours 1 minutes 52 seconds
Variants: generated 100, build-succeeded 11, build-failed 33, syntax-invalid 53, redundant 3
Fitness: max 0.944(9), min 0.5(1), ave 0.894
Test execution time: sum 2832 ms, max 326 ms, min 220 ms

---

2023-08-15 16:36:33 [main] [INFO] KGenProgMain - entered the era of 185th generation.
2023-08-15 16:36:54 [main] [INFO] KGenProgMain -

---

Elapsed time: 18 hours 2 minutes 13 seconds
Variants: generated 100, build-succeeded 8, build-failed 30, syntax-invalid 58, redundant 4
Fitness: max 0.944(6), min 0.5(1), ave 0.875
Test execution time: sum 1868 ms, max 256 ms, min 217 ms

---

2023-08-15 16:36:54 [main] [INFO] KGenProgMain - entered the era of 186th generation.
2023-08-15 16:37:15 [main] [INFO] KGenProgMain -

---

Elapsed time: 18 hours 2 minutes 34 seconds
Variants: generated 100, build-succeeded 12, build-failed 30, syntax-invalid 53, redundant 5
Fitness: max 0.944(10), min 0.833(2), ave 0.926
Test execution time: sum 2928 ms, max 265 ms, min 227 ms

---

2023-08-15 16:37:15 [main] [INFO] KGenProgMain - entered the era of 187th generation.
2023-08-15 16:37:37 [main] [INFO] KGenProgMain -

---

Elapsed time: 18 hours 2 minutes 56 seconds
Variants: generated 100, build-succeeded 12, build-failed 31, syntax-invalid 54, redundant 3
Fitness: max 0.944(10), min 0.5(1), ave 0.903
Test execution time: sum 3432 ms, max 398 ms, min 233 ms

---

2023-08-15 16:37:38 [main] [INFO] KGenProgMain - entered the era of 188th generation.
2023-08-15 16:41:00 [main] [INFO] KGenProgMain -

---

Elapsed time: 18 hours 6 minutes 19 seconds
Variants: generated 100, build-succeeded 12, build-failed 34, syntax-invalid 52, redundant 2
Fitness: max 0.944(9), min 0.556(1), ave 0.894
Test execution time: sum 182850 ms, max 180238 ms, min 217 ms

---

2023-08-15 16:41:00 [main] [INFO] KGenProgMain - entered the era of 189th generation.
2023-08-15 16:41:21 [main] [INFO] KGenProgMain -

---

Elapsed time: 18 hours 6 minutes 40 seconds
Variants: generated 100, build-succeeded 9, build-failed 31, syntax-invalid 53, redundant 7
Fitness: max 0.944(8), min 0.833(1), ave 0.932
Test execution time: sum 2258 ms, max 304 ms, min 209 ms

---

2023-08-15 16:41:21 [main] [INFO] KGenProgMain - entered the era of 190th generation.
2023-08-15 16:41:44 [main] [INFO] KGenProgMain -

---

Elapsed time: 18 hours 7 minutes 3 seconds
Variants: generated 100, build-succeeded 13, build-failed 29, syntax-invalid 53, redundant 5
Fitness: max 0.944(10), min 0.611(1), ave 0.902
Test execution time: sum 3137 ms, max 277 ms, min 225 ms

---

2023-08-15 16:41:44 [main] [INFO] KGenProgMain - entered the era of 191st generation.
2023-08-15 16:42:06 [main] [INFO] KGenProgMain -

---

Elapsed time: 18 hours 7 minutes 25 seconds
Variants: generated 100, build-succeeded 11, build-failed 34, syntax-invalid 51, redundant 4
Fitness: max 0.944(11), min 0.944(11), ave 0.944
Test execution time: sum 2832 ms, max 381 ms, min 213 ms

---

2023-08-15 16:42:06 [main] [INFO] KGenProgMain - entered the era of 192nd generation.
2023-08-15 16:42:29 [main] [INFO] KGenProgMain -

---

Elapsed time: 18 hours 7 minutes 47 seconds
Variants: generated 100, build-succeeded 12, build-failed 31, syntax-invalid 54, redundant 3
Fitness: max 0.944(9), min 0.5(1), ave 0.889
Test execution time: sum 3343 ms, max 456 ms, min 233 ms

---

2023-08-15 16:42:29 [main] [INFO] KGenProgMain - entered the era of 193rd generation.
2023-08-15 16:42:50 [main] [INFO] KGenProgMain -

---

Elapsed time: 18 hours 8 minutes 9 seconds
Variants: generated 100, build-succeeded 9, build-failed 34, syntax-invalid 54, redundant 3
Fitness: max 0.944(8), min 0.833(1), ave 0.932
Test execution time: sum 2405 ms, max 344 ms, min 222 ms

---

2023-08-15 16:42:50 [main] [INFO] KGenProgMain - entered the era of 194th generation.
2023-08-15 16:43:12 [main] [INFO] KGenProgMain -

---

Elapsed time: 18 hours 8 minutes 30 seconds
Variants: generated 100, build-succeeded 10, build-failed 29, syntax-invalid 55, redundant 6
Fitness: max 0.944(8), min 0.444(1), ave 0.883
Test execution time: sum 2594 ms, max 446 ms, min 208 ms

---

2023-08-15 16:43:12 [main] [INFO] KGenProgMain - entered the era of 195th generation.
2023-08-15 16:43:35 [main] [INFO] KGenProgMain -

---

Elapsed time: 18 hours 8 minutes 53 seconds
Variants: generated 100, build-succeeded 7, build-failed 34, syntax-invalid 54, redundant 5
Fitness: max 0.944(4), min 0.833(2), ave 0.905
Test execution time: sum 1913 ms, max 352 ms, min 231 ms

---

2023-08-15 16:43:35 [main] [INFO] KGenProgMain - entered the era of 196th generation.
2023-08-15 16:43:57 [main] [INFO] KGenProgMain -

---

Elapsed time: 18 hours 9 minutes 15 seconds
Variants: generated 100, build-succeeded 11, build-failed 26, syntax-invalid 53, redundant 10
Fitness: max 0.944(8), min 0.5(1), ave 0.864
Test execution time: sum 2817 ms, max 312 ms, min 224 ms

---

2023-08-15 16:43:57 [main] [INFO] KGenProgMain - entered the era of 197th generation.
2023-08-15 16:44:18 [main] [INFO] KGenProgMain -

---

Elapsed time: 18 hours 9 minutes 36 seconds
Variants: generated 100, build-succeeded 8, build-failed 38, syntax-invalid 53, redundant 1
Fitness: max 0.944(7), min 0.833(1), ave 0.931
Test execution time: sum 2096 ms, max 313 ms, min 233 ms

---

2023-08-15 16:44:18 [main] [INFO] KGenProgMain - entered the era of 198th generation.
2023-08-15 16:50:41 [main] [INFO] KGenProgMain -

---

Elapsed time: 18 hours 16 minutes 0 seconds
Variants: generated 100, build-succeeded 12, build-failed 34, syntax-invalid 53, redundant 1
Fitness: max 0.944(7), min 0.5(1), ave 0.88
Test execution time: sum 363096 ms, max 180280 ms, min 225 ms

---

2023-08-15 16:50:41 [main] [INFO] KGenProgMain - entered the era of 199th generation.
2023-08-15 16:51:02 [main] [INFO] KGenProgMain -

---

Elapsed time: 18 hours 16 minutes 20 seconds
Variants: generated 100, build-succeeded 9, build-failed 35, syntax-invalid 53, redundant 3
Fitness: max 0.944(8), min 0.5(1), ave 0.895
Test execution time: sum 2253 ms, max 347 ms, min 218 ms

---

2023-08-15 16:51:02 [main] [INFO] KGenProgMain - entered the era of 200th generation.
2023-08-15 16:54:23 [main] [INFO] KGenProgMain -

---

Elapsed time: 18 hours 19 minutes 42 seconds
Variants: generated 100, build-succeeded 13, build-failed 32, syntax-invalid 52, redundant 3
Fitness: max 0.944(13), min 0.944(13), ave 0.944
Test execution time: sum 183380 ms, max 180229 ms, min 220 ms

---

2023-08-15 16:54:23 [main] [INFO] KGenProgMain - entered the era of 201st generation.
2023-08-15 16:54:45 [main] [INFO] KGenProgMain -

---

Elapsed time: 18 hours 20 minutes 4 seconds
Variants: generated 100, build-succeeded 13, build-failed 31, syntax-invalid 54, redundant 2
Fitness: max 0.944(12), min 0.556(1), ave 0.915
Test execution time: sum 3269 ms, max 371 ms, min 216 ms

---

2023-08-15 16:54:45 [main] [INFO] KGenProgMain - entered the era of 202nd generation.
2023-08-15 16:55:09 [main] [INFO] KGenProgMain -

---

Elapsed time: 18 hours 20 minutes 27 seconds
Variants: generated 100, build-succeeded 11, build-failed 31, syntax-invalid 54, redundant 4
Fitness: max 0.944(9), min 0.5(1), ave 0.894
Test execution time: sum 2885 ms, max 421 ms, min 216 ms

---

2023-08-15 16:55:09 [main] [INFO] KGenProgMain - entered the era of 203rd generation.
2023-08-15 16:58:32 [main] [INFO] KGenProgMain -

---

Elapsed time: 18 hours 23 minutes 50 seconds
Variants: generated 100, build-succeeded 14, build-failed 30, syntax-invalid 52, redundant 4
Fitness: max 0.944(13), min 0.889(1), ave 0.94
Test execution time: sum 183460 ms, max 180226 ms, min 209 ms

---

2023-08-15 16:58:32 [main] [INFO] KGenProgMain - entered the era of 204th generation.
2023-08-15 17:26:01 [main] [INFO] KGenProgMain -

---

Elapsed time: 18 hours 51 minutes 20 seconds
Variants: generated 100, build-succeeded 7, build-failed 37, syntax-invalid 54, redundant 2
Fitness: max 0.944(4), min 0.444(1), ave 0.849
Test execution time: sum 1621848 ms, max 1440214 ms, min 243 ms

---

2023-08-15 17:26:01 [main] [INFO] KGenProgMain - entered the era of 205th generation.
2023-08-15 17:26:24 [main] [INFO] KGenProgMain -

---

Elapsed time: 18 hours 51 minutes 42 seconds
Variants: generated 100, build-succeeded 13, build-failed 30, syntax-invalid 54, redundant 3
Fitness: max 0.944(12), min 0.833(1), ave 0.936
Test execution time: sum 3187 ms, max 331 ms, min 220 ms

---

2023-08-15 17:26:24 [main] [INFO] KGenProgMain - entered the era of 206th generation.
2023-08-15 17:32:47 [main] [INFO] KGenProgMain -

---

Elapsed time: 18 hours 58 minutes 5 seconds
Variants: generated 100, build-succeeded 10, build-failed 33, syntax-invalid 55, redundant 2
Fitness: max 0.944(9), min 0.889(1), ave 0.939
Test execution time: sum 362834 ms, max 180261 ms, min 235 ms

---

2023-08-15 17:32:47 [main] [INFO] KGenProgMain - entered the era of 207th generation.
2023-08-15 17:36:08 [main] [INFO] KGenProgMain -

---

Elapsed time: 19 hours 1 minutes 27 seconds
Variants: generated 100, build-succeeded 10, build-failed 34, syntax-invalid 54, redundant 2
Fitness: max 0.944(8), min 0.833(1), ave 0.928
Test execution time: sum 182908 ms, max 180248 ms, min 216 ms

---

2023-08-15 17:36:08 [main] [INFO] KGenProgMain - entered the era of 208th generation.
2023-08-15 17:36:30 [main] [INFO] KGenProgMain -

---

Elapsed time: 19 hours 1 minutes 49 seconds
Variants: generated 100, build-succeeded 10, build-failed 32, syntax-invalid 55, redundant 3
Fitness: max 0.944(8), min 0.5(1), ave 0.878
Test execution time: sum 2452 ms, max 302 ms, min 221 ms

---

2023-08-15 17:36:30 [main] [INFO] KGenProgMain - entered the era of 209th generation.
2023-08-15 17:36:52 [main] [INFO] KGenProgMain -

---

Elapsed time: 19 hours 2 minutes 11 seconds
Variants: generated 100, build-succeeded 8, build-failed 32, syntax-invalid 55, redundant 5
Fitness: max 1(1), min 0.944(7), ave 0.951
Test execution time: sum 2148 ms, max 338 ms, min 236 ms

---

2023-08-15 17:36:52 [main] [INFO] KGenProgMain - entered the era of 210th generation.
2023-08-15 17:37:14 [main] [INFO] KGenProgMain -

---

Elapsed time: 19 hours 2 minutes 33 seconds
Variants: generated 100, build-succeeded 9, build-failed 33, syntax-invalid 54, redundant 4
Fitness: max 0.944(8), min 0.833(1), ave 0.932
Test execution time: sum 2230 ms, max 326 ms, min 209 ms

---

2023-08-15 17:37:14 [main] [INFO] KGenProgMain - entered the era of 211th generation.
2023-08-15 17:43:40 [main] [INFO] KGenProgMain -

---

Elapsed time: 19 hours 8 minutes 59 seconds
Variants: generated 100, build-succeeded 15, build-failed 28, syntax-invalid 55, redundant 2
Fitness: max 0.944(11), min 0.5(1), ave 0.885
Test execution time: sum 363865 ms, max 180347 ms, min 217 ms

---

2023-08-15 17:43:40 [main] [INFO] KGenProgMain - entered the era of 212th generation.
2023-08-15 17:44:02 [main] [INFO] KGenProgMain -

---

Elapsed time: 19 hours 9 minutes 20 seconds
Variants: generated 100, build-succeeded 8, build-failed 35, syntax-invalid 55, redundant 2
Fitness: max 0.944(8), min 0.944(8), ave 0.944
Test execution time: sum 2159 ms, max 416 ms, min 222 ms

---

2023-08-15 17:44:02 [main] [INFO] KGenProgMain - entered the era of 213th generation.
2023-08-15 17:44:23 [main] [INFO] KGenProgMain -

---

Elapsed time: 19 hours 9 minutes 42 seconds
Variants: generated 100, build-succeeded 9, build-failed 34, syntax-invalid 53, redundant 4
Fitness: max 0.944(8), min 0.611(1), ave 0.907
Test execution time: sum 2107 ms, max 257 ms, min 215 ms

---

2023-08-15 17:44:23 [main] [INFO] KGenProgMain - entered the era of 214th generation.
2023-08-15 17:44:47 [main] [INFO] KGenProgMain -

---

Elapsed time: 19 hours 10 minutes 5 seconds
Variants: generated 100, build-succeeded 9, build-failed 32, syntax-invalid 55, redundant 4
Fitness: max 0.944(7), min 0.833(1), ave 0.926
Test execution time: sum 2431 ms, max 338 ms, min 221 ms

---

2023-08-15 17:44:47 [main] [INFO] KGenProgMain - entered the era of 215th generation.
2023-08-15 17:48:11 [main] [INFO] KGenProgMain -

---

Elapsed time: 19 hours 13 minutes 30 seconds
Variants: generated 100, build-succeeded 12, build-failed 33, syntax-invalid 53, redundant 2
Fitness: max 0.944(10), min 0.833(2), ave 0.926
Test execution time: sum 183030 ms, max 180226 ms, min 212 ms

---

2023-08-15 17:48:11 [main] [INFO] KGenProgMain - entered the era of 216th generation.
2023-08-15 17:48:32 [main] [INFO] KGenProgMain -

---

Elapsed time: 19 hours 13 minutes 51 seconds
Variants: generated 100, build-succeeded 6, build-failed 37, syntax-invalid 52, redundant 5
Fitness: max 0.944(6), min 0.944(6), ave 0.944
Test execution time: sum 1557 ms, max 382 ms, min 225 ms

---

2023-08-15 17:48:32 [main] [INFO] KGenProgMain - entered the era of 217th generation.
2023-08-15 17:51:56 [main] [INFO] KGenProgMain -

---

Elapsed time: 19 hours 17 minutes 15 seconds
Variants: generated 100, build-succeeded 14, build-failed 30, syntax-invalid 55, redundant 1
Fitness: max 0.944(13), min 0.611(1), ave 0.921
Test execution time: sum 183416 ms, max 180239 ms, min 221 ms

---

2023-08-15 17:51:56 [main] [INFO] KGenProgMain - entered the era of 218th generation.
2023-08-15 17:52:19 [main] [INFO] KGenProgMain -

---

Elapsed time: 19 hours 17 minutes 38 seconds
Variants: generated 100, build-succeeded 10, build-failed 33, syntax-invalid 54, redundant 3
Fitness: max 0.944(9), min 0.889(1), ave 0.939
Test execution time: sum 2461 ms, max 292 ms, min 217 ms

---

2023-08-15 17:52:19 [main] [INFO] KGenProgMain - entered the era of 219th generation.
2023-08-15 17:55:42 [main] [INFO] KGenProgMain -

---

Elapsed time: 19 hours 21 minutes 1 seconds
Variants: generated 100, build-succeeded 10, build-failed 34, syntax-invalid 52, redundant 4
Fitness: max 0.944(9), min 0.833(1), ave 0.933
Test execution time: sum 182601 ms, max 180273 ms, min 224 ms

---

2023-08-15 17:55:42 [main] [INFO] KGenProgMain - entered the era of 220th generation.
2023-08-15 17:59:05 [main] [INFO] KGenProgMain -

---

Elapsed time: 19 hours 24 minutes 24 seconds
Variants: generated 100, build-succeeded 8, build-failed 35, syntax-invalid 54, redundant 3
Fitness: max 0.944(6), min 0.5(1), ave 0.875
Test execution time: sum 181898 ms, max 180147 ms, min 238 ms

---

2023-08-15 17:59:05 [main] [INFO] KGenProgMain - entered the era of 221st generation.
2023-08-15 18:02:30 [main] [INFO] KGenProgMain -

---

Elapsed time: 19 hours 27 minutes 49 seconds
Variants: generated 100, build-succeeded 10, build-failed 37, syntax-invalid 52, redundant 1
Fitness: max 0.944(10), min 0.944(10), ave 0.944
Test execution time: sum 182657 ms, max 180299 ms, min 234 ms

---

2023-08-15 18:02:30 [main] [INFO] KGenProgMain - entered the era of 222nd generation.
2023-08-15 18:05:54 [main] [INFO] KGenProgMain -

---

Elapsed time: 19 hours 31 minutes 12 seconds
Variants: generated 100, build-succeeded 8, build-failed 30, syntax-invalid 57, redundant 5
Fitness: max 0.944(8), min 0.944(8), ave 0.944
Test execution time: sum 182012 ms, max 180260 ms, min 238 ms

---

2023-08-15 18:05:54 [main] [INFO] KGenProgMain - entered the era of 223rd generation.
2023-08-15 18:12:21 [main] [INFO] KGenProgMain -

---

Elapsed time: 19 hours 37 minutes 40 seconds
Variants: generated 100, build-succeeded 9, build-failed 29, syntax-invalid 59, redundant 3
Fitness: max 0.944(7), min 0.833(2), ave 0.92
Test execution time: sum 362198 ms, max 180212 ms, min 219 ms

---

2023-08-15 18:12:21 [main] [INFO] KGenProgMain - entered the era of 224th generation.
2023-08-15 18:12:45 [main] [INFO] KGenProgMain -

---

Elapsed time: 19 hours 38 minutes 3 seconds
Variants: generated 100, build-succeeded 8, build-failed 30, syntax-invalid 59, redundant 3
Fitness: max 0.944(7), min 0.889(1), ave 0.938
Test execution time: sum 2111 ms, max 345 ms, min 225 ms

---

2023-08-15 18:12:45 [main] [INFO] KGenProgMain - entered the era of 225th generation.
2023-08-15 18:13:08 [main] [INFO] KGenProgMain -

---

Elapsed time: 19 hours 38 minutes 26 seconds
Variants: generated 100, build-succeeded 8, build-failed 35, syntax-invalid 54, redundant 3
Fitness: max 0.944(5), min 0.833(2), ave 0.91
Test execution time: sum 2014 ms, max 269 ms, min 236 ms

---

2023-08-15 18:13:08 [main] [INFO] KGenProgMain - entered the era of 226th generation.
2023-08-15 18:13:30 [main] [INFO] KGenProgMain -

---

Elapsed time: 19 hours 38 minutes 49 seconds
Variants: generated 100, build-succeeded 4, build-failed 37, syntax-invalid 54, redundant 5
Fitness: max 0.944(2), min 0.5(1), ave 0.806
Test execution time: sum 1176 ms, max 357 ms, min 230 ms

---

2023-08-15 18:13:30 [main] [INFO] KGenProgMain - entered the era of 227th generation.
2023-08-15 18:16:56 [main] [INFO] KGenProgMain -

---

Elapsed time: 19 hours 42 minutes 14 seconds
Variants: generated 100, build-succeeded 15, build-failed 32, syntax-invalid 52, redundant 1
Fitness: max 0.944(13), min 0.444(1), ave 0.893
Test execution time: sum 184356 ms, max 180285 ms, min 226 ms

---

2023-08-15 18:16:56 [main] [INFO] KGenProgMain - entered the era of 228th generation.
2023-08-15 18:20:20 [main] [INFO] KGenProgMain -

---

Elapsed time: 19 hours 45 minutes 38 seconds
Variants: generated 100, build-succeeded 8, build-failed 31, syntax-invalid 56, redundant 5
Fitness: max 0.944(6), min 0.833(1), ave 0.924
Test execution time: sum 182033 ms, max 180243 ms, min 236 ms

---

2023-08-15 18:20:20 [main] [INFO] KGenProgMain - entered the era of 229th generation.
2023-08-15 18:26:48 [main] [INFO] KGenProgMain -

---

Elapsed time: 19 hours 52 minutes 7 seconds
Variants: generated 100, build-succeeded 7, build-failed 28, syntax-invalid 59, redundant 6
Fitness: max 0.944(7), min 0.944(7), ave 0.944
Test execution time: sum 362114 ms, max 180246 ms, min 263 ms

---

2023-08-15 18:26:48 [main] [INFO] KGenProgMain - entered the era of 230th generation.
2023-08-15 18:33:18 [main] [INFO] KGenProgMain -

---

Elapsed time: 19 hours 58 minutes 37 seconds
Variants: generated 100, build-succeeded 12, build-failed 28, syntax-invalid 52, redundant 8
Fitness: max 0.944(9), min 0.778(1), ave 0.912
Test execution time: sum 363606 ms, max 180438 ms, min 246 ms

---

2023-08-15 18:33:18 [main] [INFO] KGenProgMain - entered the era of 231st generation.
2023-08-15 18:42:41 [main] [INFO] KGenProgMain -

---

Elapsed time: 20 hours 8 minutes 0 seconds
Variants: generated 100, build-succeeded 9, build-failed 35, syntax-invalid 56, redundant 0
Fitness: max 0.944(7), min 0.5(1), ave 0.877
Test execution time: sum 542251 ms, max 180232 ms, min 240 ms

---

2023-08-15 18:42:41 [main] [INFO] KGenProgMain - entered the era of 232nd generation.
2023-08-15 18:58:07 [main] [INFO] KGenProgMain -

---

Elapsed time: 20 hours 23 minutes 26 seconds
Variants: generated 100, build-succeeded 10, build-failed 29, syntax-invalid 56, redundant 5
Fitness: max 0.944(8), min 0.5(1), ave 0.889
Test execution time: sum 902839 ms, max 360421 ms, min 235 ms

---

2023-08-15 18:58:07 [main] [INFO] KGenProgMain - entered the era of 233rd generation.
2023-08-15 19:04:39 [main] [INFO] KGenProgMain -

---

Elapsed time: 20 hours 29 minutes 58 seconds
Variants: generated 100, build-succeeded 11, build-failed 33, syntax-invalid 54, redundant 2
Fitness: max 0.944(7), min 0.5(1), ave 0.869
Test execution time: sum 363631 ms, max 180300 ms, min 234 ms

---

2023-08-15 19:04:39 [main] [INFO] KGenProgMain - entered the era of 234th generation.
2023-08-15 19:17:06 [main] [INFO] KGenProgMain -

---

Elapsed time: 20 hours 42 minutes 25 seconds
Variants: generated 100, build-succeeded 6, build-failed 31, syntax-invalid 58, redundant 5
Fitness: max 0.944(4), min 0(1), ave 0.769
Test execution time: sum 721706 ms, max 180343 ms, min 266 ms

---

2023-08-15 19:17:06 [main] [INFO] KGenProgMain - entered the era of 235th generation.
2023-08-15 19:20:30 [main] [INFO] KGenProgMain -

---

Elapsed time: 20 hours 45 minutes 49 seconds
Variants: generated 100, build-succeeded 9, build-failed 34, syntax-invalid 53, redundant 4
Fitness: max 0.944(6), min 0.5(2), ave 0.833
Test execution time: sum 182534 ms, max 180237 ms, min 238 ms

---

2023-08-15 19:20:30 [main] [INFO] KGenProgMain - entered the era of 236th generation.
2023-08-15 19:23:55 [main] [INFO] KGenProgMain -

---

Elapsed time: 20 hours 49 minutes 13 seconds
Variants: generated 100, build-succeeded 5, build-failed 33, syntax-invalid 58, redundant 4
Fitness: max 0.944(4), min 0.833(1), ave 0.922
Test execution time: sum 181320 ms, max 180249 ms, min 254 ms

---

2023-08-15 19:23:55 [main] [INFO] KGenProgMain - entered the era of 237th generation.
2023-08-15 19:36:19 [main] [INFO] KGenProgMain -

---

Elapsed time: 21 hours 1 minutes 37 seconds
Variants: generated 100, build-succeeded 11, build-failed 24, syntax-invalid 58, redundant 7
Fitness: max 0.944(9), min 0.833(2), ave 0.924
Test execution time: sum 723077 ms, max 360531 ms, min 227 ms

---

2023-08-15 19:36:19 [main] [INFO] KGenProgMain - entered the era of 238th generation.
2023-08-15 19:39:43 [main] [INFO] KGenProgMain -

---

Elapsed time: 21 hours 5 minutes 1 seconds
Variants: generated 100, build-succeeded 8, build-failed 31, syntax-invalid 57, redundant 4
Fitness: max 0.944(7), min 0.833(1), ave 0.931
Test execution time: sum 182162 ms, max 180297 ms, min 230 ms

---

2023-08-15 19:39:43 [main] [INFO] KGenProgMain - entered the era of 239th generation.
2023-08-15 19:40:06 [main] [INFO] KGenProgMain -

---

Elapsed time: 21 hours 5 minutes 25 seconds
Variants: generated 100, build-succeeded 6, build-failed 35, syntax-invalid 56, redundant 3
Fitness: max 0.944(4), min 0.556(1), ave 0.861
Test execution time: sum 1585 ms, max 303 ms, min 225 ms

---

2023-08-15 19:40:06 [main] [INFO] KGenProgMain - entered the era of 240th generation.
2023-08-15 19:46:31 [main] [INFO] KGenProgMain -

---

Elapsed time: 21 hours 11 minutes 50 seconds
Variants: generated 100, build-succeeded 7, build-failed 40, syntax-invalid 53, redundant 0
Fitness: max 0.944(6), min 0.778(1), ave 0.921
Test execution time: sum 361910 ms, max 180272 ms, min 235 ms

---

2023-08-15 19:46:31 [main] [INFO] KGenProgMain - entered the era of 241st generation.
2023-08-15 20:16:56 [main] [INFO] KGenProgMain -

---

Elapsed time: 21 hours 42 minutes 14 seconds
Variants: generated 100, build-succeeded 11, build-failed 27, syntax-invalid 57, redundant 5
Fitness: max 0.944(10), min 0.5(1), ave 0.904
Test execution time: sum 1803008 ms, max 1620283 ms, min 218 ms

---

2023-08-15 20:16:56 [main] [INFO] KGenProgMain - entered the era of 242nd generation.
2023-08-15 20:23:19 [main] [INFO] KGenProgMain -

---

Elapsed time: 21 hours 48 minutes 37 seconds
Variants: generated 100, build-succeeded 7, build-failed 35, syntax-invalid 58, redundant 0
Fitness: max 0.944(6), min 0.833(1), ave 0.929
Test execution time: sum 361866 ms, max 360255 ms, min 221 ms

---

2023-08-15 20:23:19 [main] [INFO] KGenProgMain - entered the era of 243rd generation.
2023-08-15 20:23:41 [main] [INFO] KGenProgMain -

---

Elapsed time: 21 hours 48 minutes 59 seconds
Variants: generated 100, build-succeeded 7, build-failed 36, syntax-invalid 57, redundant 0
Fitness: max 0.944(5), min 0.778(1), ave 0.905
Test execution time: sum 1681 ms, max 288 ms, min 226 ms

---

2023-08-15 20:23:41 [main] [INFO] KGenProgMain - entered the era of 244th generation.
2023-08-15 20:33:09 [main] [INFO] KGenProgMain -

---

Elapsed time: 21 hours 58 minutes 27 seconds
Variants: generated 100, build-succeeded 11, build-failed 30, syntax-invalid 53, redundant 6
Fitness: max 1(1), min 0.833(1), ave 0.934
Test execution time: sum 542907 ms, max 180355 ms, min 214 ms

---

2023-08-15 20:33:09 [main] [INFO] KGenProgMain - entered the era of 245th generation.
2023-08-15 20:39:31 [main] [INFO] KGenProgMain -

---

Elapsed time: 22 hours 4 minutes 49 seconds
Variants: generated 100, build-succeeded 7, build-failed 32, syntax-invalid 57, redundant 4
Fitness: max 0.944(6), min 0.833(1), ave 0.929
Test execution time: sum 361804 ms, max 180358 ms, min 224 ms

---

2023-08-15 20:39:31 [main] [INFO] KGenProgMain - entered the era of 246th generation.
2023-08-15 20:54:54 [main] [INFO] KGenProgMain -

---

Elapsed time: 22 hours 20 minutes 12 seconds
Variants: generated 100, build-succeeded 9, build-failed 33, syntax-invalid 57, redundant 1
Fitness: max 0.944(8), min 0.833(1), ave 0.932
Test execution time: sum 902322 ms, max 360311 ms, min 223 ms

---

2023-08-15 20:54:54 [main] [INFO] KGenProgMain - entered the era of 247th generation.
2023-08-15 21:04:18 [main] [INFO] KGenProgMain -

---

Elapsed time: 22 hours 29 minutes 37 seconds
Variants: generated 100, build-succeeded 6, build-failed 35, syntax-invalid 55, redundant 4
Fitness: max 0.944(3), min 0.833(2), ave 0.898
Test execution time: sum 541556 ms, max 360352 ms, min 225 ms

---

2023-08-15 21:04:18 [main] [INFO] KGenProgMain - entered the era of 248th generation.
2023-08-15 21:10:45 [main] [INFO] KGenProgMain -

---

Elapsed time: 22 hours 36 minutes 4 seconds
Variants: generated 100, build-succeeded 9, build-failed 29, syntax-invalid 55, redundant 7
Fitness: max 1(1), min 0.833(1), ave 0.932
Test execution time: sum 362351 ms, max 180341 ms, min 227 ms

---

2023-08-15 21:10:45 [main] [INFO] KGenProgMain - entered the era of 249th generation.
2023-08-15 21:20:07 [main] [INFO] KGenProgMain -

---

Elapsed time: 22 hours 45 minutes 26 seconds
Variants: generated 100, build-succeeded 5, build-failed 36, syntax-invalid 57, redundant 2
Fitness: max 0.944(3), min 0.833(2), ave 0.9
Test execution time: sum 541464 ms, max 180468 ms, min 220 ms

---

2023-08-15 21:20:07 [main] [INFO] KGenProgMain - entered the era of 250th generation.
2023-08-15 21:29:30 [main] [INFO] KGenProgMain -

---

Elapsed time: 22 hours 54 minutes 48 seconds
Variants: generated 100, build-succeeded 8, build-failed 30, syntax-invalid 54, redundant 8
Fitness: max 0.944(8), min 0.944(8), ave 0.944
Test execution time: sum 542020 ms, max 180322 ms, min 216 ms

---

2023-08-15 21:29:30 [main] [INFO] KGenProgMain - entered the era of 251st generation.
2023-08-15 21:35:53 [main] [INFO] KGenProgMain -

---

Elapsed time: 23 hours 1 minutes 12 seconds
Variants: generated 100, build-succeeded 8, build-failed 30, syntax-invalid 57, redundant 5
Fitness: max 1(1), min 0.444(1), ave 0.819
Test execution time: sum 361973 ms, max 180222 ms, min 230 ms

---

2023-08-15 21:35:53 [main] [INFO] KGenProgMain - entered the era of 252nd generation.
2023-08-15 22:32:17 [main] [INFO] KGenProgMain -

---

Elapsed time: 23 hours 40 minutes 35 seconds
Variants: generated 100, build-succeeded 10, build-failed 29, syntax-invalid 56, redundant 5
Fitness: max 0.944(7), min 0.444(1), ave 0.872
Test execution time: sum 2342829 ms, max 1800190 ms, min 224 ms

---

2023-08-15 22:32:17 [main] [INFO] KGenProgMain - entered the era of 253rd generation.
2023-08-15 22:56:41 [main] [INFO] KGenProgMain -

---

Elapsed time: 24 hours 4 minutes 59 seconds
Variants: generated 100, build-succeeded 10, build-failed 31, syntax-invalid 54, redundant 5
Fitness: max 0.944(6), min 0.444(1), ave 0.844
Test execution time: sum 1442728 ms, max 900252 ms, min 230 ms

---

2023-08-15 22:56:41 [main] [INFO] KGenProgMain - GA stopped
2023-08-15 22:56:46 [main] [INFO] PatchLogExporter - patch (v63)
--- org.apache.commons.math.linear.EigenDecompositionImpl
+++ org.apache.commons.math.linear.EigenDecompositionImpl
@@ -1053,6 +1053,7 @@
if ((dMin <= 0) || (deflatedEnd < end)) {
if (flipIfWarranted(deflatedEnd, 1)) {
dMin2 = Math.min(dMin2, work[l - 1]);

-     		double alpha = 0;
                   work[l - 1] =
                       Math.min(work[l - 1],
                                Math.min(work[3 + pingPong], work[7 + pingPong]));
  @@ -1136,7 +1137,6 @@
  for (int i = 0; i < j; i += 4) {
  for (int k = 0; k < 4; k += step) {
  final double tmp = work[i + k];

*                    work[i + k] = work[j - k];
                       work[j - k] = tmp;
                   }
                   j -= 4;
  2023-08-15 22:56:46 [main] [INFO] PatchLogExporter - patch (v63)
  --- org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic
  +++ org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic
  @@ -173,4 +173,3 @@
  return test(values, begin, length);
  }
  }
* 2023-08-15 22:56:46 [main] [INFO] PatchLogExporter - patch (v63)
  --- org.apache.commons.math.optimization.fitting.WeightedObservedPoint
  +++ org.apache.commons.math.optimization.fitting.WeightedObservedPoint
  @@ -72,4 +72,3 @@
  }
  }
* 2023-08-15 22:56:46 [main] [INFO] PatchLogExporter - patch (v63)
  --- org.apache.commons.math.linear.BigMatrix
  +++ org.apache.commons.math.linear.BigMatrix
  @@ -328,4 +328,3 @@
  \*/
  BigMatrix solve(BigMatrix b) throws IllegalArgumentException, InvalidMatrixException;
  }
* 2023-08-15 22:56:46 [main] [INFO] PatchLogExporter - patch (v1120)
  --- org.apache.commons.math.linear.EigenDecompositionImpl
  +++ org.apache.commons.math.linear.EigenDecompositionImpl
  @@ -955,7 +955,6 @@
  work[j] = d + work[i];
  if (work[i] <= TOLERANCE_2 \* d) {
  work[i] = -0.0;
*                    work[j]     = d;
                       work[j + 2] = 0.0;
                       d = work[i + 2];
                   } else if ((MathUtils.SAFE_MIN * work[i + 2] < work[j]) &&
  @@ -1136,7 +1135,6 @@
  for (int i = 0; i < j; i += 4) {
  for (int k = 0; k < 4; k += step) {
  final double tmp = work[i + k];
*                    work[i + k] = work[j - k];
                       work[j - k] = tmp;
                   }
                   j -= 4;
  @@ -1381,17 +1379,15 @@
  int j4p2 = j4 + 2 \* pingPong - 1;
  work[j4 - 2] = dN2 + work[j4p2];
  if (work[j4 - 2] == 0.0) {
*            work[j4] = 0.0;
             dN1  = work[j4p2 + 2];
             dMin = dN1;
*            eMin = 0.0;

-            int h = 3542;
         } else if ((MathUtils.SAFE_MIN * work[j4p2 + 2] < work[j4 - 2]) &&
                    (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4p2 + 2])) {
             final double tmp = work[j4p2 + 2] / work[j4 - 2];
             work[j4] = work[j4p2] * tmp;
             dN1 = dN2 * tmp;
         } else {

*            work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]);
               dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);
           }
           dMin = Math.min(dMin, dN1);
  2023-08-15 22:56:46 [main] [INFO] PatchLogExporter - patch (v1120)
  --- org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic
  +++ org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic
  @@ -173,4 +173,3 @@
  return test(values, begin, length);
  }
  }
* 2023-08-15 22:56:46 [main] [INFO] PatchLogExporter - patch (v1120)
  --- org.apache.commons.math.optimization.fitting.WeightedObservedPoint
  +++ org.apache.commons.math.optimization.fitting.WeightedObservedPoint
  @@ -72,4 +72,3 @@
  }
  }
* 2023-08-15 22:56:46 [main] [INFO] PatchLogExporter - patch (v1120)
  --- org.apache.commons.math.linear.BigMatrix
  +++ org.apache.commons.math.linear.BigMatrix
  @@ -328,4 +328,3 @@
  \*/
  BigMatrix solve(BigMatrix b) throws IllegalArgumentException, InvalidMatrixException;
  }
* 2023-08-15 22:56:46 [main] [INFO] PatchLogExporter - patch (v1236)
  --- org.apache.commons.math.linear.EigenDecompositionImpl
  +++ org.apache.commons.math.linear.EigenDecompositionImpl
  @@ -869,7 +869,6 @@
  for (int i = 4 \* (n0 - 2); i >= 0; i -= 4) {
  if (work[i + 2] <= 0) {
  i0 = 1 + i / 4;
*                    break;
                   }
                   if (diagMin >= 4 * offDiagMax) {
                       diagMin    = Math.min(diagMin, work[i + 4]);
  @@ -956,7 +955,6 @@
  if (work[i] <= TOLERANCE_2 \* d) {
  work[i] = -0.0;
  work[j] = d;
*                    work[j + 2] = 0.0;
                       d = work[i + 2];
                   } else if ((MathUtils.SAFE_MIN * work[i + 2] < work[j]) &&
                              (MathUtils.SAFE_MIN * work[j] < work[i + 2])) {
  @@ -1136,7 +1134,6 @@
  for (int i = 0; i < j; i += 4) {
  for (int k = 0; k < 4; k += step) {
  final double tmp = work[i + k];
*                    work[i + k] = work[j - k];
                       work[j - k] = tmp;
                   }
                   j -= 4;
  @@ -1382,7 +1379,6 @@
  work[j4 - 2] = dN2 + work[j4p2];
  if (work[j4 - 2] == 0.0) {
  work[j4] = 0.0;
*            dN1  = work[j4p2 + 2];
               dMin = dN1;
               eMin = 0.0;
           } else if ((MathUtils.SAFE_MIN * work[j4p2 + 2] < work[j4 - 2]) &&
  @@ -1391,7 +1387,6 @@
  work[j4] = work[j4p2] _ tmp;
  dN1 = dN2 _ tmp;
  } else {
*            work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]);
               dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);
           }
           dMin = Math.min(dMin, dN1);
  @@ -1411,7 +1406,6 @@
  work[j4] = work[j4p2] _ tmp;
  dN = dN1 _ tmp;
  } else {
*            work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]);
               dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);
           }
           dMin = Math.min(dMin, dN);
  2023-08-15 22:56:46 [main] [INFO] PatchLogExporter - patch (v1236)
  --- org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic
  +++ org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic
  @@ -173,4 +173,3 @@
  return test(values, begin, length);
  }
  }
* 2023-08-15 22:56:46 [main] [INFO] PatchLogExporter - patch (v1236)
  --- org.apache.commons.math.optimization.fitting.WeightedObservedPoint
  +++ org.apache.commons.math.optimization.fitting.WeightedObservedPoint
  @@ -72,4 +72,3 @@
  }
  }
* 2023-08-15 22:56:46 [main] [INFO] PatchLogExporter - patch (v1236)
  --- org.apache.commons.math.linear.BigMatrix
  +++ org.apache.commons.math.linear.BigMatrix
  @@ -328,4 +328,3 @@
  \*/
  BigMatrix solve(BigMatrix b) throws IllegalArgumentException, InvalidMatrixException;
  }
* 2023-08-15 22:56:46 [main] [INFO] PatchLogExporter - patch (v1424)
  --- org.apache.commons.math.linear.EigenDecompositionImpl
  +++ org.apache.commons.math.linear.EigenDecompositionImpl
  @@ -955,7 +955,6 @@
  work[j] = d + work[i];
  if (work[i] <= TOLERANCE_2 \* d) {
  work[i] = -0.0;
*                    work[j]     = d;
                       work[j + 2] = 0.0;
                       d = work[i + 2];
                   } else if ((MathUtils.SAFE_MIN * work[i + 2] < work[j]) &&
  @@ -1136,12 +1135,10 @@
  for (int i = 0; i < j; i += 4) {
  for (int k = 0; k < 4; k += step) {
  final double tmp = work[i + k];
*                    work[i + k] = work[j - k];
                     work[j - k] = tmp;
                 }
                 j -= 4;
             }
*            return true;
           }
           return false;
       }
  @@ -1381,7 +1378,6 @@
  int j4p2 = j4 + 2 \* pingPong - 1;
  work[j4 - 2] = dN2 + work[j4p2];
  if (work[j4 - 2] == 0.0) {
*            work[j4] = 0.0;
               dN1  = work[j4p2 + 2];
               dMin = dN1;
               eMin = 0.0;
  @@ -1391,7 +1387,6 @@
  work[j4] = work[j4p2] _ tmp;
  dN1 = dN2 _ tmp;
  } else {
*            work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]);
               dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);
           }
           dMin = Math.min(dMin, dN1);
  2023-08-15 22:56:46 [main] [INFO] PatchLogExporter - patch (v1424)
  --- org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic
  +++ org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic
  @@ -173,4 +173,3 @@
  return test(values, begin, length);
  }
  }
* 2023-08-15 22:56:46 [main] [INFO] PatchLogExporter - patch (v1424)
  --- org.apache.commons.math.optimization.fitting.WeightedObservedPoint
  +++ org.apache.commons.math.optimization.fitting.WeightedObservedPoint
  @@ -72,4 +72,3 @@
  }
  }
* 2023-08-15 22:56:46 [main] [INFO] PatchLogExporter - patch (v1424)
  --- org.apache.commons.math.linear.BigMatrix
  +++ org.apache.commons.math.linear.BigMatrix
  @@ -328,4 +328,3 @@
  \*/
  BigMatrix solve(BigMatrix b) throws IllegalArgumentException, InvalidMatrixException;
  }
* 2023-08-15 22:56:46 [main] [INFO] PatchLogExporter - patch (v2037)
  --- org.apache.commons.math.linear.EigenDecompositionImpl
  +++ org.apache.commons.math.linear.EigenDecompositionImpl
  @@ -955,7 +955,6 @@
  work[j] = d + work[i];
  if (work[i] <= TOLERANCE_2 \* d) {
  work[i] = -0.0;
*                    work[j]     = d;
                       work[j + 2] = 0.0;
                       d = work[i + 2];
                   } else if ((MathUtils.SAFE_MIN * work[i + 2] < work[j]) &&
  @@ -1053,9 +1052,6 @@
  if ((dMin <= 0) || (deflatedEnd < end)) {
  if (flipIfWarranted(deflatedEnd, 1)) {
  dMin2 = Math.min(dMin2, work[l - 1]);
*                work[l - 1] =
*                    Math.min(work[l - 1],
*                             Math.min(work[3 + pingPong], work[7 + pingPong]));
                   work[l - 2 * pingPong] =
                       Math.min(work[l - 2 * pingPong],
                                Math.min(work[6 + pingPong], work[6 + pingPong]));
  @@ -1136,7 +1132,6 @@
  for (int i = 0; i < j; i += 4) {
  for (int k = 0; k < 4; k += step) {
  final double tmp = work[i + k];
*                    work[i + k] = work[j - k];
                       work[j - k] = tmp;
                   }
                   j -= 4;
  @@ -1381,7 +1376,6 @@
  int j4p2 = j4 + 2 \* pingPong - 1;
  work[j4 - 2] = dN2 + work[j4p2];
  if (work[j4 - 2] == 0.0) {
*            work[j4] = 0.0;
               dN1  = work[j4p2 + 2];
               dMin = dN1;
               eMin = 0.0;
  @@ -1391,7 +1385,6 @@
  work[j4] = work[j4p2] _ tmp;
  dN1 = dN2 _ tmp;
  } else {
*            work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]);
               dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);
           }
           dMin = Math.min(dMin, dN1);
  @@ -1402,7 +1395,6 @@
  work[j4 - 2] = dN1 + work[j4p2];
  if (work[j4 - 2] == 0.0) {
  work[j4] = 0.0;
*            dN   = work[j4p2 + 2];
               dMin = dN;
               eMin = 0.0;
           } else if ((MathUtils.SAFE_MIN * work[j4p2 + 2] < work[j4 - 2]) &&
  2023-08-15 22:56:46 [main] [INFO] PatchLogExporter - patch (v2037)
  --- org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic
  +++ org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic
  @@ -173,4 +173,3 @@
  return test(values, begin, length);
  }
  }
* 2023-08-15 22:56:46 [main] [INFO] PatchLogExporter - patch (v2037)
  --- org.apache.commons.math.optimization.fitting.WeightedObservedPoint
  +++ org.apache.commons.math.optimization.fitting.WeightedObservedPoint
  @@ -72,4 +72,3 @@
  }
  }
* 2023-08-15 22:56:46 [main] [INFO] PatchLogExporter - patch (v2037)
  --- org.apache.commons.math.linear.BigMatrix
  +++ org.apache.commons.math.linear.BigMatrix
  @@ -328,4 +328,3 @@
  \*/
  BigMatrix solve(BigMatrix b) throws IllegalArgumentException, InvalidMatrixException;
  }
* 2023-08-15 22:56:46 [main] [INFO] PatchLogExporter - patch (v2101)
  --- org.apache.commons.math.linear.EigenDecompositionImpl
  +++ org.apache.commons.math.linear.EigenDecompositionImpl
  @@ -955,8 +955,6 @@
  work[j] = d + work[i];
  if (work[i] <= TOLERANCE_2 \* d) {
  work[i] = -0.0;
*                    work[j]     = d;
*                    work[j + 2] = 0.0;
                       d = work[i + 2];
                   } else if ((MathUtils.SAFE_MIN * work[i + 2] < work[j]) &&
                              (MathUtils.SAFE_MIN * work[j] < work[i + 2])) {
  @@ -1019,7 +1017,6 @@
  // two realEigenvalues found, deflate array
  if (work[k - 3] > work[k - 7]) {
  final double tmp = work[k - 3];
*                    work[k - 3] = work[k - 7];
                     work[k - 7] = tmp;
                 }

@@ -1053,9 +1050,6 @@
if ((dMin <= 0) || (deflatedEnd < end)) {
if (flipIfWarranted(deflatedEnd, 1)) {
dMin2 = Math.min(dMin2, work[l - 1]);

-                work[l - 1] =
-                    Math.min(work[l - 1],
-                             Math.min(work[3 + pingPong], work[7 + pingPong]));
                   work[l - 2 * pingPong] =
                       Math.min(work[l - 2 * pingPong],
                                Math.min(work[6 + pingPong], work[6 + pingPong]));
  @@ -1134,11 +1128,8 @@
  // flip array
  int j = 4 \* n - 1;
  for (int i = 0; i < j; i += 4) {
-                for (int k = 0; k < 4; k += step) {
-                    final double tmp = work[i + k];
-                    work[i + k] = work[j - k];
-                    work[j - k] = tmp;
-                }

*                for (int k = 0; k < 4; k += step)
*     			dMin2 = dMin;
                   j -= 4;
               }
               return true;
  @@ -1402,7 +1393,8 @@
  work[j4 - 2] = dN1 + work[j4p2];
  if (work[j4 - 2] == 0.0) {
  work[j4] = 0.0;

-            dN   = work[j4p2 + 2];

*            double sum = 0;
*     	dN   = work[j4p2 + 2];
               dMin = dN;
               eMin = 0.0;
           } else if ((MathUtils.SAFE_MIN * work[j4p2 + 2] < work[j4 - 2]) &&
  2023-08-15 22:56:46 [main] [INFO] PatchLogExporter - patch (v2101)
  --- org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic
  +++ org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic
  @@ -173,4 +173,3 @@
  return test(values, begin, length);
  }
  }

- 2023-08-15 22:56:46 [main] [INFO] PatchLogExporter - patch (v2101)
  --- org.apache.commons.math.optimization.fitting.WeightedObservedPoint
  +++ org.apache.commons.math.optimization.fitting.WeightedObservedPoint
  @@ -72,4 +72,3 @@
  }
  }
- 2023-08-15 22:56:46 [main] [INFO] PatchLogExporter - patch (v2101)
  --- org.apache.commons.math.linear.BigMatrix
  +++ org.apache.commons.math.linear.BigMatrix
  @@ -328,4 +328,3 @@
  \*/
  BigMatrix solve(BigMatrix b) throws IllegalArgumentException, InvalidMatrixException;
  }
- 2023-08-15 22:56:46 [main] [INFO] PatchLogExporter - patch (v2402)
  --- org.apache.commons.math.linear.EigenDecompositionImpl
  +++ org.apache.commons.math.linear.EigenDecompositionImpl
  @@ -955,9 +955,7 @@
  work[j] = d + work[i];
  if (work[i] <= TOLERANCE_2 \* d) {
  work[i] = -0.0;
-                    work[j]     = d;
                     work[j + 2] = 0.0;
-                    d = work[i + 2];
                   } else if ((MathUtils.SAFE_MIN * work[i + 2] < work[j]) &&
                              (MathUtils.SAFE_MIN * work[j] < work[i + 2])) {
                       final double tmp = work[i + 2] / work[j];
  @@ -1136,7 +1134,6 @@
  for (int i = 0; i < j; i += 4) {
  for (int k = 0; k < 4; k += step) {
  final double tmp = work[i + k];
-                    work[i + k] = work[j - k];
                       work[j - k] = tmp;
                   }
                   j -= 4;
  @@ -1381,10 +1378,10 @@
  int j4p2 = j4 + 2 \* pingPong - 1;
  work[j4 - 2] = dN2 + work[j4p2];
  if (work[j4 - 2] == 0.0) {
-            work[j4] = 0.0;
             dN1  = work[j4p2 + 2];
             dMin = dN1;
             eMin = 0.0;

*     	int k = 0;
           } else if ((MathUtils.SAFE_MIN * work[j4p2 + 2] < work[j4 - 2]) &&
                      (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4p2 + 2])) {
               final double tmp = work[j4p2 + 2] / work[j4 - 2];
  @@ -1401,8 +1398,8 @@
  j4p2 = j4 + 2 \* pingPong - 1;
  work[j4 - 2] = dN1 + work[j4p2];
  if (work[j4 - 2] == 0.0) {

-            work[j4] = 0.0;
-            dN   = work[j4p2 + 2];

*            double sum = 0;
*     	dN   = work[j4p2 + 2];
               dMin = dN;
               eMin = 0.0;
           } else if ((MathUtils.SAFE_MIN * work[j4p2 + 2] < work[j4 - 2]) &&
  2023-08-15 22:56:46 [main] [INFO] PatchLogExporter - patch (v2402)
  --- org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic
  +++ org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic
  @@ -173,4 +173,3 @@
  return test(values, begin, length);
  }
  }

- 2023-08-15 22:56:46 [main] [INFO] PatchLogExporter - patch (v2402)
  --- org.apache.commons.math.optimization.fitting.WeightedObservedPoint
  +++ org.apache.commons.math.optimization.fitting.WeightedObservedPoint
  @@ -72,4 +72,3 @@
  }
  }
- 2023-08-15 22:56:46 [main] [INFO] PatchLogExporter - patch (v2402)
  --- org.apache.commons.math.linear.BigMatrix
  +++ org.apache.commons.math.linear.BigMatrix
  @@ -328,4 +328,3 @@
  \*/
  BigMatrix solve(BigMatrix b) throws IllegalArgumentException, InvalidMatrixException;
  }
- 2023-08-15 22:56:46 [main] [INFO] PatchLogExporter - patch (v2724)
  --- org.apache.commons.math.linear.EigenDecompositionImpl
  +++ org.apache.commons.math.linear.EigenDecompositionImpl
  @@ -941,7 +941,6 @@
  double d = work[4 * (n - 1) + pingPong];
  for (int i = 4 _ (n - 2) + pingPong; i >= 0; i -= 4) {
  if (work[i + 2] <= TOLERANCE_2 _ d) {
-                    work[i + 2] = -0.0;
                       d = work[i];
                   } else {
                       d *= work[i] / (d + work[i + 2]);
  @@ -955,8 +954,6 @@
  work[j] = d + work[i];
  if (work[i] <= TOLERANCE_2 \* d) {
  work[i] = -0.0;
-                    work[j]     = d;
-                    work[j + 2] = 0.0;
                       d = work[i + 2];
                   } else if ((MathUtils.SAFE_MIN * work[i + 2] < work[j]) &&
                              (MathUtils.SAFE_MIN * work[j] < work[i + 2])) {
  @@ -1020,7 +1017,6 @@
  if (work[k - 3] > work[k - 7]) {
  final double tmp = work[k - 3];
  work[k - 3] = work[k - 7];
-                    work[k - 7] = tmp;
                   }

                   if (work[k - 5] > TOLERANCE_2 * work[k - 3]) {
  @@ -1052,7 +1048,6 @@
  // step 2: flip array if needed
  if ((dMin <= 0) || (deflatedEnd < end)) {
  if (flipIfWarranted(deflatedEnd, 1)) {
-                dMin2 = Math.min(dMin2, work[l - 1]);
                   work[l - 1] =
                       Math.min(work[l - 1],
                                Math.min(work[3 + pingPong], work[7 + pingPong]));
  @@ -1134,11 +1129,8 @@
  // flip array
  int j = 4 \* n - 1;
  for (int i = 0; i < j; i += 4) {
-                for (int k = 0; k < 4; k += step) {
-                    final double tmp = work[i + k];
-                    work[i + k] = work[j - k];
-                    work[j - k] = tmp;
-                }

*                for (int k = 0; k < 4; k += step)
*     			tType = -3;
                   j -= 4;
               }
               return true;
  @@ -1381,7 +1373,6 @@
  int j4p2 = j4 + 2 \* pingPong - 1;
  work[j4 - 2] = dN2 + work[j4p2];
  if (work[j4 - 2] == 0.0) {

-            work[j4] = 0.0;
               dN1  = work[j4p2 + 2];
               dMin = dN1;
               eMin = 0.0;
  2023-08-15 22:56:46 [main] [INFO] PatchLogExporter - patch (v2724)
  --- org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic
  +++ org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic
  @@ -173,4 +173,3 @@
  return test(values, begin, length);
  }
  }
- 2023-08-15 22:56:46 [main] [INFO] PatchLogExporter - patch (v2724)
  --- org.apache.commons.math.optimization.fitting.WeightedObservedPoint
  +++ org.apache.commons.math.optimization.fitting.WeightedObservedPoint
  @@ -72,4 +72,3 @@
  }
  }
- 2023-08-15 22:56:46 [main] [INFO] PatchLogExporter - patch (v2724)
  --- org.apache.commons.math.linear.BigMatrix
  +++ org.apache.commons.math.linear.BigMatrix
  @@ -328,4 +328,3 @@
  \*/
  BigMatrix solve(BigMatrix b) throws IllegalArgumentException, InvalidMatrixException;
  }
- 2023-08-15 22:56:46 [main] [INFO] PatchLogExporter - patch (v2911)
  --- org.apache.commons.math.linear.EigenDecompositionImpl
  +++ org.apache.commons.math.linear.EigenDecompositionImpl
  @@ -941,7 +941,6 @@
  double d = work[4 * (n - 1) + pingPong];
  for (int i = 4 _ (n - 2) + pingPong; i >= 0; i -= 4) {
  if (work[i + 2] <= TOLERANCE_2 _ d) {
-                    work[i + 2] = -0.0;
                       d = work[i];
                   } else {
                       d *= work[i] / (d + work[i + 2]);
  @@ -955,7 +954,6 @@
  work[j] = d + work[i];
  if (work[i] <= TOLERANCE_2 \* d) {
  work[i] = -0.0;
-                    work[j]     = d;
                       work[j + 2] = 0.0;
                       d = work[i + 2];
                   } else if ((MathUtils.SAFE_MIN * work[i + 2] < work[j]) &&
  @@ -1060,7 +1058,6 @@
  Math.min(work[l - 2 * pingPong],
  Math.min(work[6 + pingPong], work[6 + pingPong]));
  qMax = Math.max(qMax, Math.max(work[3 + pingPong], work[7 + pingPong]));
-                dMin  = -0.0;
             }
         }

@@ -1136,7 +1133,6 @@
for (int i = 0; i < j; i += 4) {
for (int k = 0; k < 4; k += step) {
final double tmp = work[i + k];

-                    work[i + k] = work[j - k];
                       work[j - k] = tmp;
                   }
                   j -= 4;
  @@ -1381,7 +1377,6 @@
  int j4p2 = j4 + 2 \* pingPong - 1;
  work[j4 - 2] = dN2 + work[j4p2];
  if (work[j4 - 2] == 0.0) {
-            work[j4] = 0.0;
               dN1  = work[j4p2 + 2];
               dMin = dN1;
               eMin = 0.0;
  @@ -1391,7 +1386,6 @@
  work[j4] = work[j4p2] _ tmp;
  dN1 = dN2 _ tmp;
  } else {
-            work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]);
               dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);
           }
           dMin = Math.min(dMin, dN1);
  @@ -1411,7 +1405,6 @@
  work[j4] = work[j4p2] _ tmp;
  dN = dN1 _ tmp;
  } else {
-            work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]);
               dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);
           }
           dMin = Math.min(dMin, dN);
  2023-08-15 22:56:46 [main] [INFO] PatchLogExporter - patch (v2911)
  --- org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic
  +++ org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic
  @@ -173,4 +173,3 @@
  return test(values, begin, length);
  }
  }
- 2023-08-15 22:56:46 [main] [INFO] PatchLogExporter - patch (v2911)
  --- org.apache.commons.math.optimization.fitting.WeightedObservedPoint
  +++ org.apache.commons.math.optimization.fitting.WeightedObservedPoint
  @@ -72,4 +72,3 @@
  }
  }
- 2023-08-15 22:56:46 [main] [INFO] PatchLogExporter - patch (v2911)
  --- org.apache.commons.math.linear.BigMatrix
  +++ org.apache.commons.math.linear.BigMatrix
  @@ -328,4 +328,3 @@
  \*/
  BigMatrix solve(BigMatrix b) throws IllegalArgumentException, InvalidMatrixException;
  }
- 2023-08-15 22:56:46 [main] [INFO] PatchLogExporter - patch (v3019)
  --- org.apache.commons.math.linear.EigenDecompositionImpl
  +++ org.apache.commons.math.linear.EigenDecompositionImpl
  @@ -955,7 +955,6 @@
  work[j] = d + work[i];
  if (work[i] <= TOLERANCE_2 \* d) {
  work[i] = -0.0;
-                    work[j]     = d;
                       work[j + 2] = 0.0;
                       d = work[i + 2];
                   } else if ((MathUtils.SAFE_MIN * work[i + 2] < work[j]) &&
  @@ -1019,7 +1018,6 @@
  // two realEigenvalues found, deflate array
  if (work[k - 3] > work[k - 7]) {
  final double tmp = work[k - 3];
-                    work[k - 3] = work[k - 7];
                     work[k - 7] = tmp;
                 }

@@ -1052,15 +1050,10 @@
// step 2: flip array if needed
if ((dMin <= 0) || (deflatedEnd < end)) {
if (flipIfWarranted(deflatedEnd, 1)) {

-                dMin2 = Math.min(dMin2, work[l - 1]);
-                work[l - 1] =
-                    Math.min(work[l - 1],
-                             Math.min(work[3 + pingPong], work[7 + pingPong]));
                 work[l - 2 * pingPong] =
                     Math.min(work[l - 2 * pingPong],
                              Math.min(work[6 + pingPong], work[6 + pingPong]));
                 qMax  = Math.max(qMax, Math.max(work[3 + pingPong], work[7 + pingPong]));
-                dMin  = -0.0;
             }
         }

@@ -1136,7 +1129,6 @@
for (int i = 0; i < j; i += 4) {
for (int k = 0; k < 4; k += step) {
final double tmp = work[i + k];

-                    work[i + k] = work[j - k];
                       work[j - k] = tmp;
                   }
                   j -= 4;
  @@ -1381,10 +1373,10 @@
  int j4p2 = j4 + 2 \* pingPong - 1;
  work[j4 - 2] = dN2 + work[j4p2];
  if (work[j4 - 2] == 0.0) {
-            work[j4] = 0.0;
             dN1  = work[j4p2 + 2];
             dMin = dN1;
             eMin = 0.0;

*     	int k = 0;
           } else if ((MathUtils.SAFE_MIN * work[j4p2 + 2] < work[j4 - 2]) &&
                      (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4p2 + 2])) {
               final double tmp = work[j4p2 + 2] / work[j4 - 2];
  2023-08-15 22:56:46 [main] [INFO] PatchLogExporter - patch (v3019)
  --- org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic
  +++ org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic
  @@ -173,4 +173,3 @@
  return test(values, begin, length);
  }
  }

- 2023-08-15 22:56:46 [main] [INFO] PatchLogExporter - patch (v3019)
  --- org.apache.commons.math.optimization.fitting.WeightedObservedPoint
  +++ org.apache.commons.math.optimization.fitting.WeightedObservedPoint
  @@ -72,4 +72,3 @@
  }
  }
- 2023-08-15 22:56:46 [main] [INFO] PatchLogExporter - patch (v3019)
  --- org.apache.commons.math.linear.BigMatrix
  +++ org.apache.commons.math.linear.BigMatrix
  @@ -328,4 +328,3 @@
  \*/
  BigMatrix solve(BigMatrix b) throws IllegalArgumentException, InvalidMatrixException;
  }
- 2023-08-15 22:56:46 [main] [INFO] PatchLogExporter - patch (v3102)
  --- org.apache.commons.math.linear.EigenDecompositionImpl
  +++ org.apache.commons.math.linear.EigenDecompositionImpl
  @@ -875,7 +875,6 @@
  diagMin = Math.min(diagMin, work[i + 4]);
  offDiagMax = Math.max(offDiagMax, work[i + 2]);
  }
-                diagMax    = Math.max(diagMax, work[i] + work[i + 2]);
                   offDiagMin = Math.min(offDiagMin, work[i + 2]);
               }
               work[4 * n0 - 2] = offDiagMin;
  @@ -955,8 +954,6 @@
  work[j] = d + work[i];
  if (work[i] <= TOLERANCE_2 \* d) {
  work[i] = -0.0;
-                    work[j]     = d;
-                    work[j + 2] = 0.0;
                       d = work[i + 2];
                   } else if ((MathUtils.SAFE_MIN * work[i + 2] < work[j]) &&
                              (MathUtils.SAFE_MIN * work[j] < work[i + 2])) {
  @@ -1019,7 +1016,6 @@
  // two realEigenvalues found, deflate array
  if (work[k - 3] > work[k - 7]) {
  final double tmp = work[k - 3];
-                    work[k - 3] = work[k - 7];
                     work[k - 7] = tmp;
                 }

@@ -1052,7 +1048,6 @@
// step 2: flip array if needed
if ((dMin <= 0) || (deflatedEnd < end)) {
if (flipIfWarranted(deflatedEnd, 1)) {

-                dMin2 = Math.min(dMin2, work[l - 1]);
                   work[l - 1] =
                       Math.min(work[l - 1],
                                Math.min(work[3 + pingPong], work[7 + pingPong]));
  @@ -1060,7 +1055,6 @@
  Math.min(work[l - 2 * pingPong],
  Math.min(work[6 + pingPong], work[6 + pingPong]));
  qMax = Math.max(qMax, Math.max(work[3 + pingPong], work[7 + pingPong]));
-                dMin  = -0.0;
             }
         }

@@ -1136,7 +1130,7 @@
for (int i = 0; i < j; i += 4) {
for (int k = 0; k < 4; k += step) {
final double tmp = work[i + k];

-                    work[i + k] = work[j - k];

*                    cachedD = MatrixUtils.createRealDiagonalMatrix(realEigenvalues);
                       work[j - k] = tmp;
                   }
                   j -= 4;
  @@ -1385,6 +1379,7 @@
  dN1 = work[j4p2 + 2];
  dMin = dN1;
  eMin = 0.0;
*     	int k = 0;
           } else if ((MathUtils.SAFE_MIN * work[j4p2 + 2] < work[j4 - 2]) &&
                      (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4p2 + 2])) {
               final double tmp = work[j4p2 + 2] / work[j4 - 2];
  2023-08-15 22:56:46 [main] [INFO] PatchLogExporter - patch (v3102)
  --- org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic
  +++ org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic
  @@ -173,4 +173,3 @@
  return test(values, begin, length);
  }
  }

- 2023-08-15 22:56:46 [main] [INFO] PatchLogExporter - patch (v3102)
  --- org.apache.commons.math.optimization.fitting.WeightedObservedPoint
  +++ org.apache.commons.math.optimization.fitting.WeightedObservedPoint
  @@ -72,4 +72,3 @@
  }
  }
- 2023-08-15 22:56:46 [main] [INFO] PatchLogExporter - patch (v3102)
  --- org.apache.commons.math.linear.BigMatrix
  +++ org.apache.commons.math.linear.BigMatrix
  @@ -328,4 +328,3 @@
  \*/
  BigMatrix solve(BigMatrix b) throws IllegalArgumentException, InvalidMatrixException;
  }
- 2023-08-15 22:56:46 [main] [INFO] PatchLogExporter - patch (v3912)
  --- org.apache.commons.math.linear.EigenDecompositionImpl
  +++ org.apache.commons.math.linear.EigenDecompositionImpl
  @@ -875,7 +875,6 @@
  diagMin = Math.min(diagMin, work[i + 4]);
  offDiagMax = Math.max(offDiagMax, work[i + 2]);
  }
-                diagMax    = Math.max(diagMax, work[i] + work[i + 2]);
                   offDiagMin = Math.min(offDiagMin, work[i + 2]);
               }
               work[4 * n0 - 2] = offDiagMin;
  @@ -955,8 +954,6 @@
  work[j] = d + work[i];
  if (work[i] <= TOLERANCE_2 \* d) {
  work[i] = -0.0;
-                    work[j]     = d;
-                    work[j + 2] = 0.0;
                       d = work[i + 2];
                   } else if ((MathUtils.SAFE_MIN * work[i + 2] < work[j]) &&
                              (MathUtils.SAFE_MIN * work[j] < work[i + 2])) {
  @@ -1136,7 +1133,6 @@
  for (int i = 0; i < j; i += 4) {
  for (int k = 0; k < 4; k += step) {
  final double tmp = work[i + k];
-                    work[i + k] = work[j - k];
                       work[j - k] = tmp;
                   }
                   j -= 4;
  @@ -1382,6 +1378,8 @@
  work[j4 - 2] = dN2 + work[j4p2];
  if (work[j4 - 2] == 0.0) {
  work[j4] = 0.0;

*     	cachedVt = null;
*     	cachedVt = null;
               dN1  = work[j4p2 + 2];
               dMin = dN1;
               eMin = 0.0;
  @@ -1402,8 +1400,8 @@
  work[j4 - 2] = dN1 + work[j4p2];
  if (work[j4 - 2] == 0.0) {
  work[j4] = 0.0;

-            dN   = work[j4p2 + 2];
-            dMin = dN;

*            double sum = 0;
*     	dN   = work[j4p2 + 2];
               eMin = 0.0;
           } else if ((MathUtils.SAFE_MIN * work[j4p2 + 2] < work[j4 - 2]) &&
                      (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4p2 + 2])) {
  2023-08-15 22:56:46 [main] [INFO] PatchLogExporter - patch (v3912)
  --- org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic
  +++ org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic
  @@ -173,4 +173,3 @@
  return test(values, begin, length);
  }
  }

- 2023-08-15 22:56:46 [main] [INFO] PatchLogExporter - patch (v3912)
  --- org.apache.commons.math.optimization.fitting.WeightedObservedPoint
  +++ org.apache.commons.math.optimization.fitting.WeightedObservedPoint
  @@ -72,4 +72,3 @@
  }
  }
- 2023-08-15 22:56:46 [main] [INFO] PatchLogExporter - patch (v3912)
  --- org.apache.commons.math.linear.BigMatrix
  +++ org.apache.commons.math.linear.BigMatrix
  @@ -328,4 +328,3 @@
  \*/
  BigMatrix solve(BigMatrix b) throws IllegalArgumentException, InvalidMatrixException;
  }
- 2023-08-15 22:56:46 [main] [INFO] PatchLogExporter - patch (v4147)
  --- org.apache.commons.math.linear.EigenDecompositionImpl
  +++ org.apache.commons.math.linear.EigenDecompositionImpl
  @@ -847,7 +847,6 @@
  dMin1 = 0;
  dMin2 = 0;
  dN = 0;
-        dN1   = 0;
         dN2   = 0;
         tau   = 0;

@@ -955,9 +954,8 @@
work[j] = d + work[i];
if (work[i] <= TOLERANCE_2 \* d) {
work[i] = -0.0;

-                    work[j]     = d;
-                    work[j + 2] = 0.0;
                     d = work[i + 2];

*     			Arrays.sort(realEigenvalues);
                   } else if ((MathUtils.SAFE_MIN * work[i + 2] < work[j]) &&
                              (MathUtils.SAFE_MIN * work[j] < work[i + 2])) {
                       final double tmp = work[i + 2] / work[j];
  @@ -1020,7 +1018,6 @@
  if (work[k - 3] > work[k - 7]) {
  final double tmp = work[k - 3];
  work[k - 3] = work[k - 7];

-                    work[k - 7] = tmp;
                   }

                   if (work[k - 5] > TOLERANCE_2 * work[k - 3]) {
  @@ -1136,10 +1133,8 @@
  for (int i = 0; i < j; i += 4) {
  for (int k = 0; k < 4; k += step) {
  final double tmp = work[i + k];
-                    work[i + k] = work[j - k];
                     work[j - k] = tmp;
                 }
-                j -= 4;
               }
               return true;
           }
  2023-08-15 22:56:46 [main] [INFO] PatchLogExporter - patch (v4147)
  --- org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic
  +++ org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic
  @@ -173,4 +173,3 @@
  return test(values, begin, length);
  }
  }
- 2023-08-15 22:56:46 [main] [INFO] PatchLogExporter - patch (v4147)
  --- org.apache.commons.math.optimization.fitting.WeightedObservedPoint
  +++ org.apache.commons.math.optimization.fitting.WeightedObservedPoint
  @@ -72,4 +72,3 @@
  }
  }
- 2023-08-15 22:56:46 [main] [INFO] PatchLogExporter - patch (v4147)
  --- org.apache.commons.math.linear.BigMatrix
  +++ org.apache.commons.math.linear.BigMatrix
  @@ -328,4 +328,3 @@
  \*/
  BigMatrix solve(BigMatrix b) throws IllegalArgumentException, InvalidMatrixException;
  }
- 2023-08-15 22:56:46 [main] [INFO] PatchLogExporter - patch (v4434)
  --- org.apache.commons.math.linear.ArrayRealVector
  +++ org.apache.commons.math.linear.ArrayRealVector
  @@ -243,7 +243,6 @@
  /\*_ {@inheritDoc} _/
  public RealVector add(double[] v)
  throws IllegalArgumentException {
-        checkVectorDimensions(v.length);
           double[] out = new double[data.length];
           for (int i = 0; i < data.length; i++) {
               out[i] = data[i] + v[i];
  2023-08-15 22:56:46 [main] [INFO] PatchLogExporter - patch (v4434)
  --- org.apache.commons.math.linear.EigenDecompositionImpl
  +++ org.apache.commons.math.linear.EigenDecompositionImpl
  @@ -875,7 +875,6 @@
  diagMin = Math.min(diagMin, work[i + 4]);
  offDiagMax = Math.max(offDiagMax, work[i + 2]);
  }
-                diagMax    = Math.max(diagMax, work[i] + work[i + 2]);
                   offDiagMin = Math.min(offDiagMin, work[i + 2]);
               }
               work[4 * n0 - 2] = offDiagMin;
  @@ -942,7 +941,6 @@
  for (int i = 4 _ (n - 2) + pingPong; i >= 0; i -= 4) {
  if (work[i + 2] <= TOLERANCE_2 _ d) {
  work[i + 2] = -0.0;
-                    d = work[i];
                   } else {
                       d *= work[i] / (d + work[i + 2]);
                   }
  @@ -955,7 +953,6 @@
  work[j] = d + work[i];
  if (work[i] <= TOLERANCE_2 \* d) {
  work[i] = -0.0;
-                    work[j]     = d;
                       work[j + 2] = 0.0;
                       d = work[i + 2];
                   } else if ((MathUtils.SAFE_MIN * work[i + 2] < work[j]) &&
  @@ -1019,7 +1016,6 @@
  // two realEigenvalues found, deflate array
  if (work[k - 3] > work[k - 7]) {
  final double tmp = work[k - 3];
-                    work[k - 3] = work[k - 7];
                     work[k - 7] = tmp;
                 }

@@ -1136,7 +1132,6 @@
for (int i = 0; i < j; i += 4) {
for (int k = 0; k < 4; k += step) {
final double tmp = work[i + k];

-                    work[i + k] = work[j - k];
                       work[j - k] = tmp;
                   }
                   j -= 4;
  @@ -1382,6 +1377,7 @@
  work[j4 - 2] = dN2 + work[j4p2];
  if (work[j4 - 2] == 0.0) {
  work[j4] = 0.0;

*     	cachedVt = null;
               dN1  = work[j4p2 + 2];
               dMin = dN1;
               eMin = 0.0;
  @@ -1402,9 +1398,8 @@
  work[j4 - 2] = dN1 + work[j4p2];
  if (work[j4 - 2] == 0.0) {
  work[j4] = 0.0;

-            dN   = work[j4p2 + 2];
-            dMin = dN;
-            eMin = 0.0;

*            double sum = 0;
*     	eMin = 0.0;
           } else if ((MathUtils.SAFE_MIN * work[j4p2 + 2] < work[j4 - 2]) &&
                      (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4p2 + 2])) {
               final double tmp = work[j4p2 + 2] / work[j4 - 2];
  2023-08-15 22:56:46 [main] [INFO] PatchLogExporter - patch (v4434)
  --- org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic
  +++ org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic
  @@ -173,4 +173,3 @@
  return test(values, begin, length);
  }
  }

- 2023-08-15 22:56:46 [main] [INFO] PatchLogExporter - patch (v4434)
  --- org.apache.commons.math.optimization.fitting.WeightedObservedPoint
  +++ org.apache.commons.math.optimization.fitting.WeightedObservedPoint
  @@ -72,4 +72,3 @@
  }
  }
- 2023-08-15 22:56:46 [main] [INFO] PatchLogExporter - patch (v4434)
  --- org.apache.commons.math.linear.BigMatrix
  +++ org.apache.commons.math.linear.BigMatrix
  @@ -328,4 +328,3 @@
  \*/
  BigMatrix solve(BigMatrix b) throws IllegalArgumentException, InvalidMatrixException;
  }
- 2023-08-15 22:56:46 [main] [INFO] PatchLogExporter - patch (v4749)
  --- org.apache.commons.math.linear.ArrayRealVector
  +++ org.apache.commons.math.linear.ArrayRealVector
  @@ -243,7 +243,6 @@
  /\*_ {@inheritDoc} _/
  public RealVector add(double[] v)
  throws IllegalArgumentException {
-        checkVectorDimensions(v.length);
           double[] out = new double[data.length];
           for (int i = 0; i < data.length; i++) {
               out[i] = data[i] + v[i];
  2023-08-15 22:56:46 [main] [INFO] PatchLogExporter - patch (v4749)
  --- org.apache.commons.math.linear.EigenDecompositionImpl
  +++ org.apache.commons.math.linear.EigenDecompositionImpl
  @@ -955,9 +955,7 @@
  work[j] = d + work[i];
  if (work[i] <= TOLERANCE_2 \* d) {
  work[i] = -0.0;
-                    work[j]     = d;
                     work[j + 2] = 0.0;
-                    d = work[i + 2];
                   } else if ((MathUtils.SAFE_MIN * work[i + 2] < work[j]) &&
                              (MathUtils.SAFE_MIN * work[j] < work[i + 2])) {
                       final double tmp = work[i + 2] / work[j];
  @@ -1133,14 +1131,8 @@
  if (1.5 _ work[pingPong] < work[4 _ (n - 1) + pingPong]) {
  // flip array
  int j = 4 \* n - 1;
-            for (int i = 0; i < j; i += 4) {
-                for (int k = 0; k < 4; k += step) {
-                    final double tmp = work[i + k];
-                    work[i + k] = work[j - k];
-                    work[j - k] = tmp;
-                }
-                j -= 4;
-            }

*            for (int i = 0; i < j; i += 4)
*     		return true;
               return true;
           }
           return false;
  @@ -1381,10 +1373,9 @@
  int j4p2 = j4 + 2 \* pingPong - 1;
  work[j4 - 2] = dN2 + work[j4p2];
  if (work[j4 - 2] == 0.0) {

-            work[j4] = 0.0;

*            cachedVt = null;
             dN1  = work[j4p2 + 2];
             dMin = dN1;

-            eMin = 0.0;
           } else if ((MathUtils.SAFE_MIN * work[j4p2 + 2] < work[j4 - 2]) &&
                      (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4p2 + 2])) {
               final double tmp = work[j4p2 + 2] / work[j4 - 2];
  @@ -1402,8 +1393,9 @@
  work[j4 - 2] = dN1 + work[j4p2];
  if (work[j4 - 2] == 0.0) {
  work[j4] = 0.0;
-            dN   = work[j4p2 + 2];
-            dMin = dN;

*     	cachedVt = null;
*            double sum = 0;
*     	dN   = work[j4p2 + 2];
               eMin = 0.0;
           } else if ((MathUtils.SAFE_MIN * work[j4p2 + 2] < work[j4 - 2]) &&
                      (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4p2 + 2])) {
  2023-08-15 22:56:46 [main] [INFO] PatchLogExporter - patch (v4749)
  --- org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic
  +++ org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic
  @@ -173,4 +173,3 @@
  return test(values, begin, length);
  }
  }

- 2023-08-15 22:56:46 [main] [INFO] PatchLogExporter - patch (v4749)
  --- org.apache.commons.math.optimization.fitting.WeightedObservedPoint
  +++ org.apache.commons.math.optimization.fitting.WeightedObservedPoint
  @@ -72,4 +72,3 @@
  }
  }
- 2023-08-15 22:56:46 [main] [INFO] PatchLogExporter - patch (v4749)
  --- org.apache.commons.math.linear.BigMatrix
  +++ org.apache.commons.math.linear.BigMatrix
  @@ -328,4 +328,3 @@
  \*/
  BigMatrix solve(BigMatrix b) throws IllegalArgumentException, InvalidMatrixException;
  }
- 2023-08-15 22:56:46 [main] [INFO] PatchLogExporter - patch (v4825)
  --- org.apache.commons.math.linear.EigenDecompositionImpl
  +++ org.apache.commons.math.linear.EigenDecompositionImpl
  @@ -875,7 +875,6 @@
  diagMin = Math.min(diagMin, work[i + 4]);
  offDiagMax = Math.max(offDiagMax, work[i + 2]);
  }
-                diagMax    = Math.max(diagMax, work[i] + work[i + 2]);
                   offDiagMin = Math.min(offDiagMin, work[i + 2]);
               }
               work[4 * n0 - 2] = offDiagMin;
  @@ -941,7 +940,6 @@
  double d = work[4 * (n - 1) + pingPong];
  for (int i = 4 _ (n - 2) + pingPong; i >= 0; i -= 4) {
  if (work[i + 2] <= TOLERANCE_2 _ d) {
-                    work[i + 2] = -0.0;
                       d = work[i];
                   } else {
                       d *= work[i] / (d + work[i + 2]);
  @@ -956,8 +954,8 @@
  if (work[i] <= TOLERANCE_2 \* d) {
  work[i] = -0.0;
  work[j] = d;
-                    work[j + 2] = 0.0;
                     d = work[i + 2];

*     			Arrays.sort(realEigenvalues);
                   } else if ((MathUtils.SAFE_MIN * work[i + 2] < work[j]) &&
                              (MathUtils.SAFE_MIN * work[j] < work[i + 2])) {
                       final double tmp = work[i + 2] / work[j];
  @@ -1020,7 +1018,6 @@
  if (work[k - 3] > work[k - 7]) {
  final double tmp = work[k - 3];
  work[k - 3] = work[k - 7];

-                    work[k - 7] = tmp;
                   }

                   if (work[k - 5] > TOLERANCE_2 * work[k - 3]) {
  @@ -1053,14 +1050,10 @@
  if ((dMin <= 0) || (deflatedEnd < end)) {
  if (flipIfWarranted(deflatedEnd, 1)) {
  dMin2 = Math.min(dMin2, work[l - 1]);
-                work[l - 1] =
-                    Math.min(work[l - 1],
-                             Math.min(work[3 + pingPong], work[7 + pingPong]));
                 work[l - 2 * pingPong] =
                     Math.min(work[l - 2 * pingPong],
                              Math.min(work[6 + pingPong], work[6 + pingPong]));
                 qMax  = Math.max(qMax, Math.max(work[3 + pingPong], work[7 + pingPong]));
-                dMin  = -0.0;
             }
         }

@@ -1136,7 +1129,6 @@
for (int i = 0; i < j; i += 4) {
for (int k = 0; k < 4; k += step) {
final double tmp = work[i + k];

-                    work[i + k] = work[j - k];
                       work[j - k] = tmp;
                   }
                   j -= 4;
  @@ -1381,7 +1373,6 @@
  int j4p2 = j4 + 2 \* pingPong - 1;
  work[j4 - 2] = dN2 + work[j4p2];
  if (work[j4 - 2] == 0.0) {
-            work[j4] = 0.0;
               dN1  = work[j4p2 + 2];
               dMin = dN1;
               eMin = 0.0;
  @@ -1402,6 +1393,7 @@
  work[j4 - 2] = dN1 + work[j4p2];
  if (work[j4 - 2] == 0.0) {
  work[j4] = 0.0;

*     	cachedVt = null;
               dN   = work[j4p2 + 2];
               dMin = dN;
               eMin = 0.0;
  2023-08-15 22:56:46 [main] [INFO] PatchLogExporter - patch (v4825)
  --- org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic
  +++ org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic
  @@ -173,4 +173,3 @@
  return test(values, begin, length);
  }
  }

- 2023-08-15 22:56:46 [main] [INFO] PatchLogExporter - patch (v4825)
  --- org.apache.commons.math.optimization.fitting.WeightedObservedPoint
  +++ org.apache.commons.math.optimization.fitting.WeightedObservedPoint
  @@ -72,4 +72,3 @@
  }
  }
- 2023-08-15 22:56:46 [main] [INFO] PatchLogExporter - patch (v4825)
  --- org.apache.commons.math.linear.BigMatrix
  +++ org.apache.commons.math.linear.BigMatrix
  @@ -328,4 +328,3 @@
  \*/
  BigMatrix solve(BigMatrix b) throws IllegalArgumentException, InvalidMatrixException;
  }
- 2023-08-15 22:56:46 [main] [INFO] PatchLogExporter - patch (v5126)
  --- org.apache.commons.math.linear.EigenDecompositionImpl
  +++ org.apache.commons.math.linear.EigenDecompositionImpl
  @@ -956,8 +956,9 @@
  if (work[i] <= TOLERANCE_2 \* d) {
  work[i] = -0.0;
  work[j] = d;
-                    work[j + 2] = 0.0;
                     d = work[i + 2];

*     			Arrays.sort(realEigenvalues);
*     			Arrays.sort(realEigenvalues);
                   } else if ((MathUtils.SAFE_MIN * work[i + 2] < work[j]) &&
                              (MathUtils.SAFE_MIN * work[j] < work[i + 2])) {
                       final double tmp = work[i + 2] / work[j];
  @@ -1020,7 +1021,6 @@
  if (work[k - 3] > work[k - 7]) {
  final double tmp = work[k - 3];
  work[k - 3] = work[k - 7];

-                    work[k - 7] = tmp;
                   }

                   if (work[k - 5] > TOLERANCE_2 * work[k - 3]) {
  @@ -1052,10 +1052,6 @@
  // step 2: flip array if needed
  if ((dMin <= 0) || (deflatedEnd < end)) {
  if (flipIfWarranted(deflatedEnd, 1)) {
-                dMin2 = Math.min(dMin2, work[l - 1]);
-                work[l - 1] =
-                    Math.min(work[l - 1],
-                             Math.min(work[3 + pingPong], work[7 + pingPong]));
                   work[l - 2 * pingPong] =
                       Math.min(work[l - 2 * pingPong],
                                Math.min(work[6 + pingPong], work[6 + pingPong]));
  @@ -1134,12 +1130,8 @@
  // flip array
  int j = 4 \* n - 1;
  for (int i = 0; i < j; i += 4) {
-                for (int k = 0; k < 4; k += step) {
-                    final double tmp = work[i + k];
-                    work[i + k] = work[j - k];
-                    work[j - k] = tmp;
-                }
-                j -= 4;

*                for (int k = 0; k < 4; k += step)
*     			dMin = 0.0;
               }
               return true;
           }
  @@ -1338,7 +1330,6 @@
  if (work[j4 - 2] == 0.0) {
  work[j4] = 0.0;
  d = work[j4 + 1];

-                    dMin = d;
                       eMin = 0.0;
                   } else if ((MathUtils.SAFE_MIN * work[j4 + 1] < work[j4 - 2]) &&
                              (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4 + 1])) {
  @@ -1382,9 +1373,9 @@
  work[j4 - 2] = dN2 + work[j4p2];
  if (work[j4 - 2] == 0.0) {
  work[j4] = 0.0;

*     	cachedVt = null;
           dN1  = work[j4p2 + 2];
           dMin = dN1;

-            eMin = 0.0;
           } else if ((MathUtils.SAFE_MIN * work[j4p2 + 2] < work[j4 - 2]) &&
                      (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4p2 + 2])) {
               final double tmp = work[j4p2 + 2] / work[j4 - 2];
  @@ -1403,7 +1394,6 @@
  if (work[j4 - 2] == 0.0) {
  work[j4] = 0.0;
  dN = work[j4p2 + 2];
-            dMin = dN;
               eMin = 0.0;
           } else if ((MathUtils.SAFE_MIN * work[j4p2 + 2] < work[j4 - 2]) &&
                      (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4p2 + 2])) {
  2023-08-15 22:56:46 [main] [INFO] PatchLogExporter - patch (v5126)
  --- org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic
  +++ org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic
  @@ -173,4 +173,3 @@
  return test(values, begin, length);
  }
  }
- 2023-08-15 22:56:46 [main] [INFO] PatchLogExporter - patch (v5126)
  --- org.apache.commons.math.optimization.fitting.WeightedObservedPoint
  +++ org.apache.commons.math.optimization.fitting.WeightedObservedPoint
  @@ -72,4 +72,3 @@
  }
  }
- 2023-08-15 22:56:46 [main] [INFO] PatchLogExporter - patch (v5126)
  --- org.apache.commons.math.linear.BigMatrix
  +++ org.apache.commons.math.linear.BigMatrix
  @@ -328,4 +328,3 @@
  \*/
  BigMatrix solve(BigMatrix b) throws IllegalArgumentException, InvalidMatrixException;
  }
- 2023-08-15 22:56:47 [main] [INFO] PatchLogExporter - patch (v5507)
  --- org.apache.commons.math.linear.ArrayRealVector
  +++ org.apache.commons.math.linear.ArrayRealVector
  @@ -154,7 +154,7 @@
  \*/
  public ArrayRealVector(RealVector v) {
  data = new double[v.getDimension()];
-        for (int i = 0; i < data.length; ++i) {

*        for (int i = 0;; ++i) {
               data[i] = v.getEntry(i);
           }
       }
  2023-08-15 22:56:47 [main] [INFO] PatchLogExporter - patch (v5507)
  --- org.apache.commons.math.linear.EigenDecompositionImpl
  +++ org.apache.commons.math.linear.EigenDecompositionImpl
  @@ -847,7 +847,6 @@
  dMin1 = 0;
  dMin2 = 0;
  dN = 0;

-        dN1   = 0;
         dN2   = 0;
         tau   = 0;

@@ -954,7 +953,6 @@
final int j = i - 2 _ pingPong - 1;
work[j] = d + work[i];
if (work[i] <= TOLERANCE_2 _ d) {

-                    work[i]     = -0.0;
                       work[j]     = d;
                       work[j + 2] = 0.0;
                       d = work[i + 2];
  @@ -1136,7 +1134,6 @@
  for (int i = 0; i < j; i += 4) {
  for (int k = 0; k < 4; k += step) {
  final double tmp = work[i + k];
-                    work[i + k] = work[j - k];
                       work[j - k] = tmp;
                   }
                   j -= 4;
  @@ -1358,7 +1355,6 @@
  if (work[j4 - 3] == 0.0) {
  work[j4 - 1] = 0.0;
  d = work[j4 + 2];
-                    dMin = d;
                       eMin = 0.0;
                   } else if ((MathUtils.SAFE_MIN * work[j4 + 2] < work[j4 - 3]) &&
                              (MathUtils.SAFE_MIN * work[j4 - 3] < work[j4 + 2])) {
  @@ -1381,10 +1377,7 @@
  int j4p2 = j4 + 2 \* pingPong - 1;
  work[j4 - 2] = dN2 + work[j4p2];
  if (work[j4 - 2] == 0.0) {
-            work[j4] = 0.0;
-            dN1  = work[j4p2 + 2];
             dMin = dN1;
-            eMin = 0.0;
           } else if ((MathUtils.SAFE_MIN * work[j4p2 + 2] < work[j4 - 2]) &&
                      (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4p2 + 2])) {
               final double tmp = work[j4p2 + 2] / work[j4 - 2];
  @@ -1402,9 +1395,8 @@
  work[j4 - 2] = dN1 + work[j4p2];
  if (work[j4 - 2] == 0.0) {
  work[j4] = 0.0;
-            dN   = work[j4p2 + 2];
-            dMin = dN;
-            eMin = 0.0;

*            double sum = 0;
*     	dN   = work[j4p2 + 2];
           } else if ((MathUtils.SAFE_MIN * work[j4p2 + 2] < work[j4 - 2]) &&
                      (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4p2 + 2])) {
               final double tmp = work[j4p2 + 2] / work[j4 - 2];
  2023-08-15 22:56:47 [main] [INFO] PatchLogExporter - patch (v5507)
  --- org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic
  +++ org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic
  @@ -173,4 +173,3 @@
  return test(values, begin, length);
  }
  }

- 2023-08-15 22:56:47 [main] [INFO] PatchLogExporter - patch (v5507)
  --- org.apache.commons.math.optimization.fitting.WeightedObservedPoint
  +++ org.apache.commons.math.optimization.fitting.WeightedObservedPoint
  @@ -72,4 +72,3 @@
  }
  }
- 2023-08-15 22:56:47 [main] [INFO] PatchLogExporter - patch (v5507)
  --- org.apache.commons.math.linear.BigMatrix
  +++ org.apache.commons.math.linear.BigMatrix
  @@ -328,4 +328,3 @@
  \*/
  BigMatrix solve(BigMatrix b) throws IllegalArgumentException, InvalidMatrixException;
  }
- 2023-08-15 22:56:47 [main] [INFO] PatchLogExporter - patch (v5650)
  --- org.apache.commons.math.linear.EigenDecompositionImpl
  +++ org.apache.commons.math.linear.EigenDecompositionImpl
  @@ -869,7 +869,6 @@
  for (int i = 4 \* (n0 - 2); i >= 0; i -= 4) {
  if (work[i + 2] <= 0) {
  i0 = 1 + i / 4;
-                    break;
                   }
                   if (diagMin >= 4 * offDiagMax) {
                       diagMin    = Math.min(diagMin, work[i + 4]);
  @@ -941,8 +940,6 @@
  double d = work[4 * (n - 1) + pingPong];
  for (int i = 4 _ (n - 2) + pingPong; i >= 0; i -= 4) {
  if (work[i + 2] <= TOLERANCE_2 _ d) {
-                    work[i + 2] = -0.0;
-                    d = work[i];
                   } else {
                       d *= work[i] / (d + work[i + 2]);
                   }
  @@ -954,10 +951,9 @@
  final int j = i - 2 _ pingPong - 1;
  work[j] = d + work[i];
  if (work[i] <= TOLERANCE_2 _ d) {
-                    work[i]     = -0.0;
                     work[j]     = d;
-                    work[j + 2] = 0.0;
                     d = work[i + 2];

*     			Arrays.sort(realEigenvalues);
                   } else if ((MathUtils.SAFE_MIN * work[i + 2] < work[j]) &&
                              (MathUtils.SAFE_MIN * work[j] < work[i + 2])) {
                       final double tmp = work[i + 2] / work[j];
  @@ -1020,7 +1016,6 @@
  if (work[k - 3] > work[k - 7]) {
  final double tmp = work[k - 3];
  work[k - 3] = work[k - 7];

-                    work[k - 7] = tmp;
                   }

                   if (work[k - 5] > TOLERANCE_2 * work[k - 3]) {
  @@ -1053,9 +1048,6 @@
  if ((dMin <= 0) || (deflatedEnd < end)) {
  if (flipIfWarranted(deflatedEnd, 1)) {
  dMin2 = Math.min(dMin2, work[l - 1]);
-                work[l - 1] =
-                    Math.min(work[l - 1],
-                             Math.min(work[3 + pingPong], work[7 + pingPong]));
                   work[l - 2 * pingPong] =
                       Math.min(work[l - 2 * pingPong],
                                Math.min(work[6 + pingPong], work[6 + pingPong]));
  @@ -1136,12 +1128,10 @@
  for (int i = 0; i < j; i += 4) {
  for (int k = 0; k < 4; k += step) {
  final double tmp = work[i + k];
-                    work[i + k] = work[j - k];
                     work[j - k] = tmp;
                 }
                 j -= 4;
             }
-            return true;
           }
           return false;
       }
  @@ -1365,9 +1355,6 @@
  final double tmp = work[j4 + 2] / work[j4 - 3];
  work[j4 - 1] = work[j4] _ tmp;
  d _= tmp;
-                } else {
-                    work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]);
-                    d *= work[j4 + 2] / work[j4 - 3];
                   }
                   dMin = Math.min(dMin, d);
                   eMin = Math.min(eMin, work[j4 - 1]);
  @@ -1384,7 +1371,7 @@
  work[j4] = 0.0;
  dN1 = work[j4p2 + 2];
  dMin = dN1;
-            eMin = 0.0;

*            int k = 0;
           } else if ((MathUtils.SAFE_MIN * work[j4p2 + 2] < work[j4 - 2]) &&
                      (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4p2 + 2])) {
               final double tmp = work[j4p2 + 2] / work[j4 - 2];
  @@ -1403,7 +1390,6 @@
  if (work[j4 - 2] == 0.0) {
  work[j4] = 0.0;
  dN = work[j4p2 + 2];

-            dMin = dN;
               eMin = 0.0;
           } else if ((MathUtils.SAFE_MIN * work[j4p2 + 2] < work[j4 - 2]) &&
                      (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4p2 + 2])) {
  2023-08-15 22:56:47 [main] [INFO] PatchLogExporter - patch (v5650)
  --- org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic
  +++ org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic
  @@ -173,4 +173,3 @@
  return test(values, begin, length);
  }
  }
- 2023-08-15 22:56:47 [main] [INFO] PatchLogExporter - patch (v5650)
  --- org.apache.commons.math.optimization.fitting.WeightedObservedPoint
  +++ org.apache.commons.math.optimization.fitting.WeightedObservedPoint
  @@ -72,4 +72,3 @@
  }
  }
- 2023-08-15 22:56:47 [main] [INFO] PatchLogExporter - patch (v5650)
  --- org.apache.commons.math.linear.BigMatrix
  +++ org.apache.commons.math.linear.BigMatrix
  @@ -328,4 +328,3 @@
  \*/
  BigMatrix solve(BigMatrix b) throws IllegalArgumentException, InvalidMatrixException;
  }
- 2023-08-15 22:56:47 [main] [INFO] PatchLogExporter - patch (v6347)
  --- org.apache.commons.math.linear.ArrayRealVector
  +++ org.apache.commons.math.linear.ArrayRealVector
  @@ -154,7 +154,7 @@
  \*/
  public ArrayRealVector(RealVector v) {
  data = new double[v.getDimension()];
-        for (int i = 0; i < data.length; ++i) {

*        for (int i = 0;; ++i) {
               data[i] = v.getEntry(i);
           }
       }
  2023-08-15 22:56:47 [main] [INFO] PatchLogExporter - patch (v6347)
  --- org.apache.commons.math.linear.EigenDecompositionImpl
  +++ org.apache.commons.math.linear.EigenDecompositionImpl
  @@ -942,6 +942,14 @@
  for (int i = 4 _ (n - 2) + pingPong; i >= 0; i -= 4) {
  if (work[i + 2] <= TOLERANCE_2 _ d) {
  work[i + 2] = -0.0;
*     			{
*     				work[i + 2] = -0.0;
*     				d = work[i];
*     			}
*     			{
*     				work[i + 2] = -0.0;
*     				d = work[i];
*     			}
                       d = work[i];
                   } else {
                       d *= work[i] / (d + work[i + 2]);
  @@ -958,6 +966,7 @@
  work[j] = d;
  work[j + 2] = 0.0;
  d = work[i + 2];
*     			Arrays.sort(realEigenvalues);
                   } else if ((MathUtils.SAFE_MIN * work[i + 2] < work[j]) &&
                              (MathUtils.SAFE_MIN * work[j] < work[i + 2])) {
                       final double tmp = work[i + 2] / work[j];
  @@ -1136,12 +1145,10 @@
  for (int i = 0; i < j; i += 4) {
  for (int k = 0; k < 4; k += step) {
  final double tmp = work[i + k];

-                    work[i + k] = work[j - k];
-                    work[j - k] = tmp;

*                    ++k;
                 }
                 j -= 4;
             }

-            return true;
           }
           return false;
       }
  @@ -1358,7 +1365,6 @@
  if (work[j4 - 3] == 0.0) {
  work[j4 - 1] = 0.0;
  d = work[j4 + 2];
-                    dMin = d;
                       eMin = 0.0;
                   } else if ((MathUtils.SAFE_MIN * work[j4 + 2] < work[j4 - 3]) &&
                              (MathUtils.SAFE_MIN * work[j4 - 3] < work[j4 + 2])) {
  @@ -1381,10 +1387,8 @@
  int j4p2 = j4 + 2 \* pingPong - 1;
  work[j4 - 2] = dN2 + work[j4p2];
  if (work[j4 - 2] == 0.0) {
-            work[j4] = 0.0;
             dN1  = work[j4p2 + 2];
             dMin = dN1;
-            eMin = 0.0;
           } else if ((MathUtils.SAFE_MIN * work[j4p2 + 2] < work[j4 - 2]) &&
                      (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4p2 + 2])) {
               final double tmp = work[j4p2 + 2] / work[j4 - 2];
  @@ -1402,9 +1406,9 @@
  work[j4 - 2] = dN1 + work[j4p2];
  if (work[j4 - 2] == 0.0) {
  work[j4] = 0.0;

*     	cachedVt = null;
           dN   = work[j4p2 + 2];
           dMin = dN;

-            eMin = 0.0;
           } else if ((MathUtils.SAFE_MIN * work[j4p2 + 2] < work[j4 - 2]) &&
                      (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4p2 + 2])) {
               final double tmp = work[j4p2 + 2] / work[j4 - 2];
  2023-08-15 22:56:47 [main] [INFO] PatchLogExporter - patch (v6347)
  --- org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic
  +++ org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic
  @@ -173,4 +173,3 @@
  return test(values, begin, length);
  }
  }
- 2023-08-15 22:56:47 [main] [INFO] PatchLogExporter - patch (v6347)
  --- org.apache.commons.math.optimization.fitting.WeightedObservedPoint
  +++ org.apache.commons.math.optimization.fitting.WeightedObservedPoint
  @@ -72,4 +72,3 @@
  }
  }
- 2023-08-15 22:56:47 [main] [INFO] PatchLogExporter - patch (v6347)
  --- org.apache.commons.math.linear.BigMatrix
  +++ org.apache.commons.math.linear.BigMatrix
  @@ -328,4 +328,3 @@
  \*/
  BigMatrix solve(BigMatrix b) throws IllegalArgumentException, InvalidMatrixException;
  }
- 2023-08-15 22:56:47 [main] [INFO] PatchLogExporter - patch (v6742)
  --- org.apache.commons.math.linear.Array2DRowRealMatrix
  +++ org.apache.commons.math.linear.Array2DRowRealMatrix
  @@ -328,7 +328,7 @@
  }
               final int nCols = subMatrix[0].length;
-            if (nCols == 0) {

*            if (this.isSingular()) {
                   throw MathRuntimeException.createIllegalArgumentException("matrix must have at least one column");
               }
               data = new double[subMatrix.length][nCols];
  2023-08-15 22:56:47 [main] [INFO] PatchLogExporter - patch (v6742)
  --- org.apache.commons.math.linear.EigenDecompositionImpl
  +++ org.apache.commons.math.linear.EigenDecompositionImpl
  @@ -1019,7 +1019,6 @@
  // two realEigenvalues found, deflate array
  if (work[k - 3] > work[k - 7]) {
  final double tmp = work[k - 3];

-                    work[k - 3] = work[k - 7];
                     work[k - 7] = tmp;
                 }

@@ -1053,9 +1052,6 @@
if ((dMin <= 0) || (deflatedEnd < end)) {
if (flipIfWarranted(deflatedEnd, 1)) {
dMin2 = Math.min(dMin2, work[l - 1]);

-                work[l - 1] =
-                    Math.min(work[l - 1],
-                             Math.min(work[3 + pingPong], work[7 + pingPong]));
                   work[l - 2 * pingPong] =
                       Math.min(work[l - 2 * pingPong],
                                Math.min(work[6 + pingPong], work[6 + pingPong]));
  @@ -1136,12 +1132,8 @@
  for (int i = 0; i < j; i += 4) {
  for (int k = 0; k < 4; k += step) {
  final double tmp = work[i + k];
-                    work[i + k] = work[j - k];
-                    work[j - k] = tmp;
                 }
-                j -= 4;
             }
-            return true;
           }
           return false;
       }
  @@ -1358,7 +1350,6 @@
  if (work[j4 - 3] == 0.0) {
  work[j4 - 1] = 0.0;
  d = work[j4 + 2];
-                    dMin = d;
                       eMin = 0.0;
                   } else if ((MathUtils.SAFE_MIN * work[j4 + 2] < work[j4 - 3]) &&
                              (MathUtils.SAFE_MIN * work[j4 - 3] < work[j4 + 2])) {
  @@ -1381,10 +1372,7 @@
  int j4p2 = j4 + 2 \* pingPong - 1;
  work[j4 - 2] = dN2 + work[j4p2];
  if (work[j4 - 2] == 0.0) {
-            work[j4] = 0.0;
-            dN1  = work[j4p2 + 2];
             dMin = dN1;
-            eMin = 0.0;
           } else if ((MathUtils.SAFE_MIN * work[j4p2 + 2] < work[j4 - 2]) &&
                      (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4p2 + 2])) {
               final double tmp = work[j4p2 + 2] / work[j4 - 2];
  @@ -1401,10 +1389,9 @@
  j4p2 = j4 + 2 \* pingPong - 1;
  work[j4 - 2] = dN1 + work[j4p2];
  if (work[j4 - 2] == 0.0) {
-            work[j4] = 0.0;
             dN   = work[j4p2 + 2];
             dMin = dN;
-            eMin = 0.0;

*            int k = 0;
           } else if ((MathUtils.SAFE_MIN * work[j4p2 + 2] < work[j4 - 2]) &&
                      (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4p2 + 2])) {
               final double tmp = work[j4p2 + 2] / work[j4 - 2];
  2023-08-15 22:56:47 [main] [INFO] PatchLogExporter - patch (v6742)
  --- org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic
  +++ org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic
  @@ -173,4 +173,3 @@
  return test(values, begin, length);
  }
  }

- 2023-08-15 22:56:47 [main] [INFO] PatchLogExporter - patch (v6742)
  --- org.apache.commons.math.optimization.fitting.WeightedObservedPoint
  +++ org.apache.commons.math.optimization.fitting.WeightedObservedPoint
  @@ -72,4 +72,3 @@
  }
  }
- 2023-08-15 22:56:47 [main] [INFO] PatchLogExporter - patch (v6742)
  --- org.apache.commons.math.linear.BigMatrix
  +++ org.apache.commons.math.linear.BigMatrix
  @@ -328,4 +328,3 @@
  \*/
  BigMatrix solve(BigMatrix b) throws IllegalArgumentException, InvalidMatrixException;
  }
- 2023-08-15 22:56:47 [main] [INFO] PatchLogExporter - patch (v7302)
  --- org.apache.commons.math.linear.Array2DRowRealMatrix
  +++ org.apache.commons.math.linear.Array2DRowRealMatrix
  @@ -328,7 +328,7 @@
  }
               final int nCols = subMatrix[0].length;
-            if (nCols == 0) {

*            if (this.isSingular()) {
                   throw MathRuntimeException.createIllegalArgumentException("matrix must have at least one column");
               }
               data = new double[subMatrix.length][nCols];
  2023-08-15 22:56:47 [main] [INFO] PatchLogExporter - patch (v7302)
  --- org.apache.commons.math.linear.EigenDecompositionImpl
  +++ org.apache.commons.math.linear.EigenDecompositionImpl
  @@ -876,7 +876,6 @@
  offDiagMax = Math.max(offDiagMax, work[i + 2]);
  }
  diagMax = Math.max(diagMax, work[i] + work[i + 2]);

-                offDiagMin = Math.min(offDiagMin, work[i + 2]);
             }
             work[4 * n0 - 2] = offDiagMin;

@@ -941,7 +940,6 @@
double d = work[4 * (n - 1) + pingPong];
for (int i = 4 _ (n - 2) + pingPong; i >= 0; i -= 4) {
if (work[i + 2] <= TOLERANCE_2 _ d) {

-                    work[i + 2] = -0.0;
                       d = work[i];
                   } else {
                       d *= work[i] / (d + work[i + 2]);
  @@ -1136,12 +1134,9 @@
  for (int i = 0; i < j; i += 4) {
  for (int k = 0; k < 4; k += step) {
  final double tmp = work[i + k];
-                    work[i + k] = work[j - k];
-                    work[j - k] = tmp;
                 }
                 j -= 4;
             }
-            return true;
           }
           return false;
       }
  @@ -1338,7 +1333,6 @@
  if (work[j4 - 2] == 0.0) {
  work[j4] = 0.0;
  d = work[j4 + 1];
-                    dMin = d;
                       eMin = 0.0;
                   } else if ((MathUtils.SAFE_MIN * work[j4 + 1] < work[j4 - 2]) &&
                              (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4 + 1])) {
  @@ -1347,7 +1341,6 @@
  d _= tmp;
  } else {
  work[j4] = work[j4 + 1] _ (work[j4 - 1] / work[j4 - 2]);
-                    d *= work[j4 + 1] / work[j4 - 2];
                   }
                   dMin = Math.min(dMin, d);
                   eMin = Math.min(eMin, work[j4]);
  @@ -1382,9 +1375,8 @@
  work[j4 - 2] = dN2 + work[j4p2];
  if (work[j4 - 2] == 0.0) {
  work[j4] = 0.0;
-            dN1  = work[j4p2 + 2];

*     	cachedVt = null;
           dMin = dN1;

-            eMin = 0.0;
           } else if ((MathUtils.SAFE_MIN * work[j4p2 + 2] < work[j4 - 2]) &&
                      (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4p2 + 2])) {
               final double tmp = work[j4p2 + 2] / work[j4 - 2];
  @@ -1403,7 +1395,6 @@
  if (work[j4 - 2] == 0.0) {
  work[j4] = 0.0;
  dN = work[j4p2 + 2];
-            dMin = dN;
               eMin = 0.0;
           } else if ((MathUtils.SAFE_MIN * work[j4p2 + 2] < work[j4 - 2]) &&
                      (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4p2 + 2])) {
  @@ -1505,7 +1496,6 @@
  if(b2 == 0.0) {
  break;
  }
-                        b1 = b2;
                           if (work[i4]  >  work[i4 - 2]) {
                               return;
                           }
  2023-08-15 22:56:47 [main] [INFO] PatchLogExporter - patch (v7302)
  --- org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic
  +++ org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic
  @@ -173,4 +173,3 @@
  return test(values, begin, length);
  }
  }
- 2023-08-15 22:56:47 [main] [INFO] PatchLogExporter - patch (v7302)
  --- org.apache.commons.math.optimization.fitting.WeightedObservedPoint
  +++ org.apache.commons.math.optimization.fitting.WeightedObservedPoint
  @@ -72,4 +72,3 @@
  }
  }
- 2023-08-15 22:56:47 [main] [INFO] PatchLogExporter - patch (v7302)
  --- org.apache.commons.math.linear.BigMatrix
  +++ org.apache.commons.math.linear.BigMatrix
  @@ -328,4 +328,3 @@
  \*/
  BigMatrix solve(BigMatrix b) throws IllegalArgumentException, InvalidMatrixException;
  }
- 2023-08-15 22:56:47 [main] [INFO] PatchLogExporter - patch (v7750)
  --- org.apache.commons.math.linear.ArrayRealVector
  +++ org.apache.commons.math.linear.ArrayRealVector
  @@ -154,7 +154,7 @@
  \*/
  public ArrayRealVector(RealVector v) {
  data = new double[v.getDimension()];
-        for (int i = 0; i < data.length; ++i) {

*        for (int i = 0;; ++i) {
               data[i] = v.getEntry(i);
           }
       }
  2023-08-15 22:56:47 [main] [INFO] PatchLogExporter - patch (v7750)
  --- org.apache.commons.math.linear.EigenDecompositionImpl
  +++ org.apache.commons.math.linear.EigenDecompositionImpl
  @@ -868,7 +868,6 @@
  i0 = 0;
  for (int i = 4 \* (n0 - 2); i >= 0; i -= 4) {
  if (work[i + 2] <= 0) {

-                    i0 = 1 + i / 4;
                       break;
                   }
                   if (diagMin >= 4 * offDiagMax) {
  @@ -942,6 +941,14 @@
  for (int i = 4 _ (n - 2) + pingPong; i >= 0; i -= 4) {
  if (work[i + 2] <= TOLERANCE_2 _ d) {
  work[i + 2] = -0.0;

*     			{
*     				work[i + 2] = -0.0;
*     				d = work[i];
*     			}
*     			{
*     				work[i + 2] = -0.0;
*     				d = work[i];
*     			}
                       d = work[i];
                   } else {
                       d *= work[i] / (d + work[i + 2]);
  @@ -954,7 +961,6 @@
  final int j = i - 2 _ pingPong - 1;
  work[j] = d + work[i];
  if (work[i] <= TOLERANCE_2 _ d) {

-                    work[i]     = -0.0;
                       work[j]     = d;
                       work[j + 2] = 0.0;
                       d = work[i + 2];
  @@ -1053,9 +1059,6 @@
  if ((dMin <= 0) || (deflatedEnd < end)) {
  if (flipIfWarranted(deflatedEnd, 1)) {
  dMin2 = Math.min(dMin2, work[l - 1]);
-                work[l - 1] =
-                    Math.min(work[l - 1],
-                             Math.min(work[3 + pingPong], work[7 + pingPong]));
                   work[l - 2 * pingPong] =
                       Math.min(work[l - 2 * pingPong],
                                Math.min(work[6 + pingPong], work[6 + pingPong]));
  @@ -1106,7 +1109,6 @@
  tType -= 12;
  }
  } else if (Double.isNaN(dMin)) {
-                    tau = 0.0;
                   } else {
                       // possible underflow. Play it safe.
                       loop = false;
  @@ -1136,7 +1138,7 @@
  for (int i = 0; i < j; i += 4) {
  for (int k = 0; k < 4; k += step) {
  final double tmp = work[i + k];
-                    work[i + k] = work[j - k];

*                    double sum = 0;
                       work[j - k] = tmp;
                   }
                   j -= 4;
  @@ -1347,7 +1349,6 @@
  d _= tmp;
  } else {
  work[j4] = work[j4 + 1] _ (work[j4 - 1] / work[j4 - 2]);

-                    d *= work[j4 + 1] / work[j4 - 2];
                   }
                   dMin = Math.min(dMin, d);
                   eMin = Math.min(eMin, work[j4]);
  @@ -1381,10 +1382,10 @@
  int j4p2 = j4 + 2 \* pingPong - 1;
  work[j4 - 2] = dN2 + work[j4p2];
  if (work[j4 - 2] == 0.0) {
-            work[j4] = 0.0;

*            cachedVt = null;
*     	cachedVt = null;
           dN1  = work[j4p2 + 2];
           dMin = dN1;

-            eMin = 0.0;
           } else if ((MathUtils.SAFE_MIN * work[j4p2 + 2] < work[j4 - 2]) &&
                      (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4p2 + 2])) {
               final double tmp = work[j4p2 + 2] / work[j4 - 2];
  @@ -1402,6 +1403,7 @@
  work[j4 - 2] = dN1 + work[j4p2];
  if (work[j4 - 2] == 0.0) {
  work[j4] = 0.0;

*     	cachedVt = null;
               dN   = work[j4p2 + 2];
               dMin = dN;
               eMin = 0.0;
  2023-08-15 22:56:47 [main] [INFO] PatchLogExporter - patch (v7750)
  --- org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic
  +++ org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic
  @@ -173,4 +173,3 @@
  return test(values, begin, length);
  }
  }

- 2023-08-15 22:56:47 [main] [INFO] PatchLogExporter - patch (v7750)
  --- org.apache.commons.math.optimization.fitting.WeightedObservedPoint
  +++ org.apache.commons.math.optimization.fitting.WeightedObservedPoint
  @@ -72,4 +72,3 @@
  }
  }
- 2023-08-15 22:56:47 [main] [INFO] PatchLogExporter - patch (v7750)
  --- org.apache.commons.math.linear.BigMatrix
  +++ org.apache.commons.math.linear.BigMatrix
  @@ -328,4 +328,3 @@
  \*/
  BigMatrix solve(BigMatrix b) throws IllegalArgumentException, InvalidMatrixException;
  }
- 2023-08-15 22:56:47 [main] [INFO] PatchLogExporter - patch (v7946)
  --- org.apache.commons.math.linear.ArrayRealVector
  +++ org.apache.commons.math.linear.ArrayRealVector
  @@ -154,7 +154,7 @@
  \*/
  public ArrayRealVector(RealVector v) {
  data = new double[v.getDimension()];
-        for (int i = 0; i < data.length; ++i) {

*        for (int i = 0;; ++i) {
               data[i] = v.getEntry(i);
           }
       }
  2023-08-15 22:56:47 [main] [INFO] PatchLogExporter - patch (v7946)
  --- org.apache.commons.math.linear.EigenDecompositionImpl
  +++ org.apache.commons.math.linear.EigenDecompositionImpl
  @@ -868,7 +868,6 @@
  i0 = 0;
  for (int i = 4 \* (n0 - 2); i >= 0; i -= 4) {
  if (work[i + 2] <= 0) {

-                    i0 = 1 + i / 4;
                       break;
                   }
                   if (diagMin >= 4 * offDiagMax) {
  @@ -942,6 +941,10 @@
  for (int i = 4 _ (n - 2) + pingPong; i >= 0; i -= 4) {
  if (work[i + 2] <= TOLERANCE_2 _ d) {
  work[i + 2] = -0.0;

*     			{
*     				work[i + 2] = -0.0;
*     				d = work[i];
*     			}
                       d = work[i];
                   } else {
                       d *= work[i] / (d + work[i + 2]);
  @@ -954,10 +957,9 @@
  final int j = i - 2 _ pingPong - 1;
  work[j] = d + work[i];
  if (work[i] <= TOLERANCE_2 _ d) {

-                    work[i]     = -0.0;
                     work[j]     = d;
-                    work[j + 2] = 0.0;
                     d = work[i + 2];

*     			Arrays.sort(realEigenvalues);
                   } else if ((MathUtils.SAFE_MIN * work[i + 2] < work[j]) &&
                              (MathUtils.SAFE_MIN * work[j] < work[i + 2])) {
                       final double tmp = work[i + 2] / work[j];
  @@ -990,8 +992,6 @@
  \*/
  private int goodStep(final int start, final int end) {

-        g = 0.0;
-          // step 1: accepting realEigenvalues
           int deflatedEnd = end;
           for (boolean deflating = true; deflating;) {
  @@ -1053,9 +1053,6 @@
  if ((dMin <= 0) || (deflatedEnd < end)) {
  if (flipIfWarranted(deflatedEnd, 1)) {
  dMin2 = Math.min(dMin2, work[l - 1]);
-                work[l - 1] =
-                    Math.min(work[l - 1],
-                             Math.min(work[3 + pingPong], work[7 + pingPong]));
                   work[l - 2 * pingPong] =
                       Math.min(work[l - 2 * pingPong],
                                Math.min(work[6 + pingPong], work[6 + pingPong]));
  @@ -1136,12 +1133,9 @@
  for (int i = 0; i < j; i += 4) {
  for (int k = 0; k < 4; k += step) {
  final double tmp = work[i + k];
-                    work[i + k] = work[j - k];
-                    work[j - k] = tmp;

*                    double sum = 0;
                 }

-                j -= 4;
             }
-            return true;
           }
           return false;
       }
  @@ -1358,7 +1352,6 @@
  if (work[j4 - 3] == 0.0) {
  work[j4 - 1] = 0.0;
  d = work[j4 + 2];
-                    dMin = d;
                       eMin = 0.0;
                   } else if ((MathUtils.SAFE_MIN * work[j4 + 2] < work[j4 - 3]) &&
                              (MathUtils.SAFE_MIN * work[j4 - 3] < work[j4 + 2])) {
  @@ -1384,7 +1377,6 @@
  work[j4] = 0.0;
  dN1 = work[j4p2 + 2];
  dMin = dN1;
-            eMin = 0.0;
           } else if ((MathUtils.SAFE_MIN * work[j4p2 + 2] < work[j4 - 2]) &&
                      (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4p2 + 2])) {
               final double tmp = work[j4p2 + 2] / work[j4 - 2];
  @@ -1403,7 +1395,6 @@
  if (work[j4 - 2] == 0.0) {
  work[j4] = 0.0;
  dN = work[j4p2 + 2];
-            dMin = dN;
               eMin = 0.0;
           } else if ((MathUtils.SAFE_MIN * work[j4p2 + 2] < work[j4 - 2]) &&
                      (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4p2 + 2])) {
  2023-08-15 22:56:47 [main] [INFO] PatchLogExporter - patch (v7946)
  --- org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic
  +++ org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic
  @@ -173,4 +173,3 @@
  return test(values, begin, length);
  }
  }
- 2023-08-15 22:56:47 [main] [INFO] PatchLogExporter - patch (v7946)
  --- org.apache.commons.math.optimization.fitting.WeightedObservedPoint
  +++ org.apache.commons.math.optimization.fitting.WeightedObservedPoint
  @@ -72,4 +72,3 @@
  }
  }
- 2023-08-15 22:56:47 [main] [INFO] PatchLogExporter - patch (v7946)
  --- org.apache.commons.math.linear.BigMatrix
  +++ org.apache.commons.math.linear.BigMatrix
  @@ -328,4 +328,3 @@
  \*/
  BigMatrix solve(BigMatrix b) throws IllegalArgumentException, InvalidMatrixException;
  }
- 2023-08-15 22:56:47 [main] [INFO] PatchLogExporter - patch (v8022)
  --- org.apache.commons.math.linear.EigenDecompositionImpl
  +++ org.apache.commons.math.linear.EigenDecompositionImpl
  @@ -869,7 +869,6 @@
  for (int i = 4 \* (n0 - 2); i >= 0; i -= 4) {
  if (work[i + 2] <= 0) {
  i0 = 1 + i / 4;
-                    break;
                   }
                   if (diagMin >= 4 * offDiagMax) {
                       diagMin    = Math.min(diagMin, work[i + 4]);
  @@ -941,7 +940,6 @@
  double d = work[4 * (n - 1) + pingPong];
  for (int i = 4 _ (n - 2) + pingPong; i >= 0; i -= 4) {
  if (work[i + 2] <= TOLERANCE_2 _ d) {
-                    work[i + 2] = -0.0;
                       d = work[i];
                   } else {
                       d *= work[i] / (d + work[i + 2]);
  @@ -954,7 +952,6 @@
  final int j = i - 2 _ pingPong - 1;
  work[j] = d + work[i];
  if (work[i] <= TOLERANCE_2 _ d) {
-                    work[i]     = -0.0;
                       work[j]     = d;
                       work[j + 2] = 0.0;
                       d = work[i + 2];
  @@ -1053,9 +1050,6 @@
  if ((dMin <= 0) || (deflatedEnd < end)) {
  if (flipIfWarranted(deflatedEnd, 1)) {
  dMin2 = Math.min(dMin2, work[l - 1]);
-                work[l - 1] =
-                    Math.min(work[l - 1],
-                             Math.min(work[3 + pingPong], work[7 + pingPong]));
                   work[l - 2 * pingPong] =
                       Math.min(work[l - 2 * pingPong],
                                Math.min(work[6 + pingPong], work[6 + pingPong]));
  @@ -1136,7 +1130,7 @@
  for (int i = 0; i < j; i += 4) {
  for (int k = 0; k < 4; k += step) {
  final double tmp = work[i + k];
-                    work[i + k] = work[j - k];

*                    double sum = 0;
                       work[j - k] = tmp;
                   }
                   j -= 4;
  @@ -1338,7 +1332,6 @@
  if (work[j4 - 2] == 0.0) {
  work[j4] = 0.0;
  d = work[j4 + 1];

-                    dMin = d;
                       eMin = 0.0;
                   } else if ((MathUtils.SAFE_MIN * work[j4 + 1] < work[j4 - 2]) &&
                              (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4 + 1])) {
  @@ -1347,7 +1340,6 @@
  d _= tmp;
  } else {
  work[j4] = work[j4 + 1] _ (work[j4 - 1] / work[j4 - 2]);
-                    d *= work[j4 + 1] / work[j4 - 2];
                   }
                   dMin = Math.min(dMin, d);
                   eMin = Math.min(eMin, work[j4]);
  @@ -1358,7 +1350,6 @@
  if (work[j4 - 3] == 0.0) {
  work[j4 - 1] = 0.0;
  d = work[j4 + 2];
-                    dMin = d;
                       eMin = 0.0;
                   } else if ((MathUtils.SAFE_MIN * work[j4 + 2] < work[j4 - 3]) &&
                              (MathUtils.SAFE_MIN * work[j4 - 3] < work[j4 + 2])) {
  @@ -1382,9 +1373,10 @@
  work[j4 - 2] = dN2 + work[j4p2];
  if (work[j4 - 2] == 0.0) {
  work[j4] = 0.0;

*     	cachedVt = null;
*     	cachedVt = null;
           dN1  = work[j4p2 + 2];
           dMin = dN1;

-            eMin = 0.0;
           } else if ((MathUtils.SAFE_MIN * work[j4p2 + 2] < work[j4 - 2]) &&
                      (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4p2 + 2])) {
               final double tmp = work[j4p2 + 2] / work[j4 - 2];
  @@ -1402,9 +1394,9 @@
  work[j4 - 2] = dN1 + work[j4p2];
  if (work[j4 - 2] == 0.0) {
  work[j4] = 0.0;
-            dN   = work[j4p2 + 2];
-            dMin = dN;
-            eMin = 0.0;

*            double sum = 0;
*     	dN   = work[j4p2 + 2];
*            int k = 0;
           } else if ((MathUtils.SAFE_MIN * work[j4p2 + 2] < work[j4 - 2]) &&
                      (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4p2 + 2])) {
               final double tmp = work[j4p2 + 2] / work[j4 - 2];
  2023-08-15 22:56:47 [main] [INFO] PatchLogExporter - patch (v8022)
  --- org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic
  +++ org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic
  @@ -173,4 +173,3 @@
  return test(values, begin, length);
  }
  }

- 2023-08-15 22:56:47 [main] [INFO] PatchLogExporter - patch (v8022)
  --- org.apache.commons.math.optimization.fitting.WeightedObservedPoint
  +++ org.apache.commons.math.optimization.fitting.WeightedObservedPoint
  @@ -72,4 +72,3 @@
  }
  }
- 2023-08-15 22:56:47 [main] [INFO] PatchLogExporter - patch (v8022)
  --- org.apache.commons.math.linear.BigMatrix
  +++ org.apache.commons.math.linear.BigMatrix
  @@ -328,4 +328,3 @@
  \*/
  BigMatrix solve(BigMatrix b) throws IllegalArgumentException, InvalidMatrixException;
  }
- 2023-08-15 22:56:47 [main] [INFO] PatchLogExporter - patch (v8329)
  --- org.apache.commons.math.linear.EigenDecompositionImpl
  +++ org.apache.commons.math.linear.EigenDecompositionImpl
  @@ -869,7 +869,6 @@
  for (int i = 4 \* (n0 - 2); i >= 0; i -= 4) {
  if (work[i + 2] <= 0) {
  i0 = 1 + i / 4;
-                    break;
                   }
                   if (diagMin >= 4 * offDiagMax) {
                       diagMin    = Math.min(diagMin, work[i + 4]);
  @@ -941,8 +940,6 @@
  double d = work[4 * (n - 1) + pingPong];
  for (int i = 4 _ (n - 2) + pingPong; i >= 0; i -= 4) {
  if (work[i + 2] <= TOLERANCE_2 _ d) {
-                    work[i + 2] = -0.0;
-                    d = work[i];
                   } else {
                       d *= work[i] / (d + work[i + 2]);
                   }
  @@ -956,7 +953,6 @@
  if (work[i] <= TOLERANCE_2 \* d) {
  work[i] = -0.0;
  work[j] = d;
-                    work[j + 2] = 0.0;
                       d = work[i + 2];
                   } else if ((MathUtils.SAFE_MIN * work[i + 2] < work[j]) &&
                              (MathUtils.SAFE_MIN * work[j] < work[i + 2])) {
  @@ -1019,7 +1015,6 @@
  // two realEigenvalues found, deflate array
  if (work[k - 3] > work[k - 7]) {
  final double tmp = work[k - 3];
-                    work[k - 3] = work[k - 7];
                     work[k - 7] = tmp;
                 }

@@ -1053,9 +1048,6 @@
if ((dMin <= 0) || (deflatedEnd < end)) {
if (flipIfWarranted(deflatedEnd, 1)) {
dMin2 = Math.min(dMin2, work[l - 1]);

-                work[l - 1] =
-                    Math.min(work[l - 1],
-                             Math.min(work[3 + pingPong], work[7 + pingPong]));
                   work[l - 2 * pingPong] =
                       Math.min(work[l - 2 * pingPong],
                                Math.min(work[6 + pingPong], work[6 + pingPong]));
  @@ -1136,10 +1128,8 @@
  for (int i = 0; i < j; i += 4) {
  for (int k = 0; k < 4; k += step) {
  final double tmp = work[i + k];
-                    work[i + k] = work[j - k];
                     work[j - k] = tmp;
                 }
-                j -= 4;
               }
               return true;
           }
  @@ -1338,7 +1328,6 @@
  if (work[j4 - 2] == 0.0) {
  work[j4] = 0.0;
  d = work[j4 + 1];
-                    dMin = d;
                       eMin = 0.0;
                   } else if ((MathUtils.SAFE_MIN * work[j4 + 1] < work[j4 - 2]) &&
                              (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4 + 1])) {
  @@ -1347,7 +1336,6 @@
  d _= tmp;
  } else {
  work[j4] = work[j4 + 1] _ (work[j4 - 1] / work[j4 - 2]);
-                    d *= work[j4 + 1] / work[j4 - 2];
                   }
                   dMin = Math.min(dMin, d);
                   eMin = Math.min(eMin, work[j4]);
  @@ -1381,10 +1369,9 @@
  int j4p2 = j4 + 2 \* pingPong - 1;
  work[j4 - 2] = dN2 + work[j4p2];
  if (work[j4 - 2] == 0.0) {
-            work[j4] = 0.0;

*            cachedVt = null;
             dN1  = work[j4p2 + 2];
             dMin = dN1;

-            eMin = 0.0;
           } else if ((MathUtils.SAFE_MIN * work[j4p2 + 2] < work[j4 - 2]) &&
                      (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4p2 + 2])) {
               final double tmp = work[j4p2 + 2] / work[j4 - 2];
  @@ -1403,8 +1390,6 @@
  if (work[j4 - 2] == 0.0) {
  work[j4] = 0.0;
  dN = work[j4p2 + 2];
-            dMin = dN;
-            eMin = 0.0;
           } else if ((MathUtils.SAFE_MIN * work[j4p2 + 2] < work[j4 - 2]) &&
                      (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4p2 + 2])) {
               final double tmp = work[j4p2 + 2] / work[j4 - 2];
  @@ -1536,7 +1521,6 @@
  double b2 = work[np - 6];
  final double gam = dN2;
  if (work[np - 8] > b2 || work[np - 4] > b1) {
-                    return;
                 }
                 double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1);

2023-08-15 22:56:47 [main] [INFO] PatchLogExporter - patch (v8329)
--- org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic
+++ org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic
@@ -173,4 +173,3 @@
return test(values, begin, length);
}
}

- 2023-08-15 22:56:47 [main] [INFO] PatchLogExporter - patch (v8329)
  --- org.apache.commons.math.optimization.fitting.WeightedObservedPoint
  +++ org.apache.commons.math.optimization.fitting.WeightedObservedPoint
  @@ -72,4 +72,3 @@
  }
  }
- 2023-08-15 22:56:47 [main] [INFO] PatchLogExporter - patch (v8329)
  --- org.apache.commons.math.linear.BigMatrix
  +++ org.apache.commons.math.linear.BigMatrix
  @@ -328,4 +328,3 @@
  \*/
  BigMatrix solve(BigMatrix b) throws IllegalArgumentException, InvalidMatrixException;
  }
- 2023-08-15 22:56:47 [main] [INFO] PatchLogExporter - patch (v8592)
  --- org.apache.commons.math.linear.Array2DRowRealMatrix
  +++ org.apache.commons.math.linear.Array2DRowRealMatrix
  @@ -328,7 +328,7 @@
  }
               final int nCols = subMatrix[0].length;
-            if (nCols == 0) {

*            if (this.isSingular()) {
                   throw MathRuntimeException.createIllegalArgumentException("matrix must have at least one column");
               }
               data = new double[subMatrix.length][nCols];
  2023-08-15 22:56:47 [main] [INFO] PatchLogExporter - patch (v8592)
  --- org.apache.commons.math.linear.ArrayRealVector
  +++ org.apache.commons.math.linear.ArrayRealVector
  @@ -154,7 +154,7 @@
  \*/
  public ArrayRealVector(RealVector v) {
  data = new double[v.getDimension()];

-        for (int i = 0; i < data.length; ++i) {

*        for (int i = 0;; ++i) {
               data[i] = v.getEntry(i);
           }
       }
  2023-08-15 22:56:47 [main] [INFO] PatchLogExporter - patch (v8592)
  --- org.apache.commons.math.linear.EigenDecompositionImpl
  +++ org.apache.commons.math.linear.EigenDecompositionImpl
  @@ -868,7 +868,6 @@
  i0 = 0;
  for (int i = 4 \* (n0 - 2); i >= 0; i -= 4) {
  if (work[i + 2] <= 0) {

-                    i0 = 1 + i / 4;
                       break;
                   }
                   if (diagMin >= 4 * offDiagMax) {
  @@ -942,7 +941,14 @@
  for (int i = 4 _ (n - 2) + pingPong; i >= 0; i -= 4) {
  if (work[i + 2] <= TOLERANCE_2 _ d) {
  work[i + 2] = -0.0;
-                    d = work[i];

*     			{
*     				work[i + 2] = -0.0;
*     				d = work[i];
*     			}
*     			{
*     				work[i + 2] = -0.0;
*     				d = work[i];
*     			}
                   } else {
                       d *= work[i] / (d + work[i + 2]);
                   }
  @@ -958,6 +964,7 @@
  work[j] = d;
  work[j + 2] = 0.0;
  d = work[i + 2];
*     			Arrays.sort(realEigenvalues);
                   } else if ((MathUtils.SAFE_MIN * work[i + 2] < work[j]) &&
                              (MathUtils.SAFE_MIN * work[j] < work[i + 2])) {
                       final double tmp = work[i + 2] / work[j];
  @@ -1136,10 +1143,9 @@
  for (int i = 0; i < j; i += 4) {
  for (int k = 0; k < 4; k += step) {
  final double tmp = work[i + k];

-                    work[i + k] = work[j - k];

*                    double sum = 0;
                     work[j - k] = tmp;
                 }

-                j -= 4;
               }
               return true;
           }
  @@ -1180,8 +1186,6 @@
  final double range = right - left;
  if ((range < absoluteTolerance) ||
  (range < relativeTolerance \* Math.max(Math.abs(left), Math.abs(right)))) {
-                // search has converged
-                break;
               }

               final double middle = 0.5 * (left + right);
  @@ -1338,7 +1342,6 @@
  if (work[j4 - 2] == 0.0) {
  work[j4] = 0.0;
  d = work[j4 + 1];
-                    dMin = d;
                       eMin = 0.0;
                   } else if ((MathUtils.SAFE_MIN * work[j4 + 1] < work[j4 - 2]) &&
                              (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4 + 1])) {
  @@ -1358,7 +1361,6 @@
  if (work[j4 - 3] == 0.0) {
  work[j4 - 1] = 0.0;
  d = work[j4 + 2];
-                    dMin = d;
                       eMin = 0.0;
                   } else if ((MathUtils.SAFE_MIN * work[j4 + 2] < work[j4 - 3]) &&
                              (MathUtils.SAFE_MIN * work[j4 - 3] < work[j4 + 2])) {
  @@ -1384,7 +1386,6 @@
  work[j4] = 0.0;
  dN1 = work[j4p2 + 2];
  dMin = dN1;
-            eMin = 0.0;
           } else if ((MathUtils.SAFE_MIN * work[j4p2 + 2] < work[j4 - 2]) &&
                      (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4p2 + 2])) {
               final double tmp = work[j4p2 + 2] / work[j4 - 2];
  @@ -1403,7 +1404,6 @@
  if (work[j4 - 2] == 0.0) {
  work[j4] = 0.0;
  dN = work[j4p2 + 2];
-            dMin = dN;
               eMin = 0.0;
           } else if ((MathUtils.SAFE_MIN * work[j4p2 + 2] < work[j4 - 2]) &&
                      (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4p2 + 2])) {
  2023-08-15 22:56:47 [main] [INFO] PatchLogExporter - patch (v8592)
  --- org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic
  +++ org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic
  @@ -173,4 +173,3 @@
  return test(values, begin, length);
  }
  }
- 2023-08-15 22:56:47 [main] [INFO] PatchLogExporter - patch (v8592)
  --- org.apache.commons.math.optimization.fitting.WeightedObservedPoint
  +++ org.apache.commons.math.optimization.fitting.WeightedObservedPoint
  @@ -72,4 +72,3 @@
  }
  }
- 2023-08-15 22:56:47 [main] [INFO] PatchLogExporter - patch (v8592)
  --- org.apache.commons.math.linear.BigMatrix
  +++ org.apache.commons.math.linear.BigMatrix
  @@ -328,4 +328,3 @@
  \*/
  BigMatrix solve(BigMatrix b) throws IllegalArgumentException, InvalidMatrixException;
  }
- 2023-08-15 22:56:47 [main] [INFO] PatchLogExporter - patch (v8611)
  --- org.apache.commons.math.linear.ArrayRealVector
  +++ org.apache.commons.math.linear.ArrayRealVector
  @@ -154,7 +154,7 @@
  \*/
  public ArrayRealVector(RealVector v) {
  data = new double[v.getDimension()];
-        for (int i = 0; i < data.length; ++i) {

*        for (int i = 0;; ++i) {
               data[i] = v.getEntry(i);
           }
       }
  2023-08-15 22:56:47 [main] [INFO] PatchLogExporter - patch (v8611)
  --- org.apache.commons.math.linear.EigenDecompositionImpl
  +++ org.apache.commons.math.linear.EigenDecompositionImpl
  @@ -868,7 +868,6 @@
  i0 = 0;
  for (int i = 4 \* (n0 - 2); i >= 0; i -= 4) {
  if (work[i + 2] <= 0) {

-                    i0 = 1 + i / 4;
                       break;
                   }
                   if (diagMin >= 4 * offDiagMax) {
  @@ -942,6 +941,14 @@
  for (int i = 4 _ (n - 2) + pingPong; i >= 0; i -= 4) {
  if (work[i + 2] <= TOLERANCE_2 _ d) {
  work[i + 2] = -0.0;

*     			{
*     				work[i + 2] = -0.0;
*     				d = work[i];
*     			}
*     			{
*     				work[i + 2] = -0.0;
*     				d = work[i];
*     			}
                       d = work[i];
                   } else {
                       d *= work[i] / (d + work[i + 2]);
  @@ -956,8 +963,9 @@
  if (work[i] <= TOLERANCE_2 \* d) {
  work[i] = -0.0;
  work[j] = d;

-                    work[j + 2] = 0.0;
                     d = work[i + 2];

*     			Arrays.sort(realEigenvalues);
*     			Arrays.sort(realEigenvalues);
                   } else if ((MathUtils.SAFE_MIN * work[i + 2] < work[j]) &&
                              (MathUtils.SAFE_MIN * work[j] < work[i + 2])) {
                       final double tmp = work[i + 2] / work[j];
  @@ -990,8 +998,6 @@
  \*/
  private int goodStep(final int start, final int end) {

-        g = 0.0;
-          // step 1: accepting realEigenvalues
           int deflatedEnd = end;
           for (boolean deflating = true; deflating;) {
  @@ -1053,9 +1059,6 @@
  if ((dMin <= 0) || (deflatedEnd < end)) {
  if (flipIfWarranted(deflatedEnd, 1)) {
  dMin2 = Math.min(dMin2, work[l - 1]);
-                work[l - 1] =
-                    Math.min(work[l - 1],
-                             Math.min(work[3 + pingPong], work[7 + pingPong]));
                   work[l - 2 * pingPong] =
                       Math.min(work[l - 2 * pingPong],
                                Math.min(work[6 + pingPong], work[6 + pingPong]));
  @@ -1136,7 +1139,6 @@
  for (int i = 0; i < j; i += 4) {
  for (int k = 0; k < 4; k += step) {
  final double tmp = work[i + k];
-                    work[i + k] = work[j - k];
                       work[j - k] = tmp;
                   }
                   j -= 4;
  @@ -1338,7 +1340,6 @@
  if (work[j4 - 2] == 0.0) {
  work[j4] = 0.0;
  d = work[j4 + 1];
-                    dMin = d;
                       eMin = 0.0;
                   } else if ((MathUtils.SAFE_MIN * work[j4 + 1] < work[j4 - 2]) &&
                              (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4 + 1])) {
  @@ -1381,10 +1382,9 @@
  int j4p2 = j4 + 2 \* pingPong - 1;
  work[j4 - 2] = dN2 + work[j4p2];
  if (work[j4 - 2] == 0.0) {
-            work[j4] = 0.0;

*            cachedVt = null;
             dN1  = work[j4p2 + 2];
             dMin = dN1;

-            eMin = 0.0;
           } else if ((MathUtils.SAFE_MIN * work[j4p2 + 2] < work[j4 - 2]) &&
                      (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4p2 + 2])) {
               final double tmp = work[j4p2 + 2] / work[j4 - 2];
  @@ -1403,7 +1403,6 @@
  if (work[j4 - 2] == 0.0) {
  work[j4] = 0.0;
  dN = work[j4p2 + 2];
-            dMin = dN;
               eMin = 0.0;
           } else if ((MathUtils.SAFE_MIN * work[j4p2 + 2] < work[j4 - 2]) &&
                      (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4p2 + 2])) {
  2023-08-15 22:56:47 [main] [INFO] PatchLogExporter - patch (v8611)
  --- org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic
  +++ org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic
  @@ -173,4 +173,3 @@
  return test(values, begin, length);
  }
  }
- 2023-08-15 22:56:47 [main] [INFO] PatchLogExporter - patch (v8611)
  --- org.apache.commons.math.optimization.fitting.WeightedObservedPoint
  +++ org.apache.commons.math.optimization.fitting.WeightedObservedPoint
  @@ -72,4 +72,3 @@
  }
  }
- 2023-08-15 22:56:47 [main] [INFO] PatchLogExporter - patch (v8611)
  --- org.apache.commons.math.linear.BigMatrix
  +++ org.apache.commons.math.linear.BigMatrix
  @@ -328,4 +328,3 @@
  \*/
  BigMatrix solve(BigMatrix b) throws IllegalArgumentException, InvalidMatrixException;
  }
- 2023-08-15 22:56:47 [main] [INFO] PatchLogExporter - patch (v8900)
  --- org.apache.commons.math.linear.Array2DRowRealMatrix
  +++ org.apache.commons.math.linear.Array2DRowRealMatrix
  @@ -328,7 +328,7 @@
  }
               final int nCols = subMatrix[0].length;
-            if (nCols == 0) {

*            if (this.isSingular()) {
                   throw MathRuntimeException.createIllegalArgumentException("matrix must have at least one column");
               }
               data = new double[subMatrix.length][nCols];
  2023-08-15 22:56:47 [main] [INFO] PatchLogExporter - patch (v8900)
  --- org.apache.commons.math.linear.EigenDecompositionImpl
  +++ org.apache.commons.math.linear.EigenDecompositionImpl
  @@ -869,7 +869,6 @@
  for (int i = 4 \* (n0 - 2); i >= 0; i -= 4) {
  if (work[i + 2] <= 0) {
  i0 = 1 + i / 4;

-                    break;
                   }
                   if (diagMin >= 4 * offDiagMax) {
                       diagMin    = Math.min(diagMin, work[i + 4]);
  @@ -942,7 +941,6 @@
  for (int i = 4 _ (n - 2) + pingPong; i >= 0; i -= 4) {
  if (work[i + 2] <= TOLERANCE_2 _ d) {
  work[i + 2] = -0.0;
-                    d = work[i];
                   } else {
                       d *= work[i] / (d + work[i + 2]);
                   }
  @@ -954,10 +952,12 @@
  final int j = i - 2 _ pingPong - 1;
  work[j] = d + work[i];
  if (work[i] <= TOLERANCE_2 _ d) {
-                    work[i]     = -0.0;
                     work[j]     = d;
                     work[j + 2] = 0.0;
                     d = work[i + 2];

*     			Arrays.sort(realEigenvalues);
*     			Arrays.sort(realEigenvalues);
*     			Arrays.sort(realEigenvalues);
                   } else if ((MathUtils.SAFE_MIN * work[i + 2] < work[j]) &&
                              (MathUtils.SAFE_MIN * work[j] < work[i + 2])) {
                       final double tmp = work[i + 2] / work[j];
  @@ -990,8 +990,6 @@
  \*/
  private int goodStep(final int start, final int end) {

-        g = 0.0;
-          // step 1: accepting realEigenvalues
           int deflatedEnd = end;
           for (boolean deflating = true; deflating;) {
  @@ -1106,7 +1104,6 @@
  tType -= 12;
  }
  } else if (Double.isNaN(dMin)) {
-                    tau = 0.0;
                   } else {
                       // possible underflow. Play it safe.
                       loop = false;
  @@ -1136,10 +1133,9 @@
  for (int i = 0; i < j; i += 4) {
  for (int k = 0; k < 4; k += step) {
  final double tmp = work[i + k];
-                    work[i + k] = work[j - k];

*                    double sum = 0;
                     work[j - k] = tmp;
                 }

-                j -= 4;
               }
               return true;
           }
  @@ -1347,7 +1343,6 @@
  d _= tmp;
  } else {
  work[j4] = work[j4 + 1] _ (work[j4 - 1] / work[j4 - 2]);
-                    d *= work[j4 + 1] / work[j4 - 2];
                   }
                   dMin = Math.min(dMin, d);
                   eMin = Math.min(eMin, work[j4]);
  @@ -1358,7 +1353,6 @@
  if (work[j4 - 3] == 0.0) {
  work[j4 - 1] = 0.0;
  d = work[j4 + 2];
-                    dMin = d;
                       eMin = 0.0;
                   } else if ((MathUtils.SAFE_MIN * work[j4 + 2] < work[j4 - 3]) &&
                              (MathUtils.SAFE_MIN * work[j4 - 3] < work[j4 + 2])) {
  @@ -1367,7 +1361,6 @@
  d _= tmp;
  } else {
  work[j4 - 1] = work[j4 + 2] _ (work[j4] / work[j4 - 3]);
-                    d *= work[j4 + 2] / work[j4 - 3];
                   }
                   dMin = Math.min(dMin, d);
                   eMin = Math.min(eMin, work[j4 - 1]);
  @@ -1381,7 +1374,7 @@
  int j4p2 = j4 + 2 \* pingPong - 1;
  work[j4 - 2] = dN2 + work[j4p2];
  if (work[j4 - 2] == 0.0) {
-            work[j4] = 0.0;

*            cachedVt = null;
               dN1  = work[j4p2 + 2];
               dMin = dN1;
               eMin = 0.0;
  @@ -1402,7 +1395,8 @@
  work[j4 - 2] = dN1 + work[j4p2];
  if (work[j4 - 2] == 0.0) {
  work[j4] = 0.0;

-            dN   = work[j4p2 + 2];

*            double sum = 0;
*     	dN   = work[j4p2 + 2];
               dMin = dN;
               eMin = 0.0;
           } else if ((MathUtils.SAFE_MIN * work[j4p2 + 2] < work[j4 - 2]) &&
  2023-08-15 22:56:47 [main] [INFO] PatchLogExporter - patch (v8900)
  --- org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic
  +++ org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic
  @@ -173,4 +173,3 @@
  return test(values, begin, length);
  }
  }

- 2023-08-15 22:56:47 [main] [INFO] PatchLogExporter - patch (v8900)
  --- org.apache.commons.math.optimization.fitting.WeightedObservedPoint
  +++ org.apache.commons.math.optimization.fitting.WeightedObservedPoint
  @@ -72,4 +72,3 @@
  }
  }
- 2023-08-15 22:56:47 [main] [INFO] PatchLogExporter - patch (v8900)
  --- org.apache.commons.math.linear.BigMatrix
  +++ org.apache.commons.math.linear.BigMatrix
  @@ -328,4 +328,3 @@
  \*/
  BigMatrix solve(BigMatrix b) throws IllegalArgumentException, InvalidMatrixException;
  }
- 2023-08-15 22:56:47 [main] [INFO] PatchLogExporter - patch (v8949)
  --- org.apache.commons.math.linear.Array2DRowRealMatrix
  +++ org.apache.commons.math.linear.Array2DRowRealMatrix
  @@ -328,7 +328,7 @@
  }
               final int nCols = subMatrix[0].length;
-            if (nCols == 0) {

*            if (this.isSingular()) {
                   throw MathRuntimeException.createIllegalArgumentException("matrix must have at least one column");
               }
               data = new double[subMatrix.length][nCols];
  2023-08-15 22:56:47 [main] [INFO] PatchLogExporter - patch (v8949)
  --- org.apache.commons.math.linear.ArrayRealVector
  +++ org.apache.commons.math.linear.ArrayRealVector
  @@ -243,7 +243,6 @@
  /\*_ {@inheritDoc} _/
  public RealVector add(double[] v)
  throws IllegalArgumentException {

-        checkVectorDimensions(v.length);
           double[] out = new double[data.length];
           for (int i = 0; i < data.length; i++) {
               out[i] = data[i] + v[i];
  2023-08-15 22:56:47 [main] [INFO] PatchLogExporter - patch (v8949)
  --- org.apache.commons.math.linear.EigenDecompositionImpl
  +++ org.apache.commons.math.linear.EigenDecompositionImpl
  @@ -868,7 +868,6 @@
  i0 = 0;
  for (int i = 4 \* (n0 - 2); i >= 0; i -= 4) {
  if (work[i + 2] <= 0) {
-                    i0 = 1 + i / 4;
                       break;
                   }
                   if (diagMin >= 4 * offDiagMax) {
  @@ -942,7 +941,22 @@
  for (int i = 4 _ (n - 2) + pingPong; i >= 0; i -= 4) {
  if (work[i + 2] <= TOLERANCE_2 _ d) {
  work[i + 2] = -0.0;
-                    d = work[i];

*     			{
*     				work[i + 2] = -0.0;
*     				d = work[i];
*     			}
*     			{
*     				work[i + 2] = -0.0;
*     				d = work[i];
*     			}
*     			{
*     				work[i + 2] = -0.0;
*     				d = work[i];
*     			}
*     			{
*     				work[i + 2] = -0.0;
*     				d = work[i];
*     			}
                   } else {
                       d *= work[i] / (d + work[i + 2]);
                   }
  @@ -958,6 +972,8 @@
  work[j] = d;
  work[j + 2] = 0.0;
  d = work[i + 2];
*     			Arrays.sort(realEigenvalues);
*     			Arrays.sort(realEigenvalues);
                   } else if ((MathUtils.SAFE_MIN * work[i + 2] < work[j]) &&
                              (MathUtils.SAFE_MIN * work[j] < work[i + 2])) {
                       final double tmp = work[i + 2] / work[j];
  @@ -1134,7 +1150,7 @@
  // flip array
  int j = 4 \* n - 1;
  for (int i = 0; i < j; i += 4) {

-                for (int k = 0; k < 4; k += step) {

*                for (int k = 0; j < n; k += step) {
                       final double tmp = work[i + k];
                       work[i + k] = work[j - k];
                       work[j - k] = tmp;
  @@ -1347,7 +1363,6 @@
  d _= tmp;
  } else {
  work[j4] = work[j4 + 1] _ (work[j4 - 1] / work[j4 - 2]);

-                    d *= work[j4 + 1] / work[j4 - 2];
                   }
                   dMin = Math.min(dMin, d);
                   eMin = Math.min(eMin, work[j4]);
  @@ -1382,16 +1397,15 @@
  work[j4 - 2] = dN2 + work[j4p2];
  if (work[j4 - 2] == 0.0) {
  work[j4] = 0.0;

*     	cachedVt = null;
           dN1  = work[j4p2 + 2];
           dMin = dN1;

-            eMin = 0.0;
         } else if ((MathUtils.SAFE_MIN * work[j4p2 + 2] < work[j4 - 2]) &&
                    (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4p2 + 2])) {
             final double tmp = work[j4p2 + 2] / work[j4 - 2];
             work[j4] = work[j4p2] * tmp;
             dN1 = dN2 * tmp;
         } else {
-            work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]);
               dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);
           }
           dMin = Math.min(dMin, dN1);
  @@ -1402,8 +1416,8 @@
  work[j4 - 2] = dN1 + work[j4p2];
  if (work[j4 - 2] == 0.0) {
  work[j4] = 0.0;
-            dN   = work[j4p2 + 2];
-            dMin = dN;

*            double sum = 0;
*     	dN   = work[j4p2 + 2];
               eMin = 0.0;
           } else if ((MathUtils.SAFE_MIN * work[j4p2 + 2] < work[j4 - 2]) &&
                      (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4p2 + 2])) {
  2023-08-15 22:56:47 [main] [INFO] PatchLogExporter - patch (v8949)
  --- org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic
  +++ org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic
  @@ -173,4 +173,3 @@
  return test(values, begin, length);
  }
  }

- 2023-08-15 22:56:47 [main] [INFO] PatchLogExporter - patch (v8949)
  --- org.apache.commons.math.optimization.fitting.WeightedObservedPoint
  +++ org.apache.commons.math.optimization.fitting.WeightedObservedPoint
  @@ -72,4 +72,3 @@
  }
  }
- 2023-08-15 22:56:47 [main] [INFO] PatchLogExporter - patch (v8949)
  --- org.apache.commons.math.linear.BigMatrix
  +++ org.apache.commons.math.linear.BigMatrix
  @@ -328,4 +328,3 @@
  \*/
  BigMatrix solve(BigMatrix b) throws IllegalArgumentException, InvalidMatrixException;
  }
- 2023-08-15 22:56:47 [main] [INFO] PatchLogExporter - patch (v9135)
  --- org.apache.commons.math.linear.ArrayRealVector
  +++ org.apache.commons.math.linear.ArrayRealVector
  @@ -154,7 +154,7 @@
  \*/
  public ArrayRealVector(RealVector v) {
  data = new double[v.getDimension()];
-        for (int i = 0; i < data.length; ++i) {

*        for (int i = 0;; ++i) {
               data[i] = v.getEntry(i);
           }
       }
  @@ -904,7 +904,6 @@
  public double getNorm() {
  double sum = 0;
  for (double a : data) {

-            sum += a * a;
           }
           return Math.sqrt(sum);
       }
  2023-08-15 22:56:47 [main] [INFO] PatchLogExporter - patch (v9135)
  --- org.apache.commons.math.linear.EigenDecompositionImpl
  +++ org.apache.commons.math.linear.EigenDecompositionImpl
  @@ -844,7 +844,6 @@
           // initialize parameters used by goodStep
           tType = 0;
-        dMin1 = 0;
           dMin2 = 0;
           dN    = 0;
           dN1   = 0;
  @@ -868,8 +867,6 @@
  i0 = 0;
  for (int i = 4 \* (n0 - 2); i >= 0; i -= 4) {
  if (work[i + 2] <= 0) {
-                    i0 = 1 + i / 4;
-                    break;
                   }
                   if (diagMin >= 4 * offDiagMax) {
                       diagMin    = Math.min(diagMin, work[i + 4]);
  @@ -956,8 +953,8 @@
  if (work[i] <= TOLERANCE_2 \* d) {
  work[i] = -0.0;
  work[j] = d;
-                    work[j + 2] = 0.0;
                     d = work[i + 2];

*     			Arrays.sort(realEigenvalues);
                   } else if ((MathUtils.SAFE_MIN * work[i + 2] < work[j]) &&
                              (MathUtils.SAFE_MIN * work[j] < work[i + 2])) {
                       final double tmp = work[i + 2] / work[j];
  @@ -1053,9 +1050,6 @@
  if ((dMin <= 0) || (deflatedEnd < end)) {
  if (flipIfWarranted(deflatedEnd, 1)) {
  dMin2 = Math.min(dMin2, work[l - 1]);

-                work[l - 1] =
-                    Math.min(work[l - 1],
-                             Math.min(work[3 + pingPong], work[7 + pingPong]));
                   work[l - 2 * pingPong] =
                       Math.min(work[l - 2 * pingPong],
                                Math.min(work[6 + pingPong], work[6 + pingPong]));
  @@ -1133,15 +1127,8 @@
  if (1.5 _ work[pingPong] < work[4 _ (n - 1) + pingPong]) {
  // flip array
  int j = 4 \* n - 1;
-            for (int i = 0; i < j; i += 4) {
-                for (int k = 0; k < 4; k += step) {
-                    final double tmp = work[i + k];
-                    work[i + k] = work[j - k];
-                    work[j - k] = tmp;
-                }
-                j -= 4;
-            }
-            return true;

*            for (int i = 0; i < j; i += 4)
*     		return false;
           }
           return false;
       }
  @@ -1338,7 +1325,6 @@
  if (work[j4 - 2] == 0.0) {
  work[j4] = 0.0;
  d = work[j4 + 1];

-                    dMin = d;
                       eMin = 0.0;
                   } else if ((MathUtils.SAFE_MIN * work[j4 + 1] < work[j4 - 2]) &&
                              (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4 + 1])) {
  @@ -1347,7 +1333,6 @@
  d _= tmp;
  } else {
  work[j4] = work[j4 + 1] _ (work[j4 - 1] / work[j4 - 2]);
-                    d *= work[j4 + 1] / work[j4 - 2];
                   }
                   dMin = Math.min(dMin, d);
                   eMin = Math.min(eMin, work[j4]);
  @@ -1358,7 +1343,6 @@
  if (work[j4 - 3] == 0.0) {
  work[j4 - 1] = 0.0;
  d = work[j4 + 2];
-                    dMin = d;
                       eMin = 0.0;
                   } else if ((MathUtils.SAFE_MIN * work[j4 + 2] < work[j4 - 3]) &&
                              (MathUtils.SAFE_MIN * work[j4 - 3] < work[j4 + 2])) {
  @@ -1367,7 +1351,6 @@
  d _= tmp;
  } else {
  work[j4 - 1] = work[j4 + 2] _ (work[j4] / work[j4 - 3]);
-                    d *= work[j4 + 2] / work[j4 - 3];
                   }
                   dMin = Math.min(dMin, d);
                   eMin = Math.min(eMin, work[j4 - 1]);
  @@ -1381,10 +1364,8 @@
  int j4p2 = j4 + 2 \* pingPong - 1;
  work[j4 - 2] = dN2 + work[j4p2];
  if (work[j4 - 2] == 0.0) {
-            work[j4] = 0.0;
             dN1  = work[j4p2 + 2];
             dMin = dN1;
-            eMin = 0.0;
           } else if ((MathUtils.SAFE_MIN * work[j4p2 + 2] < work[j4 - 2]) &&
                      (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4p2 + 2])) {
               final double tmp = work[j4p2 + 2] / work[j4 - 2];
  @@ -1401,7 +1382,6 @@
  j4p2 = j4 + 2 \* pingPong - 1;
  work[j4 - 2] = dN1 + work[j4p2];
  if (work[j4 - 2] == 0.0) {
-            work[j4] = 0.0;
               dN   = work[j4p2 + 2];
               dMin = dN;
               eMin = 0.0;
  2023-08-15 22:56:47 [main] [INFO] PatchLogExporter - patch (v9135)
  --- org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic
  +++ org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic
  @@ -173,4 +173,3 @@
  return test(values, begin, length);
  }
  }
- 2023-08-15 22:56:47 [main] [INFO] PatchLogExporter - patch (v9135)
  --- org.apache.commons.math.optimization.fitting.WeightedObservedPoint
  +++ org.apache.commons.math.optimization.fitting.WeightedObservedPoint
  @@ -72,4 +72,3 @@
  }
  }
- 2023-08-15 22:56:47 [main] [INFO] PatchLogExporter - patch (v9135)
  --- org.apache.commons.math.linear.BigMatrix
  +++ org.apache.commons.math.linear.BigMatrix
  @@ -328,4 +328,3 @@
  \*/
  BigMatrix solve(BigMatrix b) throws IllegalArgumentException, InvalidMatrixException;
  }
- 2023-08-15 22:56:47 [main] [INFO] PatchLogExporter - patch (v9431)
  --- org.apache.commons.math.linear.Array2DRowRealMatrix
  +++ org.apache.commons.math.linear.Array2DRowRealMatrix
  @@ -328,7 +328,7 @@
  }
               final int nCols = subMatrix[0].length;
-            if (nCols == 0) {

*            if (this.isSingular()) {
                   throw MathRuntimeException.createIllegalArgumentException("matrix must have at least one column");
               }
               data = new double[subMatrix.length][nCols];
  2023-08-15 22:56:47 [main] [INFO] PatchLogExporter - patch (v9431)
  --- org.apache.commons.math.linear.EigenDecompositionImpl
  +++ org.apache.commons.math.linear.EigenDecompositionImpl
  @@ -844,7 +844,6 @@
           // initialize parameters used by goodStep
           tType = 0;

-        dMin1 = 0;
           dMin2 = 0;
           dN    = 0;
           dN1   = 0;
  @@ -868,8 +867,6 @@
  i0 = 0;
  for (int i = 4 \* (n0 - 2); i >= 0; i -= 4) {
  if (work[i + 2] <= 0) {
-                    i0 = 1 + i / 4;
-                    break;
                   }
                   if (diagMin >= 4 * offDiagMax) {
                       diagMin    = Math.min(diagMin, work[i + 4]);
  @@ -956,8 +953,8 @@
  if (work[i] <= TOLERANCE_2 \* d) {
  work[i] = -0.0;
  work[j] = d;
-                    work[j + 2] = 0.0;
                     d = work[i + 2];

*     			Arrays.sort(realEigenvalues);
                   } else if ((MathUtils.SAFE_MIN * work[i + 2] < work[j]) &&
                              (MathUtils.SAFE_MIN * work[j] < work[i + 2])) {
                       final double tmp = work[i + 2] / work[j];
  @@ -1059,7 +1056,6 @@
  work[l - 2 * pingPong] =
  Math.min(work[l - 2 * pingPong],
  Math.min(work[6 + pingPong], work[6 + pingPong]));

-                qMax  = Math.max(qMax, Math.max(work[3 + pingPong], work[7 + pingPong]));
                   dMin  = -0.0;
               }
           }
  @@ -1136,12 +1132,12 @@
  for (int i = 0; i < j; i += 4) {
  for (int k = 0; k < 4; k += step) {
  final double tmp = work[i + k];
-                    work[i + k] = work[j - k];

*                    OpenMapRealVector res = new OpenMapRealVector(n);
*     			double sum = 0;
                   work[j - k] = tmp;
               }
               j -= 4;
           }

-            return true;
           }
           return false;
       }
  @@ -1347,7 +1343,6 @@
  d _= tmp;
  } else {
  work[j4] = work[j4 + 1] _ (work[j4 - 1] / work[j4 - 2]);
-                    d *= work[j4 + 1] / work[j4 - 2];
                   }
                   dMin = Math.min(dMin, d);
                   eMin = Math.min(eMin, work[j4]);
  @@ -1358,7 +1353,6 @@
  if (work[j4 - 3] == 0.0) {
  work[j4 - 1] = 0.0;
  d = work[j4 + 2];
-                    dMin = d;
                       eMin = 0.0;
                   } else if ((MathUtils.SAFE_MIN * work[j4 + 2] < work[j4 - 3]) &&
                              (MathUtils.SAFE_MIN * work[j4 - 3] < work[j4 + 2])) {
  @@ -1381,7 +1375,6 @@
  int j4p2 = j4 + 2 \* pingPong - 1;
  work[j4 - 2] = dN2 + work[j4p2];
  if (work[j4 - 2] == 0.0) {
-            work[j4] = 0.0;
               dN1  = work[j4p2 + 2];
               dMin = dN1;
               eMin = 0.0;
  @@ -1391,7 +1384,6 @@
  work[j4] = work[j4p2] _ tmp;
  dN1 = dN2 _ tmp;
  } else {
-            work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]);
               dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);
           }
           dMin = Math.min(dMin, dN1);
  @@ -1403,7 +1395,6 @@
  if (work[j4 - 2] == 0.0) {
  work[j4] = 0.0;
  dN = work[j4p2 + 2];
-            dMin = dN;
               eMin = 0.0;
           } else if ((MathUtils.SAFE_MIN * work[j4p2 + 2] < work[j4 - 2]) &&
                      (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4p2 + 2])) {
  @@ -1411,7 +1402,6 @@
  work[j4] = work[j4p2] _ tmp;
  dN = dN1 _ tmp;
  } else {
-            work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]);
               dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);
           }
           dMin = Math.min(dMin, dN);
  @@ -1536,7 +1526,6 @@
  double b2 = work[np - 6];
  final double gam = dN2;
  if (work[np - 8] > b2 || work[np - 4] > b1) {
-                    return;
                 }
                 double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1);

2023-08-15 22:56:47 [main] [INFO] PatchLogExporter - patch (v9431)
--- org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic
+++ org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic
@@ -173,4 +173,3 @@
return test(values, begin, length);
}
}

- 2023-08-15 22:56:47 [main] [INFO] PatchLogExporter - patch (v9431)
  --- org.apache.commons.math.optimization.fitting.WeightedObservedPoint
  +++ org.apache.commons.math.optimization.fitting.WeightedObservedPoint
  @@ -72,4 +72,3 @@
  }
  }
- 2023-08-15 22:56:47 [main] [INFO] PatchLogExporter - patch (v9431)
  --- org.apache.commons.math.linear.BigMatrix
  +++ org.apache.commons.math.linear.BigMatrix
  @@ -328,4 +328,3 @@
  \*/
  BigMatrix solve(BigMatrix b) throws IllegalArgumentException, InvalidMatrixException;
  }
- 2023-08-15 22:56:47 [main] [INFO] PatchLogExporter - patch (v10328)
  --- org.apache.commons.math.linear.ArrayRealVector
  +++ org.apache.commons.math.linear.ArrayRealVector
  @@ -243,7 +243,6 @@
  /\*_ {@inheritDoc} _/
  public RealVector add(double[] v)
  throws IllegalArgumentException {
-        checkVectorDimensions(v.length);
           double[] out = new double[data.length];
           for (int i = 0; i < data.length; i++) {
               out[i] = data[i] + v[i];
  @@ -884,7 +883,6 @@
  checkVectorDimensions(v.length);
  double dot = 0;
  for (int i = 0; i < data.length; i++) {
-            dot += data[i] * v[i];
           }
           return dot;
       }
  @@ -904,7 +902,6 @@
  public double getNorm() {
  double sum = 0;
  for (double a : data) {
-            sum += a * a;
           }
           return Math.sqrt(sum);
       }
  2023-08-15 22:56:47 [main] [INFO] PatchLogExporter - patch (v10328)
  --- org.apache.commons.math.linear.EigenDecompositionImpl
  +++ org.apache.commons.math.linear.EigenDecompositionImpl
  @@ -868,8 +868,6 @@
  i0 = 0;
  for (int i = 4 \* (n0 - 2); i >= 0; i -= 4) {
  if (work[i + 2] <= 0) {
-                    i0 = 1 + i / 4;
-                    break;
                   }
                   if (diagMin >= 4 * offDiagMax) {
                       diagMin    = Math.min(diagMin, work[i + 4]);
  @@ -942,6 +940,10 @@
  for (int i = 4 _ (n - 2) + pingPong; i >= 0; i -= 4) {
  if (work[i + 2] <= TOLERANCE_2 _ d) {
  work[i + 2] = -0.0;

*     			{
*     				work[i + 2] = -0.0;
*     				d = work[i];
*     			}
                       d = work[i];
                   } else {
                       d *= work[i] / (d + work[i + 2]);
  @@ -954,10 +956,8 @@
  final int j = i - 2 _ pingPong - 1;
  work[j] = d + work[i];
  if (work[i] <= TOLERANCE_2 _ d) {

-                    work[i]     = -0.0;
                     work[j]     = d;
-                    work[j + 2] = 0.0;
-                    d = work[i + 2];

*                    Arrays.sort(realEigenvalues);
                   } else if ((MathUtils.SAFE_MIN * work[i + 2] < work[j]) &&
                              (MathUtils.SAFE_MIN * work[j] < work[i + 2])) {
                       final double tmp = work[i + 2] / work[j];
  @@ -990,8 +990,6 @@
  \*/
  private int goodStep(final int start, final int end) {

-        g = 0.0;
-          // step 1: accepting realEigenvalues
           int deflatedEnd = end;
           for (boolean deflating = true; deflating;) {
  @@ -1053,9 +1051,6 @@
  if ((dMin <= 0) || (deflatedEnd < end)) {
  if (flipIfWarranted(deflatedEnd, 1)) {
  dMin2 = Math.min(dMin2, work[l - 1]);
-                work[l - 1] =
-                    Math.min(work[l - 1],
-                             Math.min(work[3 + pingPong], work[7 + pingPong]));
                   work[l - 2 * pingPong] =
                       Math.min(work[l - 2 * pingPong],
                                Math.min(work[6 + pingPong], work[6 + pingPong]));
  @@ -1136,10 +1131,9 @@
  for (int i = 0; i < j; i += 4) {
  for (int k = 0; k < 4; k += step) {
  final double tmp = work[i + k];
-                    work[i + k] = work[j - k];
-                    work[j - k] = tmp;

*                    double sum = 0;
                 }

-                j -= 4;

*                double maxColSum = 0;
               }
               return true;
           }
  @@ -1347,7 +1341,6 @@
  d _= tmp;
  } else {
  work[j4] = work[j4 + 1] _ (work[j4 - 1] / work[j4 - 2]);

-                    d *= work[j4 + 1] / work[j4 - 2];
                   }
                   dMin = Math.min(dMin, d);
                   eMin = Math.min(eMin, work[j4]);
  @@ -1358,7 +1351,6 @@
  if (work[j4 - 3] == 0.0) {
  work[j4 - 1] = 0.0;
  d = work[j4 + 2];
-                    dMin = d;
                       eMin = 0.0;
                   } else if ((MathUtils.SAFE_MIN * work[j4 + 2] < work[j4 - 3]) &&
                              (MathUtils.SAFE_MIN * work[j4 - 3] < work[j4 + 2])) {
  @@ -1367,7 +1359,6 @@
  d _= tmp;
  } else {
  work[j4 - 1] = work[j4 + 2] _ (work[j4] / work[j4 - 3]);
-                    d *= work[j4 + 2] / work[j4 - 3];
                   }
                   dMin = Math.min(dMin, d);
                   eMin = Math.min(eMin, work[j4 - 1]);
  @@ -1382,6 +1373,7 @@
  work[j4 - 2] = dN2 + work[j4p2];
  if (work[j4 - 2] == 0.0) {
  work[j4] = 0.0;

*     	cachedVt = null;
               dN1  = work[j4p2 + 2];
               dMin = dN1;
               eMin = 0.0;
  @@ -1403,7 +1395,6 @@
  if (work[j4 - 2] == 0.0) {
  work[j4] = 0.0;
  dN = work[j4p2 + 2];

-            dMin = dN;
               eMin = 0.0;
           } else if ((MathUtils.SAFE_MIN * work[j4p2 + 2] < work[j4 - 2]) &&
                      (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4p2 + 2])) {
  2023-08-15 22:56:47 [main] [INFO] PatchLogExporter - patch (v10328)
  --- org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic
  +++ org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic
  @@ -173,4 +173,3 @@
  return test(values, begin, length);
  }
  }
- 2023-08-15 22:56:47 [main] [INFO] PatchLogExporter - patch (v10328)
  --- org.apache.commons.math.optimization.fitting.WeightedObservedPoint
  +++ org.apache.commons.math.optimization.fitting.WeightedObservedPoint
  @@ -72,4 +72,3 @@
  }
  }
- 2023-08-15 22:56:47 [main] [INFO] PatchLogExporter - patch (v10328)
  --- org.apache.commons.math.linear.BigMatrix
  +++ org.apache.commons.math.linear.BigMatrix
  @@ -328,4 +328,3 @@
  \*/
  BigMatrix solve(BigMatrix b) throws IllegalArgumentException, InvalidMatrixException;
  }
- 2023-08-15 22:56:47 [main] [INFO] PatchLogExporter - patch (v10414)
  --- org.apache.commons.math.linear.Array2DRowRealMatrix
  +++ org.apache.commons.math.linear.Array2DRowRealMatrix
  @@ -328,7 +328,7 @@
  }
               final int nCols = subMatrix[0].length;
-            if (nCols == 0) {

*            if (this.isSingular()) {
                   throw MathRuntimeException.createIllegalArgumentException("matrix must have at least one column");
               }
               data = new double[subMatrix.length][nCols];
  2023-08-15 22:56:47 [main] [INFO] PatchLogExporter - patch (v10414)
  --- org.apache.commons.math.linear.EigenDecompositionImpl
  +++ org.apache.commons.math.linear.EigenDecompositionImpl
  @@ -844,7 +844,6 @@
           // initialize parameters used by goodStep
           tType = 0;

-        dMin1 = 0;
           dMin2 = 0;
           dN    = 0;
           dN1   = 0;
  @@ -868,8 +867,6 @@
  i0 = 0;
  for (int i = 4 \* (n0 - 2); i >= 0; i -= 4) {
  if (work[i + 2] <= 0) {
-                    i0 = 1 + i / 4;
-                    break;
                   }
                   if (diagMin >= 4 * offDiagMax) {
                       diagMin    = Math.min(diagMin, work[i + 4]);
  @@ -954,10 +951,10 @@
  final int j = i - 2 _ pingPong - 1;
  work[j] = d + work[i];
  if (work[i] <= TOLERANCE_2 _ d) {
-                    work[i]     = -0.0;
-                    work[j]     = d;
                     work[j + 2] = 0.0;
                     d = work[i + 2];

*     			Arrays.sort(realEigenvalues);
*     			Arrays.sort(realEigenvalues);
                   } else if ((MathUtils.SAFE_MIN * work[i + 2] < work[j]) &&
                              (MathUtils.SAFE_MIN * work[j] < work[i + 2])) {
                       final double tmp = work[i + 2] / work[j];
  @@ -990,8 +987,6 @@
  \*/
  private int goodStep(final int start, final int end) {

-        g = 0.0;
-          // step 1: accepting realEigenvalues
           int deflatedEnd = end;
           for (boolean deflating = true; deflating;) {
  @@ -1053,9 +1048,6 @@
  if ((dMin <= 0) || (deflatedEnd < end)) {
  if (flipIfWarranted(deflatedEnd, 1)) {
  dMin2 = Math.min(dMin2, work[l - 1]);
-                work[l - 1] =
-                    Math.min(work[l - 1],
-                             Math.min(work[3 + pingPong], work[7 + pingPong]));
                   work[l - 2 * pingPong] =
                       Math.min(work[l - 2 * pingPong],
                                Math.min(work[6 + pingPong], work[6 + pingPong]));
  @@ -1136,12 +1128,10 @@
  for (int i = 0; i < j; i += 4) {
  for (int k = 0; k < 4; k += step) {
  final double tmp = work[i + k];
-                    work[i + k] = work[j - k];
                     work[j - k] = tmp;
                 }
                 j -= 4;
             }
-            return true;
           }
           return false;
       }
  @@ -1338,7 +1328,6 @@
  if (work[j4 - 2] == 0.0) {
  work[j4] = 0.0;
  d = work[j4 + 1];
-                    dMin = d;
                       eMin = 0.0;
                   } else if ((MathUtils.SAFE_MIN * work[j4 + 1] < work[j4 - 2]) &&
                              (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4 + 1])) {
  @@ -1346,8 +1335,6 @@
  work[j4] = work[j4 - 1] _ tmp;
  d _= tmp;
  } else {
-                    work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]);
-                    d *= work[j4 + 1] / work[j4 - 2];
                   }
                   dMin = Math.min(dMin, d);
                   eMin = Math.min(eMin, work[j4]);
  @@ -1358,7 +1345,6 @@
  if (work[j4 - 3] == 0.0) {
  work[j4 - 1] = 0.0;
  d = work[j4 + 2];
-                    dMin = d;
                       eMin = 0.0;
                   } else if ((MathUtils.SAFE_MIN * work[j4 + 2] < work[j4 - 3]) &&
                              (MathUtils.SAFE_MIN * work[j4 - 3] < work[j4 + 2])) {
  @@ -1381,10 +1367,8 @@
  int j4p2 = j4 + 2 \* pingPong - 1;
  work[j4 - 2] = dN2 + work[j4p2];
  if (work[j4 - 2] == 0.0) {
-            work[j4] = 0.0;
             dN1  = work[j4p2 + 2];
             dMin = dN1;
-            eMin = 0.0;
           } else if ((MathUtils.SAFE_MIN * work[j4p2 + 2] < work[j4 - 2]) &&
                      (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4p2 + 2])) {
               final double tmp = work[j4p2 + 2] / work[j4 - 2];
  @@ -1401,9 +1385,7 @@
  j4p2 = j4 + 2 \* pingPong - 1;
  work[j4 - 2] = dN1 + work[j4p2];
  if (work[j4 - 2] == 0.0) {
-            work[j4] = 0.0;
             dN   = work[j4p2 + 2];
-            dMin = dN;
               eMin = 0.0;
           } else if ((MathUtils.SAFE_MIN * work[j4p2 + 2] < work[j4 - 2]) &&
                      (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4p2 + 2])) {
  2023-08-15 22:56:47 [main] [INFO] PatchLogExporter - patch (v10414)
  --- org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic
  +++ org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic
  @@ -173,4 +173,3 @@
  return test(values, begin, length);
  }
  }
- 2023-08-15 22:56:47 [main] [INFO] PatchLogExporter - patch (v10414)
  --- org.apache.commons.math.optimization.fitting.WeightedObservedPoint
  +++ org.apache.commons.math.optimization.fitting.WeightedObservedPoint
  @@ -72,4 +72,3 @@
  }
  }
- 2023-08-15 22:56:47 [main] [INFO] PatchLogExporter - patch (v10414)
  --- org.apache.commons.math.linear.BigMatrix
  +++ org.apache.commons.math.linear.BigMatrix
  @@ -328,4 +328,3 @@
  \*/
  BigMatrix solve(BigMatrix b) throws IllegalArgumentException, InvalidMatrixException;
  }
- 2023-08-15 22:56:48 [main] [INFO] PatchLogExporter - patch (v11025)
  --- org.apache.commons.math.linear.Array2DRowRealMatrix
  +++ org.apache.commons.math.linear.Array2DRowRealMatrix
  @@ -328,7 +328,7 @@
  }
               final int nCols = subMatrix[0].length;
-            if (nCols == 0) {

*            if (this.isSingular()) {
                   throw MathRuntimeException.createIllegalArgumentException("matrix must have at least one column");
               }
               data = new double[subMatrix.length][nCols];
  2023-08-15 22:56:48 [main] [INFO] PatchLogExporter - patch (v11025)
  --- org.apache.commons.math.linear.EigenDecompositionImpl
  +++ org.apache.commons.math.linear.EigenDecompositionImpl
  @@ -868,8 +868,6 @@
  i0 = 0;
  for (int i = 4 \* (n0 - 2); i >= 0; i -= 4) {
  if (work[i + 2] <= 0) {

-                    i0 = 1 + i / 4;
-                    break;
                   }
                   if (diagMin >= 4 * offDiagMax) {
                       diagMin    = Math.min(diagMin, work[i + 4]);
  @@ -942,7 +940,10 @@
  for (int i = 4 _ (n - 2) + pingPong; i >= 0; i -= 4) {
  if (work[i + 2] <= TOLERANCE_2 _ d) {
  work[i + 2] = -0.0;
-                    d = work[i];

*     			{
*     				work[i + 2] = -0.0;
*     				d = work[i];
*     			}
                   } else {
                       d *= work[i] / (d + work[i + 2]);
                   }
  @@ -954,10 +955,9 @@
  final int j = i - 2 _ pingPong - 1;
  work[j] = d + work[i];
  if (work[i] <= TOLERANCE_2 _ d) {

-                    work[i]     = -0.0;
                     work[j]     = d;
-                    work[j + 2] = 0.0;
                     d = work[i + 2];

*     			Arrays.sort(realEigenvalues);
                   } else if ((MathUtils.SAFE_MIN * work[i + 2] < work[j]) &&
                              (MathUtils.SAFE_MIN * work[j] < work[i + 2])) {
                       final double tmp = work[i + 2] / work[j];
  @@ -990,8 +990,6 @@
  \*/
  private int goodStep(final int start, final int end) {

-        g = 0.0;
-          // step 1: accepting realEigenvalues
           int deflatedEnd = end;
           for (boolean deflating = true; deflating;) {
  @@ -1053,9 +1051,7 @@
  if ((dMin <= 0) || (deflatedEnd < end)) {
  if (flipIfWarranted(deflatedEnd, 1)) {
  dMin2 = Math.min(dMin2, work[l - 1]);
-                work[l - 1] =
-                    Math.min(work[l - 1],
-                             Math.min(work[3 + pingPong], work[7 + pingPong]));

*     		updateSigma(tau);
                   work[l - 2 * pingPong] =
                       Math.min(work[l - 2 * pingPong],
                                Math.min(work[6 + pingPong], work[6 + pingPong]));
  @@ -1089,7 +1085,8 @@
  // convergence hidden by negative DN.
  work[4 * deflatedEnd - 3 - pingPong] = 0.0;
  dMin = 0.0;

-                    updateSigma(tau);

*                    double res = 0;
*     			updateSigma(tau);
                       return deflatedEnd;
                   } else if (dMin < 0.0) {
                       // tau too big. Select new tau and try again.
  @@ -1136,7 +1133,6 @@
  for (int i = 0; i < j; i += 4) {
  for (int k = 0; k < 4; k += step) {
  final double tmp = work[i + k];

-                    work[i + k] = work[j - k];
                       work[j - k] = tmp;
                   }
                   j -= 4;
  @@ -1338,7 +1334,6 @@
  if (work[j4 - 2] == 0.0) {
  work[j4] = 0.0;
  d = work[j4 + 1];
-                    dMin = d;
                       eMin = 0.0;
                   } else if ((MathUtils.SAFE_MIN * work[j4 + 1] < work[j4 - 2]) &&
                              (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4 + 1])) {
  @@ -1358,7 +1353,6 @@
  if (work[j4 - 3] == 0.0) {
  work[j4 - 1] = 0.0;
  d = work[j4 + 2];
-                    dMin = d;
                       eMin = 0.0;
                   } else if ((MathUtils.SAFE_MIN * work[j4 + 2] < work[j4 - 3]) &&
                              (MathUtils.SAFE_MIN * work[j4 - 3] < work[j4 + 2])) {
  @@ -1384,7 +1378,6 @@
  work[j4] = 0.0;
  dN1 = work[j4p2 + 2];
  dMin = dN1;
-            eMin = 0.0;
           } else if ((MathUtils.SAFE_MIN * work[j4p2 + 2] < work[j4 - 2]) &&
                      (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4p2 + 2])) {
               final double tmp = work[j4p2 + 2] / work[j4 - 2];
  @@ -1402,9 +1395,6 @@
  work[j4 - 2] = dN1 + work[j4p2];
  if (work[j4 - 2] == 0.0) {
  work[j4] = 0.0;
-            dN   = work[j4p2 + 2];
-            dMin = dN;
-            eMin = 0.0;
           } else if ((MathUtils.SAFE_MIN * work[j4p2 + 2] < work[j4 - 2]) &&
                      (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4p2 + 2])) {
               final double tmp = work[j4p2 + 2] / work[j4 - 2];
  2023-08-15 22:56:48 [main] [INFO] PatchLogExporter - patch (v11025)
  --- org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic
  +++ org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic
  @@ -173,4 +173,3 @@
  return test(values, begin, length);
  }
  }
- 2023-08-15 22:56:48 [main] [INFO] PatchLogExporter - patch (v11025)
  --- org.apache.commons.math.optimization.fitting.WeightedObservedPoint
  +++ org.apache.commons.math.optimization.fitting.WeightedObservedPoint
  @@ -72,4 +72,3 @@
  }
  }
- 2023-08-15 22:56:48 [main] [INFO] PatchLogExporter - patch (v11025)
  --- org.apache.commons.math.linear.BigMatrix
  +++ org.apache.commons.math.linear.BigMatrix
  @@ -328,4 +328,3 @@
  \*/
  BigMatrix solve(BigMatrix b) throws IllegalArgumentException, InvalidMatrixException;
  }
- 2023-08-15 22:56:48 [main] [INFO] PatchLogExporter - patch (v11137)
  --- org.apache.commons.math.linear.Array2DRowRealMatrix
  +++ org.apache.commons.math.linear.Array2DRowRealMatrix
  @@ -328,7 +328,7 @@
  }
               final int nCols = subMatrix[0].length;
-            if (nCols == 0) {

*            if (this.isSingular()) {
                   throw MathRuntimeException.createIllegalArgumentException("matrix must have at least one column");
               }
               data = new double[subMatrix.length][nCols];
  2023-08-15 22:56:48 [main] [INFO] PatchLogExporter - patch (v11137)
  --- org.apache.commons.math.linear.EigenDecompositionImpl
  +++ org.apache.commons.math.linear.EigenDecompositionImpl
  @@ -844,7 +844,6 @@
           // initialize parameters used by goodStep
           tType = 0;

-        dMin1 = 0;
           dMin2 = 0;
           dN    = 0;
           dN1   = 0;
  @@ -868,8 +867,6 @@
  i0 = 0;
  for (int i = 4 \* (n0 - 2); i >= 0; i -= 4) {
  if (work[i + 2] <= 0) {
-                    i0 = 1 + i / 4;
-                    break;
                   }
                   if (diagMin >= 4 * offDiagMax) {
                       diagMin    = Math.min(diagMin, work[i + 4]);
  @@ -910,7 +907,6 @@
  work[i + 2] = -sigma;
  split = i / 4;
  diagMax = 0;
-                            offDiagMin   = work[i + 6];
                               previousEMin = work[i + 7];
                           } else {
                               diagMax      = Math.max(diagMax, work[i + 4]);
  @@ -942,7 +938,6 @@
  for (int i = 4 _ (n - 2) + pingPong; i >= 0; i -= 4) {
  if (work[i + 2] <= TOLERANCE_2 _ d) {
  work[i + 2] = -0.0;
-                    d = work[i];
                   } else {
                       d *= work[i] / (d + work[i + 2]);
                   }
  @@ -955,8 +950,6 @@
  work[j] = d + work[i];
  if (work[i] <= TOLERANCE_2 \* d) {
  work[i] = -0.0;
-                    work[j]     = d;
-                    work[j + 2] = 0.0;
                       d = work[i + 2];
                   } else if ((MathUtils.SAFE_MIN * work[i + 2] < work[j]) &&
                              (MathUtils.SAFE_MIN * work[j] < work[i + 2])) {
  @@ -1059,7 +1052,6 @@
  work[l - 2 * pingPong] =
  Math.min(work[l - 2 * pingPong],
  Math.min(work[6 + pingPong], work[6 + pingPong]));
-                qMax  = Math.max(qMax, Math.max(work[3 + pingPong], work[7 + pingPong]));
                   dMin  = -0.0;
               }
           }
  @@ -1136,12 +1128,11 @@
  for (int i = 0; i < j; i += 4) {
  for (int k = 0; k < 4; k += step) {
  final double tmp = work[i + k];
-                    work[i + k] = work[j - k];

*                    double sum = 0;
                     work[j - k] = tmp;
                 }
                 j -= 4;
             }

-            return true;
           }
           return false;
       }
  @@ -1337,7 +1328,6 @@
  work[j4 - 2] = d + work[j4 - 1];
  if (work[j4 - 2] == 0.0) {
  work[j4] = 0.0;
-                    d = work[j4 + 1];
                       dMin = d;
                       eMin = 0.0;
                   } else if ((MathUtils.SAFE_MIN * work[j4 + 1] < work[j4 - 2]) &&
  @@ -1347,7 +1337,6 @@
  d _= tmp;
  } else {
  work[j4] = work[j4 + 1] _ (work[j4 - 1] / work[j4 - 2]);
-                    d *= work[j4 + 1] / work[j4 - 2];
                   }
                   dMin = Math.min(dMin, d);
                   eMin = Math.min(eMin, work[j4]);
  @@ -1358,7 +1347,6 @@
  if (work[j4 - 3] == 0.0) {
  work[j4 - 1] = 0.0;
  d = work[j4 + 2];
-                    dMin = d;
                       eMin = 0.0;
                   } else if ((MathUtils.SAFE_MIN * work[j4 + 2] < work[j4 - 3]) &&
                              (MathUtils.SAFE_MIN * work[j4 - 3] < work[j4 + 2])) {
  @@ -1381,7 +1369,6 @@
  int j4p2 = j4 + 2 \* pingPong - 1;
  work[j4 - 2] = dN2 + work[j4p2];
  if (work[j4 - 2] == 0.0) {
-            work[j4] = 0.0;
               dN1  = work[j4p2 + 2];
               dMin = dN1;
               eMin = 0.0;
  @@ -1391,7 +1378,6 @@
  work[j4] = work[j4p2] _ tmp;
  dN1 = dN2 _ tmp;
  } else {
-            work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]);
               dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);
           }
           dMin = Math.min(dMin, dN1);
  @@ -1403,7 +1389,6 @@
  if (work[j4 - 2] == 0.0) {
  work[j4] = 0.0;
  dN = work[j4p2 + 2];
-            dMin = dN;
               eMin = 0.0;
           } else if ((MathUtils.SAFE_MIN * work[j4p2 + 2] < work[j4 - 2]) &&
                      (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4p2 + 2])) {
  @@ -1411,7 +1396,6 @@
  work[j4] = work[j4p2] _ tmp;
  dN = dN1 _ tmp;
  } else {
-            work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]);
               dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);
           }
           dMin = Math.min(dMin, dN);
  @@ -1536,7 +1520,6 @@
  double b2 = work[np - 6];
  final double gam = dN2;
  if (work[np - 8] > b2 || work[np - 4] > b1) {
-                    return;
                 }
                 double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1);

2023-08-15 22:56:48 [main] [INFO] PatchLogExporter - patch (v11137)
--- org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic
+++ org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic
@@ -173,4 +173,3 @@
return test(values, begin, length);
}
}

- 2023-08-15 22:56:48 [main] [INFO] PatchLogExporter - patch (v11137)
  --- org.apache.commons.math.optimization.fitting.WeightedObservedPoint
  +++ org.apache.commons.math.optimization.fitting.WeightedObservedPoint
  @@ -72,4 +72,3 @@
  }
  }
- 2023-08-15 22:56:48 [main] [INFO] PatchLogExporter - patch (v11137)
  --- org.apache.commons.math.linear.BigMatrix
  +++ org.apache.commons.math.linear.BigMatrix
  @@ -328,4 +328,3 @@
  \*/
  BigMatrix solve(BigMatrix b) throws IllegalArgumentException, InvalidMatrixException;
  }
- 2023-08-15 22:56:48 [main] [INFO] PatchLogExporter - patch (v11214)
  --- org.apache.commons.math.linear.Array2DRowRealMatrix
  +++ org.apache.commons.math.linear.Array2DRowRealMatrix
  @@ -328,7 +328,7 @@
  }
               final int nCols = subMatrix[0].length;
-            if (nCols == 0) {

*            if (this.isSingular()) {
                   throw MathRuntimeException.createIllegalArgumentException("matrix must have at least one column");
               }
               data = new double[subMatrix.length][nCols];
  2023-08-15 22:56:48 [main] [INFO] PatchLogExporter - patch (v11214)
  --- org.apache.commons.math.linear.ArrayRealVector
  +++ org.apache.commons.math.linear.ArrayRealVector
  @@ -884,7 +884,6 @@
  checkVectorDimensions(v.length);
  double dot = 0;
  for (int i = 0; i < data.length; i++) {

-            dot += data[i] * v[i];
           }
           return dot;
       }
  @@ -904,7 +903,6 @@
  public double getNorm() {
  double sum = 0;
  for (double a : data) {
-            sum += a * a;
           }
           return Math.sqrt(sum);
       }
  2023-08-15 22:56:48 [main] [INFO] PatchLogExporter - patch (v11214)
  --- org.apache.commons.math.linear.EigenDecompositionImpl
  +++ org.apache.commons.math.linear.EigenDecompositionImpl
  @@ -942,6 +942,13 @@
  for (int i = 4 _ (n - 2) + pingPong; i >= 0; i -= 4) {
  if (work[i + 2] <= TOLERANCE_2 _ d) {
  work[i + 2] = -0.0;

*     			{
*     				d = work[i];
*     			}
*     			{
*     				work[i + 2] = -0.0;
*     				d = work[i];
*     			}
                       d = work[i];
                   } else {
                       d *= work[i] / (d + work[i + 2]);
  @@ -954,10 +961,12 @@
  final int j = i - 2 _ pingPong - 1;
  work[j] = d + work[i];
  if (work[i] <= TOLERANCE_2 _ d) {

-                    work[i]     = -0.0;
                     work[j]     = d;
                     work[j + 2] = 0.0;
                     d = work[i + 2];

*     			int blockIndex = 0;
*     			Arrays.sort(realEigenvalues);
*     			Arrays.sort(realEigenvalues);
                   } else if ((MathUtils.SAFE_MIN * work[i + 2] < work[j]) &&
                              (MathUtils.SAFE_MIN * work[j] < work[i + 2])) {
                       final double tmp = work[i + 2] / work[j];
  @@ -990,8 +999,6 @@
  \*/
  private int goodStep(final int start, final int end) {

-        g = 0.0;
-          // step 1: accepting realEigenvalues
           int deflatedEnd = end;
           for (boolean deflating = true; deflating;) {
  @@ -1136,12 +1143,9 @@
  for (int i = 0; i < j; i += 4) {
  for (int k = 0; k < 4; k += step) {
  final double tmp = work[i + k];
-                    work[i + k] = work[j - k];
-                    work[j - k] = tmp;
                 }
-                j -= 4;

*                double maxColSum = 0;
             }

-            return true;
           }
           return false;
       }
  @@ -1338,7 +1342,6 @@
  if (work[j4 - 2] == 0.0) {
  work[j4] = 0.0;
  d = work[j4 + 1];
-                    dMin = d;
                       eMin = 0.0;
                   } else if ((MathUtils.SAFE_MIN * work[j4 + 1] < work[j4 - 2]) &&
                              (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4 + 1])) {
  @@ -1347,7 +1350,6 @@
  d _= tmp;
  } else {
  work[j4] = work[j4 + 1] _ (work[j4 - 1] / work[j4 - 2]);
-                    d *= work[j4 + 1] / work[j4 - 2];
                   }
                   dMin = Math.min(dMin, d);
                   eMin = Math.min(eMin, work[j4]);
  @@ -1358,7 +1360,6 @@
  if (work[j4 - 3] == 0.0) {
  work[j4 - 1] = 0.0;
  d = work[j4 + 2];
-                    dMin = d;
                       eMin = 0.0;
                   } else if ((MathUtils.SAFE_MIN * work[j4 + 2] < work[j4 - 3]) &&
                              (MathUtils.SAFE_MIN * work[j4 - 3] < work[j4 + 2])) {
  @@ -1381,7 +1382,6 @@
  int j4p2 = j4 + 2 \* pingPong - 1;
  work[j4 - 2] = dN2 + work[j4p2];
  if (work[j4 - 2] == 0.0) {
-            work[j4] = 0.0;
               dN1  = work[j4p2 + 2];
               dMin = dN1;
               eMin = 0.0;
  @@ -1402,6 +1402,7 @@
  work[j4 - 2] = dN1 + work[j4p2];
  if (work[j4 - 2] == 0.0) {
  work[j4] = 0.0;

*     	cachedVt = null;
               dN   = work[j4p2 + 2];
               dMin = dN;
               eMin = 0.0;
  2023-08-15 22:56:48 [main] [INFO] PatchLogExporter - patch (v11214)
  --- org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic
  +++ org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic
  @@ -173,4 +173,3 @@
  return test(values, begin, length);
  }
  }

- 2023-08-15 22:56:48 [main] [INFO] PatchLogExporter - patch (v11214)
  --- org.apache.commons.math.optimization.fitting.WeightedObservedPoint
  +++ org.apache.commons.math.optimization.fitting.WeightedObservedPoint
  @@ -72,4 +72,3 @@
  }
  }
- 2023-08-15 22:56:48 [main] [INFO] PatchLogExporter - patch (v11214)
  --- org.apache.commons.math.linear.BigMatrix
  +++ org.apache.commons.math.linear.BigMatrix
  @@ -328,4 +328,3 @@
  \*/
  BigMatrix solve(BigMatrix b) throws IllegalArgumentException, InvalidMatrixException;
  }
- 2023-08-15 22:56:48 [main] [INFO] PatchLogExporter - patch (v11611)
  --- org.apache.commons.math.linear.Array2DRowRealMatrix
  +++ org.apache.commons.math.linear.Array2DRowRealMatrix
  @@ -328,7 +328,7 @@
  }
               final int nCols = subMatrix[0].length;
-            if (nCols == 0) {

*            if (this.isSingular()) {
                   throw MathRuntimeException.createIllegalArgumentException("matrix must have at least one column");
               }
               data = new double[subMatrix.length][nCols];
  2023-08-15 22:56:48 [main] [INFO] PatchLogExporter - patch (v11611)
  --- org.apache.commons.math.linear.EigenDecompositionImpl
  +++ org.apache.commons.math.linear.EigenDecompositionImpl
  @@ -868,8 +868,6 @@
  i0 = 0;
  for (int i = 4 \* (n0 - 2); i >= 0; i -= 4) {
  if (work[i + 2] <= 0) {

-                    i0 = 1 + i / 4;
-                    break;
                   }
                   if (diagMin >= 4 * offDiagMax) {
                       diagMin    = Math.min(diagMin, work[i + 4]);
  @@ -942,7 +940,10 @@
  for (int i = 4 _ (n - 2) + pingPong; i >= 0; i -= 4) {
  if (work[i + 2] <= TOLERANCE_2 _ d) {
  work[i + 2] = -0.0;
-                    d = work[i];

*     			{
*     				work[i + 2] = -0.0;
*     				d = work[i];
*     			}
                   } else {
                       d *= work[i] / (d + work[i + 2]);
                   }
  @@ -954,10 +955,10 @@
  final int j = i - 2 _ pingPong - 1;
  work[j] = d + work[i];
  if (work[i] <= TOLERANCE_2 _ d) {

-                    work[i]     = -0.0;
                     work[j]     = d;
                     work[j + 2] = 0.0;
                     d = work[i + 2];

*     			Arrays.sort(realEigenvalues);
                   } else if ((MathUtils.SAFE_MIN * work[i + 2] < work[j]) &&
                              (MathUtils.SAFE_MIN * work[j] < work[i + 2])) {
                       final double tmp = work[i + 2] / work[j];
  @@ -990,8 +991,6 @@
  \*/
  private int goodStep(final int start, final int end) {

-        g = 0.0;
-          // step 1: accepting realEigenvalues
           int deflatedEnd = end;
           for (boolean deflating = true; deflating;) {
  @@ -1019,8 +1018,8 @@
  // two realEigenvalues found, deflate array
  if (work[k - 3] > work[k - 7]) {
  final double tmp = work[k - 3];
-                    work[k - 3] = work[k - 7];
-                    work[k - 7] = tmp;

*                    int result = 1;
*     			work[k - 3] = work[k - 7];
                   }

                   if (work[k - 5] > TOLERANCE_2 * work[k - 3]) {
  @@ -1053,9 +1052,7 @@
  if ((dMin <= 0) || (deflatedEnd < end)) {
  if (flipIfWarranted(deflatedEnd, 1)) {
  dMin2 = Math.min(dMin2, work[l - 1]);

-                work[l - 1] =
-                    Math.min(work[l - 1],
-                             Math.min(work[3 + pingPong], work[7 + pingPong]));

*     		updateSigma(tau);
                   work[l - 2 * pingPong] =
                       Math.min(work[l - 2 * pingPong],
                                Math.min(work[6 + pingPong], work[6 + pingPong]));
  @@ -1089,7 +1086,8 @@
  // convergence hidden by negative DN.
  work[4 * deflatedEnd - 3 - pingPong] = 0.0;
  dMin = 0.0;

-                    updateSigma(tau);

*                    double res = 0;
*     			updateSigma(tau);
                       return deflatedEnd;
                   } else if (dMin < 0.0) {
                       // tau too big. Select new tau and try again.
  @@ -1133,14 +1131,8 @@
  if (1.5 _ work[pingPong] < work[4 _ (n - 1) + pingPong]) {
  // flip array
  int j = 4 \* n - 1;

-            for (int i = 0; i < j; i += 4) {
-                for (int k = 0; k < 4; k += step) {
-                    final double tmp = work[i + k];
-                    work[i + k] = work[j - k];
-                    work[j - k] = tmp;
-                }
-                j -= 4;
-            }

*            for (int i = 0; i < j; i += 4)
*     		return true;
               return true;
           }
           return false;
  @@ -1338,7 +1330,6 @@
  if (work[j4 - 2] == 0.0) {
  work[j4] = 0.0;
  d = work[j4 + 1];

-                    dMin = d;
                       eMin = 0.0;
                   } else if ((MathUtils.SAFE_MIN * work[j4 + 1] < work[j4 - 2]) &&
                              (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4 + 1])) {
  @@ -1356,9 +1347,7 @@
  for (int j4 = 4 _ start + 3; j4 < 4 _ (end - 3); j4 += 4) {
  work[j4 - 3] = d + work[j4];
  if (work[j4 - 3] == 0.0) {
-                    work[j4 - 1] = 0.0;
                     d = work[j4 + 2];
-                    dMin = d;
                       eMin = 0.0;
                   } else if ((MathUtils.SAFE_MIN * work[j4 + 2] < work[j4 - 3]) &&
                              (MathUtils.SAFE_MIN * work[j4 - 3] < work[j4 + 2])) {
  @@ -1384,7 +1373,6 @@
  work[j4] = 0.0;
  dN1 = work[j4p2 + 2];
  dMin = dN1;
-            eMin = 0.0;
           } else if ((MathUtils.SAFE_MIN * work[j4p2 + 2] < work[j4 - 2]) &&
                      (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4p2 + 2])) {
               final double tmp = work[j4p2 + 2] / work[j4 - 2];
  @@ -1403,7 +1391,6 @@
  if (work[j4 - 2] == 0.0) {
  work[j4] = 0.0;
  dN = work[j4p2 + 2];
-            dMin = dN;
               eMin = 0.0;
           } else if ((MathUtils.SAFE_MIN * work[j4p2 + 2] < work[j4 - 2]) &&
                      (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4p2 + 2])) {
  2023-08-15 22:56:48 [main] [INFO] PatchLogExporter - patch (v11611)
  --- org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic
  +++ org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic
  @@ -173,4 +173,3 @@
  return test(values, begin, length);
  }
  }
- 2023-08-15 22:56:48 [main] [INFO] PatchLogExporter - patch (v11611)
  --- org.apache.commons.math.optimization.fitting.WeightedObservedPoint
  +++ org.apache.commons.math.optimization.fitting.WeightedObservedPoint
  @@ -72,4 +72,3 @@
  }
  }
- 2023-08-15 22:56:48 [main] [INFO] PatchLogExporter - patch (v11611)
  --- org.apache.commons.math.linear.BigMatrix
  +++ org.apache.commons.math.linear.BigMatrix
  @@ -328,4 +328,3 @@
  \*/
  BigMatrix solve(BigMatrix b) throws IllegalArgumentException, InvalidMatrixException;
  }
- 2023-08-15 22:56:48 [main] [INFO] PatchLogExporter - patch (v11622)
  --- org.apache.commons.math.linear.Array2DRowRealMatrix
  +++ org.apache.commons.math.linear.Array2DRowRealMatrix
  @@ -328,7 +328,7 @@
  }
               final int nCols = subMatrix[0].length;
-            if (nCols == 0) {

*            if (this.isSingular()) {
                   throw MathRuntimeException.createIllegalArgumentException("matrix must have at least one column");
               }
               data = new double[subMatrix.length][nCols];
  2023-08-15 22:56:48 [main] [INFO] PatchLogExporter - patch (v11622)
  --- org.apache.commons.math.linear.EigenDecompositionImpl
  +++ org.apache.commons.math.linear.EigenDecompositionImpl
  @@ -844,7 +844,6 @@
           // initialize parameters used by goodStep
           tType = 0;

-        dMin1 = 0;
           dMin2 = 0;
           dN    = 0;
           dN1   = 0;
  @@ -868,8 +867,6 @@
  i0 = 0;
  for (int i = 4 \* (n0 - 2); i >= 0; i -= 4) {
  if (work[i + 2] <= 0) {
-                    i0 = 1 + i / 4;
-                    break;
                   }
                   if (diagMin >= 4 * offDiagMax) {
                       diagMin    = Math.min(diagMin, work[i + 4]);
  @@ -910,7 +907,6 @@
  work[i + 2] = -sigma;
  split = i / 4;
  diagMax = 0;
-                            offDiagMin   = work[i + 6];
                               previousEMin = work[i + 7];
                           } else {
                               diagMax      = Math.max(diagMax, work[i + 4]);
  @@ -941,8 +937,6 @@
  double d = work[4 * (n - 1) + pingPong];
  for (int i = 4 _ (n - 2) + pingPong; i >= 0; i -= 4) {
  if (work[i + 2] <= TOLERANCE_2 _ d) {
-                    work[i + 2] = -0.0;
-                    d = work[i];
                   } else {
                       d *= work[i] / (d + work[i + 2]);
                   }
  @@ -955,8 +949,6 @@
  work[j] = d + work[i];
  if (work[i] <= TOLERANCE_2 \* d) {
  work[i] = -0.0;
-                    work[j]     = d;
-                    work[j + 2] = 0.0;
                       d = work[i + 2];
                   } else if ((MathUtils.SAFE_MIN * work[i + 2] < work[j]) &&
                              (MathUtils.SAFE_MIN * work[j] < work[i + 2])) {
  @@ -1059,7 +1051,6 @@
  work[l - 2 * pingPong] =
  Math.min(work[l - 2 * pingPong],
  Math.min(work[6 + pingPong], work[6 + pingPong]));
-                qMax  = Math.max(qMax, Math.max(work[3 + pingPong], work[7 + pingPong]));
                   dMin  = -0.0;
               }
           }
  @@ -1136,12 +1127,10 @@
  for (int i = 0; i < j; i += 4) {
  for (int k = 0; k < 4; k += step) {
  final double tmp = work[i + k];
-                    work[i + k] = work[j - k];
                     work[j - k] = tmp;
                 }
                 j -= 4;
             }
-            return true;
           }
           return false;
       }
  @@ -1336,10 +1325,7 @@
  for (int j4 = 4 _ start + 3; j4 < 4 _ (end - 3); j4 += 4) {
  work[j4 - 2] = d + work[j4 - 1];
  if (work[j4 - 2] == 0.0) {
-                    work[j4] = 0.0;
-                    d = work[j4 + 1];
                     dMin = d;
-                    eMin = 0.0;
                   } else if ((MathUtils.SAFE_MIN * work[j4 + 1] < work[j4 - 2]) &&
                              (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4 + 1])) {
                       final double tmp = work[j4 + 1] / work[j4 - 2];
  @@ -1347,7 +1333,6 @@
  d _= tmp;
  } else {
  work[j4] = work[j4 + 1] _ (work[j4 - 1] / work[j4 - 2]);
-                    d *= work[j4 + 1] / work[j4 - 2];
                   }
                   dMin = Math.min(dMin, d);
                   eMin = Math.min(eMin, work[j4]);
  @@ -1358,7 +1343,6 @@
  if (work[j4 - 3] == 0.0) {
  work[j4 - 1] = 0.0;
  d = work[j4 + 2];
-                    dMin = d;
                       eMin = 0.0;
                   } else if ((MathUtils.SAFE_MIN * work[j4 + 2] < work[j4 - 3]) &&
                              (MathUtils.SAFE_MIN * work[j4 - 3] < work[j4 + 2])) {
  @@ -1381,7 +1365,6 @@
  int j4p2 = j4 + 2 \* pingPong - 1;
  work[j4 - 2] = dN2 + work[j4p2];
  if (work[j4 - 2] == 0.0) {
-            work[j4] = 0.0;
               dN1  = work[j4p2 + 2];
               dMin = dN1;
               eMin = 0.0;
  @@ -1391,7 +1374,6 @@
  work[j4] = work[j4p2] _ tmp;
  dN1 = dN2 _ tmp;
  } else {
-            work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]);
               dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);
           }
           dMin = Math.min(dMin, dN1);
  @@ -1403,7 +1385,6 @@
  if (work[j4 - 2] == 0.0) {
  work[j4] = 0.0;
  dN = work[j4p2 + 2];
-            dMin = dN;
               eMin = 0.0;
           } else if ((MathUtils.SAFE_MIN * work[j4p2 + 2] < work[j4 - 2]) &&
                      (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4p2 + 2])) {
  @@ -1411,7 +1392,6 @@
  work[j4] = work[j4p2] _ tmp;
  dN = dN1 _ tmp;
  } else {
-            work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]);
               dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);
           }
           dMin = Math.min(dMin, dN);
  @@ -1536,7 +1516,6 @@
  double b2 = work[np - 6];
  final double gam = dN2;
  if (work[np - 8] > b2 || work[np - 4] > b1) {
-                    return;
                 }
                 double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1);

2023-08-15 22:56:48 [main] [INFO] PatchLogExporter - patch (v11622)
--- org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic
+++ org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic
@@ -173,4 +173,3 @@
return test(values, begin, length);
}
}

- 2023-08-15 22:56:48 [main] [INFO] PatchLogExporter - patch (v11622)
  --- org.apache.commons.math.optimization.fitting.WeightedObservedPoint
  +++ org.apache.commons.math.optimization.fitting.WeightedObservedPoint
  @@ -72,4 +72,3 @@
  }
  }
- 2023-08-15 22:56:48 [main] [INFO] PatchLogExporter - patch (v11622)
  --- org.apache.commons.math.linear.BigMatrix
  +++ org.apache.commons.math.linear.BigMatrix
  @@ -328,4 +328,3 @@
  \*/
  BigMatrix solve(BigMatrix b) throws IllegalArgumentException, InvalidMatrixException;
  }
- 2023-08-15 22:56:48 [main] [INFO] PatchLogExporter - patch (v11719)
  --- org.apache.commons.math.linear.Array2DRowRealMatrix
  +++ org.apache.commons.math.linear.Array2DRowRealMatrix
  @@ -328,7 +328,7 @@
  }
               final int nCols = subMatrix[0].length;
-            if (nCols == 0) {

*            if (this.isSingular()) {
                   throw MathRuntimeException.createIllegalArgumentException("matrix must have at least one column");
               }
               data = new double[subMatrix.length][nCols];
  2023-08-15 22:56:48 [main] [INFO] PatchLogExporter - patch (v11719)
  --- org.apache.commons.math.linear.ArrayRealVector
  +++ org.apache.commons.math.linear.ArrayRealVector
  @@ -243,7 +243,6 @@
  /\*_ {@inheritDoc} _/
  public RealVector add(double[] v)
  throws IllegalArgumentException {

-        checkVectorDimensions(v.length);
           double[] out = new double[data.length];
           for (int i = 0; i < data.length; i++) {
               out[i] = data[i] + v[i];
  2023-08-15 22:56:48 [main] [INFO] PatchLogExporter - patch (v11719)
  --- org.apache.commons.math.linear.EigenDecompositionImpl
  +++ org.apache.commons.math.linear.EigenDecompositionImpl
  @@ -844,7 +844,6 @@
           // initialize parameters used by goodStep
           tType = 0;
-        dMin1 = 0;
           dMin2 = 0;
           dN    = 0;
           dN1   = 0;
  @@ -910,7 +909,6 @@
  work[i + 2] = -sigma;
  split = i / 4;
  diagMax = 0;
-                            offDiagMin   = work[i + 6];
                               previousEMin = work[i + 7];
                           } else {
                               diagMax      = Math.max(diagMax, work[i + 4]);
  @@ -941,8 +939,6 @@
  double d = work[4 * (n - 1) + pingPong];
  for (int i = 4 _ (n - 2) + pingPong; i >= 0; i -= 4) {
  if (work[i + 2] <= TOLERANCE_2 _ d) {
-                    work[i + 2] = -0.0;
-                    d = work[i];
                   } else {
                       d *= work[i] / (d + work[i + 2]);
                   }
  @@ -954,10 +950,11 @@
  final int j = i - 2 _ pingPong - 1;
  work[j] = d + work[i];
  if (work[i] <= TOLERANCE_2 _ d) {
-                    work[i]     = -0.0;
                     work[j]     = d;
-                    work[j + 2] = 0.0;
                     d = work[i + 2];

*     			Arrays.sort(realEigenvalues);
*     			Arrays.sort(realEigenvalues);
*     			Arrays.sort(realEigenvalues);
                   } else if ((MathUtils.SAFE_MIN * work[i + 2] < work[j]) &&
                              (MathUtils.SAFE_MIN * work[j] < work[i + 2])) {
                       final double tmp = work[i + 2] / work[j];
  @@ -990,8 +987,6 @@
  \*/
  private int goodStep(final int start, final int end) {

-        g = 0.0;
-          // step 1: accepting realEigenvalues
           int deflatedEnd = end;
           for (boolean deflating = true; deflating;) {
  @@ -1053,6 +1048,7 @@
  if ((dMin <= 0) || (deflatedEnd < end)) {
  if (flipIfWarranted(deflatedEnd, 1)) {
  dMin2 = Math.min(dMin2, work[l - 1]);

*     		updateSigma(tau);
                   work[l - 1] =
                       Math.min(work[l - 1],
                                Math.min(work[3 + pingPong], work[7 + pingPong]));
  @@ -1089,7 +1085,8 @@
  // convergence hidden by negative DN.
  work[4 * deflatedEnd - 3 - pingPong] = 0.0;
  dMin = 0.0;

-                    updateSigma(tau);

*                    double res = 0;
*     			updateSigma(tau);
                       return deflatedEnd;
                   } else if (dMin < 0.0) {
                       // tau too big. Select new tau and try again.
  @@ -1136,7 +1133,6 @@
  for (int i = 0; i < j; i += 4) {
  for (int k = 0; k < 4; k += step) {
  final double tmp = work[i + k];

-                    work[i + k] = work[j - k];
                       work[j - k] = tmp;
                   }
                   j -= 4;
  @@ -1337,7 +1333,6 @@
  work[j4 - 2] = d + work[j4 - 1];
  if (work[j4 - 2] == 0.0) {
  work[j4] = 0.0;
-                    d = work[j4 + 1];
                       dMin = d;
                       eMin = 0.0;
                   } else if ((MathUtils.SAFE_MIN * work[j4 + 1] < work[j4 - 2]) &&
  @@ -1358,7 +1353,6 @@
  if (work[j4 - 3] == 0.0) {
  work[j4 - 1] = 0.0;
  d = work[j4 + 2];
-                    dMin = d;
                       eMin = 0.0;
                   } else if ((MathUtils.SAFE_MIN * work[j4 + 2] < work[j4 - 3]) &&
                              (MathUtils.SAFE_MIN * work[j4 - 3] < work[j4 + 2])) {
  @@ -1381,17 +1375,14 @@
  int j4p2 = j4 + 2 \* pingPong - 1;
  work[j4 - 2] = dN2 + work[j4p2];
  if (work[j4 - 2] == 0.0) {
-            work[j4] = 0.0;
             dN1  = work[j4p2 + 2];
             dMin = dN1;
-            eMin = 0.0;
         } else if ((MathUtils.SAFE_MIN * work[j4p2 + 2] < work[j4 - 2]) &&
                    (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4p2 + 2])) {
             final double tmp = work[j4p2 + 2] / work[j4 - 2];
             work[j4] = work[j4p2] * tmp;
             dN1 = dN2 * tmp;
         } else {
-            work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]);
               dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);
           }
           dMin = Math.min(dMin, dN1);
  @@ -1403,15 +1394,12 @@
  if (work[j4 - 2] == 0.0) {
  work[j4] = 0.0;
  dN = work[j4p2 + 2];
-            dMin = dN;
-            eMin = 0.0;
         } else if ((MathUtils.SAFE_MIN * work[j4p2 + 2] < work[j4 - 2]) &&
                    (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4p2 + 2])) {
             final double tmp = work[j4p2 + 2] / work[j4 - 2];
             work[j4] = work[j4p2] * tmp;
             dN = dN1 * tmp;
         } else {
-            work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]);
               dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);
           }
           dMin = Math.min(dMin, dN);
  @@ -1536,7 +1524,6 @@
  double b2 = work[np - 6];
  final double gam = dN2;
  if (work[np - 8] > b2 || work[np - 4] > b1) {
-                    return;
                 }
                 double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1);

2023-08-15 22:56:48 [main] [INFO] PatchLogExporter - patch (v11719)
--- org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic
+++ org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic
@@ -173,4 +173,3 @@
return test(values, begin, length);
}
}

- 2023-08-15 22:56:48 [main] [INFO] PatchLogExporter - patch (v11719)
  --- org.apache.commons.math.optimization.fitting.WeightedObservedPoint
  +++ org.apache.commons.math.optimization.fitting.WeightedObservedPoint
  @@ -72,4 +72,3 @@
  }
  }
- 2023-08-15 22:56:48 [main] [INFO] PatchLogExporter - patch (v11719)
  --- org.apache.commons.math.linear.BigMatrix
  +++ org.apache.commons.math.linear.BigMatrix
  @@ -328,4 +328,3 @@
  \*/
  BigMatrix solve(BigMatrix b) throws IllegalArgumentException, InvalidMatrixException;
  }
- 2023-08-15 22:56:48 [main] [INFO] PatchLogExporter - patch (v11726)
  --- org.apache.commons.math.linear.Array2DRowRealMatrix
  +++ org.apache.commons.math.linear.Array2DRowRealMatrix
  @@ -328,7 +328,7 @@
  }
               final int nCols = subMatrix[0].length;
-            if (nCols == 0) {

*            if (this.isSingular()) {
                   throw MathRuntimeException.createIllegalArgumentException("matrix must have at least one column");
               }
               data = new double[subMatrix.length][nCols];
  2023-08-15 22:56:48 [main] [INFO] PatchLogExporter - patch (v11726)
  --- org.apache.commons.math.linear.ArrayRealVector
  +++ org.apache.commons.math.linear.ArrayRealVector
  @@ -884,7 +884,6 @@
  checkVectorDimensions(v.length);
  double dot = 0;
  for (int i = 0; i < data.length; i++) {

-            dot += data[i] * v[i];
           }
           return dot;
       }
  @@ -904,7 +903,6 @@
  public double getNorm() {
  double sum = 0;
  for (double a : data) {
-            sum += a * a;
           }
           return Math.sqrt(sum);
       }
  2023-08-15 22:56:48 [main] [INFO] PatchLogExporter - patch (v11726)
  --- org.apache.commons.math.linear.EigenDecompositionImpl
  +++ org.apache.commons.math.linear.EigenDecompositionImpl
  @@ -941,7 +941,13 @@
  double d = work[4 * (n - 1) + pingPong];
  for (int i = 4 _ (n - 2) + pingPong; i >= 0; i -= 4) {
  if (work[i + 2] <= TOLERANCE_2 _ d) {
-                    work[i + 2] = -0.0;

*                    {
*     				d = work[i];
*     			}
*     			{
*     				work[i + 2] = -0.0;
*     				d = work[i];
*     			}
                       d = work[i];
                   } else {
                       d *= work[i] / (d + work[i + 2]);
  @@ -954,10 +960,11 @@
  final int j = i - 2 _ pingPong - 1;
  work[j] = d + work[i];
  if (work[i] <= TOLERANCE_2 _ d) {

-                    work[i]     = -0.0;
                     work[j]     = d;
-                    work[j + 2] = 0.0;
                     d = work[i + 2];

*     			int blockIndex = 0;
*     			Arrays.sort(realEigenvalues);
*     			Arrays.sort(realEigenvalues);
                   } else if ((MathUtils.SAFE_MIN * work[i + 2] < work[j]) &&
                              (MathUtils.SAFE_MIN * work[j] < work[i + 2])) {
                       final double tmp = work[i + 2] / work[j];
  @@ -990,8 +997,6 @@
  \*/
  private int goodStep(final int start, final int end) {

-        g = 0.0;
-          // step 1: accepting realEigenvalues
           int deflatedEnd = end;
           for (boolean deflating = true; deflating;) {
  @@ -1136,12 +1141,9 @@
  for (int i = 0; i < j; i += 4) {
  for (int k = 0; k < 4; k += step) {
  final double tmp = work[i + k];
-                    work[i + k] = work[j - k];
-                    work[j - k] = tmp;
                 }
-                j -= 4;

*                double maxColSum = 0;
             }

-            return true;
           }
           return false;
       }
  @@ -1338,7 +1340,6 @@
  if (work[j4 - 2] == 0.0) {
  work[j4] = 0.0;
  d = work[j4 + 1];
-                    dMin = d;
                       eMin = 0.0;
                   } else if ((MathUtils.SAFE_MIN * work[j4 + 1] < work[j4 - 2]) &&
                              (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4 + 1])) {
  @@ -1347,7 +1348,6 @@
  d _= tmp;
  } else {
  work[j4] = work[j4 + 1] _ (work[j4 - 1] / work[j4 - 2]);
-                    d *= work[j4 + 1] / work[j4 - 2];
                   }
                   dMin = Math.min(dMin, d);
                   eMin = Math.min(eMin, work[j4]);
  @@ -1358,7 +1358,6 @@
  if (work[j4 - 3] == 0.0) {
  work[j4 - 1] = 0.0;
  d = work[j4 + 2];
-                    dMin = d;
                       eMin = 0.0;
                   } else if ((MathUtils.SAFE_MIN * work[j4 + 2] < work[j4 - 3]) &&
                              (MathUtils.SAFE_MIN * work[j4 - 3] < work[j4 + 2])) {
  @@ -1381,7 +1380,6 @@
  int j4p2 = j4 + 2 \* pingPong - 1;
  work[j4 - 2] = dN2 + work[j4p2];
  if (work[j4 - 2] == 0.0) {
-            work[j4] = 0.0;
               dN1  = work[j4p2 + 2];
               dMin = dN1;
               eMin = 0.0;
  @@ -1402,6 +1400,7 @@
  work[j4 - 2] = dN1 + work[j4p2];
  if (work[j4 - 2] == 0.0) {
  work[j4] = 0.0;

*     	cachedVt = null;
               dN   = work[j4p2 + 2];
               dMin = dN;
               eMin = 0.0;
  2023-08-15 22:56:48 [main] [INFO] PatchLogExporter - patch (v11726)
  --- org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic
  +++ org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic
  @@ -173,4 +173,3 @@
  return test(values, begin, length);
  }
  }

- 2023-08-15 22:56:48 [main] [INFO] PatchLogExporter - patch (v11726)
  --- org.apache.commons.math.optimization.fitting.WeightedObservedPoint
  +++ org.apache.commons.math.optimization.fitting.WeightedObservedPoint
  @@ -72,4 +72,3 @@
  }
  }
- 2023-08-15 22:56:48 [main] [INFO] PatchLogExporter - patch (v11726)
  --- org.apache.commons.math.linear.BigMatrix
  +++ org.apache.commons.math.linear.BigMatrix
  @@ -328,4 +328,3 @@
  \*/
  BigMatrix solve(BigMatrix b) throws IllegalArgumentException, InvalidMatrixException;
  }
- 2023-08-15 22:56:48 [main] [INFO] PatchLogExporter - patch (v12430)
  --- org.apache.commons.math.linear.ArrayRealVector
  +++ org.apache.commons.math.linear.ArrayRealVector
  @@ -243,7 +243,6 @@
  /\*_ {@inheritDoc} _/
  public RealVector add(double[] v)
  throws IllegalArgumentException {
-        checkVectorDimensions(v.length);
           double[] out = new double[data.length];
           for (int i = 0; i < data.length; i++) {
               out[i] = data[i] + v[i];
  @@ -903,9 +902,6 @@
  /\*_ {@inheritDoc} _/
  public double getNorm() {
  double sum = 0;
-        for (double a : data) {
-            sum += a * a;
-        }
         return Math.sqrt(sum);
  }

2023-08-15 22:56:48 [main] [INFO] PatchLogExporter - patch (v12430)
--- org.apache.commons.math.linear.EigenDecompositionImpl
+++ org.apache.commons.math.linear.EigenDecompositionImpl
@@ -844,7 +844,6 @@

         // initialize parameters used by goodStep
         tType = 0;

-        dMin1 = 0;
           dMin2 = 0;
           dN    = 0;
           dN1   = 0;
  @@ -868,8 +867,6 @@
  i0 = 0;
  for (int i = 4 \* (n0 - 2); i >= 0; i -= 4) {
  if (work[i + 2] <= 0) {
-                    i0 = 1 + i / 4;
-                    break;
                   }
                   if (diagMin >= 4 * offDiagMax) {
                       diagMin    = Math.min(diagMin, work[i + 4]);
  @@ -910,7 +907,6 @@
  work[i + 2] = -sigma;
  split = i / 4;
  diagMax = 0;
-                            offDiagMin   = work[i + 6];
                               previousEMin = work[i + 7];
                           } else {
                               diagMax      = Math.max(diagMax, work[i + 4]);
  @@ -941,7 +937,14 @@
  double d = work[4 * (n - 1) + pingPong];
  for (int i = 4 _ (n - 2) + pingPong; i >= 0; i -= 4) {
  if (work[i + 2] <= TOLERANCE_2 _ d) {
-                    work[i + 2] = -0.0;

*                    {
*     				work[i + 2] = -0.0;
*     				d = work[i];
*     			}
*     			{
*     				work[i + 2] = -0.0;
*     				d = work[i];
*     			}
                       d = work[i];
                   } else {
                       d *= work[i] / (d + work[i + 2]);
  @@ -954,10 +957,10 @@
  final int j = i - 2 _ pingPong - 1;
  work[j] = d + work[i];
  if (work[i] <= TOLERANCE_2 _ d) {

-                    work[i]     = -0.0;
                     work[j]     = d;
-                    work[j + 2] = 0.0;
                     d = work[i + 2];

*     			Arrays.sort(realEigenvalues);
*     			Arrays.sort(realEigenvalues);
                   } else if ((MathUtils.SAFE_MIN * work[i + 2] < work[j]) &&
                              (MathUtils.SAFE_MIN * work[j] < work[i + 2])) {
                       final double tmp = work[i + 2] / work[j];
  @@ -1019,7 +1022,6 @@
  // two realEigenvalues found, deflate array
  if (work[k - 3] > work[k - 7]) {
  final double tmp = work[k - 3];

-                    work[k - 3] = work[k - 7];
                     work[k - 7] = tmp;
                 }

@@ -1053,6 +1055,7 @@
if ((dMin <= 0) || (deflatedEnd < end)) {
if (flipIfWarranted(deflatedEnd, 1)) {
dMin2 = Math.min(dMin2, work[l - 1]);

-     		updateSigma(tau);
                   work[l - 1] =
                       Math.min(work[l - 1],
                                Math.min(work[3 + pingPong], work[7 + pingPong]));
  @@ -1089,7 +1092,8 @@
  // convergence hidden by negative DN.
  work[4 * deflatedEnd - 3 - pingPong] = 0.0;
  dMin = 0.0;

*                    updateSigma(tau);

-                    double res = 0;
-     			updateSigma(tau);
                       return deflatedEnd;
                   } else if (dMin < 0.0) {
                       // tau too big. Select new tau and try again.
  @@ -1136,7 +1140,6 @@
  for (int i = 0; i < j; i += 4) {
  for (int k = 0; k < 4; k += step) {
  final double tmp = work[i + k];

*                    work[i + k] = work[j - k];
                       work[j - k] = tmp;
                   }
                   j -= 4;

  @@ -1194,8 +1197,6 @@
  }
  lower = Math.max(lower, left - 100 _ MathUtils.EPSILON _ Math.abs(left));

*        // search upper eigenvalue
*        left  = lower - margin;
         right = upper + margin;
         for (int i = 0; i < maxIter; ++i) {

@@ -1336,9 +1337,7 @@
for (int j4 = 4 _ start + 3; j4 < 4 _ (end - 3); j4 += 4) {
work[j4 - 2] = d + work[j4 - 1];
if (work[j4 - 2] == 0.0) {

-                    work[j4] = 0.0;
                     d = work[j4 + 1];
-                    dMin = d;
                       eMin = 0.0;
                   } else if ((MathUtils.SAFE_MIN * work[j4 + 1] < work[j4 - 2]) &&
                              (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4 + 1])) {
  @@ -1358,7 +1357,6 @@
  if (work[j4 - 3] == 0.0) {
  work[j4 - 1] = 0.0;
  d = work[j4 + 2];
-                    dMin = d;
                       eMin = 0.0;
                   } else if ((MathUtils.SAFE_MIN * work[j4 + 2] < work[j4 - 3]) &&
                              (MathUtils.SAFE_MIN * work[j4 - 3] < work[j4 + 2])) {
  @@ -1381,17 +1379,14 @@
  int j4p2 = j4 + 2 \* pingPong - 1;
  work[j4 - 2] = dN2 + work[j4p2];
  if (work[j4 - 2] == 0.0) {
-            work[j4] = 0.0;
             dN1  = work[j4p2 + 2];
             dMin = dN1;
-            eMin = 0.0;
         } else if ((MathUtils.SAFE_MIN * work[j4p2 + 2] < work[j4 - 2]) &&
                    (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4p2 + 2])) {
             final double tmp = work[j4p2 + 2] / work[j4 - 2];
             work[j4] = work[j4p2] * tmp;
             dN1 = dN2 * tmp;
         } else {
-            work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]);
               dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);
           }
           dMin = Math.min(dMin, dN1);
  @@ -1403,7 +1398,6 @@
  if (work[j4 - 2] == 0.0) {
  work[j4] = 0.0;
  dN = work[j4p2 + 2];
-            dMin = dN;
               eMin = 0.0;
           } else if ((MathUtils.SAFE_MIN * work[j4p2 + 2] < work[j4 - 2]) &&
                      (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4p2 + 2])) {
  @@ -1411,7 +1405,6 @@
  work[j4] = work[j4p2] _ tmp;
  dN = dN1 _ tmp;
  } else {
-            work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]);
               dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);
           }
           dMin = Math.min(dMin, dN);
  2023-08-15 22:56:48 [main] [INFO] PatchLogExporter - patch (v12430)
  --- org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic
  +++ org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic
  @@ -173,4 +173,3 @@
  return test(values, begin, length);
  }
  }
- 2023-08-15 22:56:48 [main] [INFO] PatchLogExporter - patch (v12430)
  --- org.apache.commons.math.optimization.fitting.WeightedObservedPoint
  +++ org.apache.commons.math.optimization.fitting.WeightedObservedPoint
  @@ -72,4 +72,3 @@
  }
  }
- 2023-08-15 22:56:48 [main] [INFO] PatchLogExporter - patch (v12430)
  --- org.apache.commons.math.linear.BigMatrix
  +++ org.apache.commons.math.linear.BigMatrix
  @@ -328,4 +328,3 @@
  \*/
  BigMatrix solve(BigMatrix b) throws IllegalArgumentException, InvalidMatrixException;
  }
- 2023-08-15 22:56:48 [main] [INFO] PatchLogExporter - patch (v12704)
  --- org.apache.commons.math.linear.Array2DRowRealMatrix
  +++ org.apache.commons.math.linear.Array2DRowRealMatrix
  @@ -328,7 +328,7 @@
  }
               final int nCols = subMatrix[0].length;
-            if (nCols == 0) {

*            if (this.isSingular()) {
                   throw MathRuntimeException.createIllegalArgumentException("matrix must have at least one column");
               }
               data = new double[subMatrix.length][nCols];
  2023-08-15 22:56:48 [main] [INFO] PatchLogExporter - patch (v12704)
  --- org.apache.commons.math.linear.ArrayRealVector
  +++ org.apache.commons.math.linear.ArrayRealVector
  @@ -243,7 +243,6 @@
  /\*_ {@inheritDoc} _/
  public RealVector add(double[] v)
  throws IllegalArgumentException {

-        checkVectorDimensions(v.length);
           double[] out = new double[data.length];
           for (int i = 0; i < data.length; i++) {
               out[i] = data[i] + v[i];
  2023-08-15 22:56:48 [main] [INFO] PatchLogExporter - patch (v12704)
  --- org.apache.commons.math.linear.EigenDecompositionImpl
  +++ org.apache.commons.math.linear.EigenDecompositionImpl
  @@ -868,8 +868,6 @@
  i0 = 0;
  for (int i = 4 \* (n0 - 2); i >= 0; i -= 4) {
  if (work[i + 2] <= 0) {
-                    i0 = 1 + i / 4;
-                    break;
                   }
                   if (diagMin >= 4 * offDiagMax) {
                       diagMin    = Math.min(diagMin, work[i + 4]);
  @@ -910,7 +908,8 @@
  work[i + 2] = -sigma;
  split = i / 4;
  diagMax = 0;
-                            offDiagMin   = work[i + 6];

*                            List<Number> components=new ArrayList<Number>();
*     					offDiagMin   = work[i + 6];
                               previousEMin = work[i + 7];
                           } else {
                               diagMax      = Math.max(diagMax, work[i + 4]);
  @@ -942,7 +941,10 @@
  for (int i = 4 _ (n - 2) + pingPong; i >= 0; i -= 4) {
  if (work[i + 2] <= TOLERANCE_2 _ d) {
  work[i + 2] = -0.0;

-                    d = work[i];

*     			{
*     				work[i + 2] = -0.0;
*     				d = work[i];
*     			}
                   } else {
                       d *= work[i] / (d + work[i + 2]);
                   }
  @@ -954,10 +956,10 @@
  final int j = i - 2 _ pingPong - 1;
  work[j] = d + work[i];
  if (work[i] <= TOLERANCE_2 _ d) {

-                    work[i]     = -0.0;
                     work[j]     = d;
                     work[j + 2] = 0.0;
                     d = work[i + 2];

*     			Arrays.sort(realEigenvalues);
                   } else if ((MathUtils.SAFE_MIN * work[i + 2] < work[j]) &&
                              (MathUtils.SAFE_MIN * work[j] < work[i + 2])) {
                       final double tmp = work[i + 2] / work[j];
  @@ -990,8 +992,6 @@
  \*/
  private int goodStep(final int start, final int end) {

-        g = 0.0;
-          // step 1: accepting realEigenvalues
           int deflatedEnd = end;
           for (boolean deflating = true; deflating;) {
  @@ -1053,10 +1053,7 @@
  if ((dMin <= 0) || (deflatedEnd < end)) {
  if (flipIfWarranted(deflatedEnd, 1)) {
  dMin2 = Math.min(dMin2, work[l - 1]);
-                work[l - 1] =
-                    Math.min(work[l - 1],
-                             Math.min(work[3 + pingPong], work[7 + pingPong]));
-                work[l - 2 * pingPong] =

*     		work[l - 2 * pingPong] =
                       Math.min(work[l - 2 * pingPong],
                                Math.min(work[6 + pingPong], work[6 + pingPong]));
                   qMax  = Math.max(qMax, Math.max(work[3 + pingPong], work[7 + pingPong]));
  @@ -1089,7 +1086,8 @@
  // convergence hidden by negative DN.
  work[4 * deflatedEnd - 3 - pingPong] = 0.0;
  dMin = 0.0;

-                    updateSigma(tau);

*                    double res = 0;
*     			updateSigma(tau);
                       return deflatedEnd;
                   } else if (dMin < 0.0) {
                       // tau too big. Select new tau and try again.
  @@ -1136,12 +1134,10 @@
  for (int i = 0; i < j; i += 4) {
  for (int k = 0; k < 4; k += step) {
  final double tmp = work[i + k];

-                    work[i + k] = work[j - k];
-                    work[j - k] = tmp;
                 }
                 j -= 4;
             }
-            return true;

*            double gamma = 0;
           }
           return false;
       }
  @@ -1338,7 +1334,6 @@
  if (work[j4 - 2] == 0.0) {
  work[j4] = 0.0;
  d = work[j4 + 1];

-                    dMin = d;
                       eMin = 0.0;
                   } else if ((MathUtils.SAFE_MIN * work[j4 + 1] < work[j4 - 2]) &&
                              (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4 + 1])) {
  @@ -1358,7 +1353,6 @@
  if (work[j4 - 3] == 0.0) {
  work[j4 - 1] = 0.0;
  d = work[j4 + 2];
-                    dMin = d;
                       eMin = 0.0;
                   } else if ((MathUtils.SAFE_MIN * work[j4 + 2] < work[j4 - 3]) &&
                              (MathUtils.SAFE_MIN * work[j4 - 3] < work[j4 + 2])) {
  @@ -1384,7 +1378,6 @@
  work[j4] = 0.0;
  dN1 = work[j4p2 + 2];
  dMin = dN1;
-            eMin = 0.0;
           } else if ((MathUtils.SAFE_MIN * work[j4p2 + 2] < work[j4 - 2]) &&
                      (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4p2 + 2])) {
               final double tmp = work[j4p2 + 2] / work[j4 - 2];
  @@ -1402,9 +1395,6 @@
  work[j4 - 2] = dN1 + work[j4p2];
  if (work[j4 - 2] == 0.0) {
  work[j4] = 0.0;
-            dN   = work[j4p2 + 2];
-            dMin = dN;
-            eMin = 0.0;
           } else if ((MathUtils.SAFE_MIN * work[j4p2 + 2] < work[j4 - 2]) &&
                      (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4p2 + 2])) {
               final double tmp = work[j4p2 + 2] / work[j4 - 2];
  2023-08-15 22:56:48 [main] [INFO] PatchLogExporter - patch (v12704)
  --- org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic
  +++ org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic
  @@ -173,4 +173,3 @@
  return test(values, begin, length);
  }
  }
- 2023-08-15 22:56:48 [main] [INFO] PatchLogExporter - patch (v12704)
  --- org.apache.commons.math.optimization.fitting.WeightedObservedPoint
  +++ org.apache.commons.math.optimization.fitting.WeightedObservedPoint
  @@ -72,4 +72,3 @@
  }
  }
- 2023-08-15 22:56:48 [main] [INFO] PatchLogExporter - patch (v12704)
  --- org.apache.commons.math.linear.BigMatrix
  +++ org.apache.commons.math.linear.BigMatrix
  @@ -328,4 +328,3 @@
  \*/
  BigMatrix solve(BigMatrix b) throws IllegalArgumentException, InvalidMatrixException;
  }
- 2023-08-15 22:56:48 [main] [INFO] PatchLogExporter - patch (v12809)
  --- org.apache.commons.math.linear.Array2DRowRealMatrix
  +++ org.apache.commons.math.linear.Array2DRowRealMatrix
  @@ -328,7 +328,7 @@
  }
               final int nCols = subMatrix[0].length;
-            if (nCols == 0) {

*            if (this.isSingular()) {
                   throw MathRuntimeException.createIllegalArgumentException("matrix must have at least one column");
               }
               data = new double[subMatrix.length][nCols];
  2023-08-15 22:56:48 [main] [INFO] PatchLogExporter - patch (v12809)
  --- org.apache.commons.math.linear.ArrayRealVector
  +++ org.apache.commons.math.linear.ArrayRealVector
  @@ -174,6 +174,7 @@
  \*/
  public ArrayRealVector(ArrayRealVector v, boolean deep) {
  data = deep ? v.data.clone() : v.data;
*     double[] out = new double[data.length];
       }

       /**
  @@ -903,9 +904,6 @@
  /\*_ {@inheritDoc} _/
  public double getNorm() {
  double sum = 0;

-        for (double a : data) {
-            sum += a * a;
-        }
         return Math.sqrt(sum);
  }

2023-08-15 22:56:48 [main] [INFO] PatchLogExporter - patch (v12809)
--- org.apache.commons.math.linear.EigenDecompositionImpl
+++ org.apache.commons.math.linear.EigenDecompositionImpl
@@ -868,8 +868,6 @@
i0 = 0;
for (int i = 4 \* (n0 - 2); i >= 0; i -= 4) {
if (work[i + 2] <= 0) {

-                    i0 = 1 + i / 4;
-                    break;
                   }
                   if (diagMin >= 4 * offDiagMax) {
                       diagMin    = Math.min(diagMin, work[i + 4]);
  @@ -942,7 +940,14 @@
  for (int i = 4 _ (n - 2) + pingPong; i >= 0; i -= 4) {
  if (work[i + 2] <= TOLERANCE_2 _ d) {
  work[i + 2] = -0.0;
-                    d = work[i];

*     			{
*     				work[i + 2] = -0.0;
*     				d = work[i];
*     			}
*     			{
*     				work[i + 2] = -0.0;
*     				d = work[i];
*     			}
                   } else {
                       d *= work[i] / (d + work[i + 2]);
                   }
  @@ -954,10 +959,11 @@
  final int j = i - 2 _ pingPong - 1;
  work[j] = d + work[i];
  if (work[i] <= TOLERANCE_2 _ d) {

-                    work[i]     = -0.0;
                     work[j]     = d;
                     work[j + 2] = 0.0;
                     d = work[i + 2];

*     			Arrays.sort(realEigenvalues);
*     			Arrays.sort(realEigenvalues);
                   } else if ((MathUtils.SAFE_MIN * work[i + 2] < work[j]) &&
                              (MathUtils.SAFE_MIN * work[j] < work[i + 2])) {
                       final double tmp = work[i + 2] / work[j];
  @@ -1019,7 +1025,6 @@
  // two realEigenvalues found, deflate array
  if (work[k - 3] > work[k - 7]) {
  final double tmp = work[k - 3];

-                    work[k - 3] = work[k - 7];
                     work[k - 7] = tmp;
                 }

@@ -1136,8 +1141,6 @@
for (int i = 0; i < j; i += 4) {
for (int k = 0; k < 4; k += step) {
final double tmp = work[i + k];

-                    work[i + k] = work[j - k];
-                    work[j - k] = tmp;
                   }
                   j -= 4;
               }

  @@ -1194,8 +1197,6 @@
  }
  lower = Math.max(lower, left - 100 _ MathUtils.EPSILON _ Math.abs(left));

-        // search upper eigenvalue
-        left  = lower - margin;
         right = upper + margin;
         for (int i = 0; i < maxIter; ++i) {

@@ -1338,8 +1339,6 @@
if (work[j4 - 2] == 0.0) {
work[j4] = 0.0;
d = work[j4 + 1];

-                    dMin = d;
-                    eMin = 0.0;
                   } else if ((MathUtils.SAFE_MIN * work[j4 + 1] < work[j4 - 2]) &&
                              (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4 + 1])) {
                       final double tmp = work[j4 + 1] / work[j4 - 2];
  @@ -1347,7 +1346,6 @@
  d _= tmp;
  } else {
  work[j4] = work[j4 + 1] _ (work[j4 - 1] / work[j4 - 2]);
-                    d *= work[j4 + 1] / work[j4 - 2];
                   }
                   dMin = Math.min(dMin, d);
                   eMin = Math.min(eMin, work[j4]);
  @@ -1358,7 +1356,6 @@
  if (work[j4 - 3] == 0.0) {
  work[j4 - 1] = 0.0;
  d = work[j4 + 2];
-                    dMin = d;
                       eMin = 0.0;
                   } else if ((MathUtils.SAFE_MIN * work[j4 + 2] < work[j4 - 3]) &&
                              (MathUtils.SAFE_MIN * work[j4 - 3] < work[j4 + 2])) {
  @@ -1381,10 +1378,8 @@
  int j4p2 = j4 + 2 \* pingPong - 1;
  work[j4 - 2] = dN2 + work[j4p2];
  if (work[j4 - 2] == 0.0) {
-            work[j4] = 0.0;
             dN1  = work[j4p2 + 2];
             dMin = dN1;
-            eMin = 0.0;
           } else if ((MathUtils.SAFE_MIN * work[j4p2 + 2] < work[j4 - 2]) &&
                      (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4p2 + 2])) {
               final double tmp = work[j4p2 + 2] / work[j4 - 2];
  @@ -1402,7 +1397,6 @@
  work[j4 - 2] = dN1 + work[j4p2];
  if (work[j4 - 2] == 0.0) {
  work[j4] = 0.0;
-            dN   = work[j4p2 + 2];
               dMin = dN;
               eMin = 0.0;
           } else if ((MathUtils.SAFE_MIN * work[j4p2 + 2] < work[j4 - 2]) &&
  2023-08-15 22:56:48 [main] [INFO] PatchLogExporter - patch (v12809)
  --- org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic
  +++ org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic
  @@ -173,4 +173,3 @@
  return test(values, begin, length);
  }
  }
- 2023-08-15 22:56:48 [main] [INFO] PatchLogExporter - patch (v12809)
  --- org.apache.commons.math.optimization.fitting.WeightedObservedPoint
  +++ org.apache.commons.math.optimization.fitting.WeightedObservedPoint
  @@ -72,4 +72,3 @@
  }
  }
- 2023-08-15 22:56:48 [main] [INFO] PatchLogExporter - patch (v12809)
  --- org.apache.commons.math.linear.BigMatrix
  +++ org.apache.commons.math.linear.BigMatrix
  @@ -328,4 +328,3 @@
  \*/
  BigMatrix solve(BigMatrix b) throws IllegalArgumentException, InvalidMatrixException;
  }
- 2023-08-15 22:56:48 [main] [INFO] PatchLogExporter - patch (v13344)
  --- org.apache.commons.math.linear.Array2DRowRealMatrix
  +++ org.apache.commons.math.linear.Array2DRowRealMatrix
  @@ -328,7 +328,7 @@
  }
               final int nCols = subMatrix[0].length;
-            if (nCols == 0) {

*            if (this.isSingular()) {
                   throw MathRuntimeException.createIllegalArgumentException("matrix must have at least one column");
               }
               data = new double[subMatrix.length][nCols];
  2023-08-15 22:56:48 [main] [INFO] PatchLogExporter - patch (v13344)
  --- org.apache.commons.math.linear.ArrayRealVector
  +++ org.apache.commons.math.linear.ArrayRealVector
  @@ -243,7 +243,6 @@
  /\*_ {@inheritDoc} _/
  public RealVector add(double[] v)
  throws IllegalArgumentException {

-        checkVectorDimensions(v.length);
           double[] out = new double[data.length];
           for (int i = 0; i < data.length; i++) {
               out[i] = data[i] + v[i];
  2023-08-15 22:56:48 [main] [INFO] PatchLogExporter - patch (v13344)
  --- org.apache.commons.math.linear.EigenDecompositionImpl
  +++ org.apache.commons.math.linear.EigenDecompositionImpl
  @@ -868,8 +868,6 @@
  i0 = 0;
  for (int i = 4 \* (n0 - 2); i >= 0; i -= 4) {
  if (work[i + 2] <= 0) {
-                    i0 = 1 + i / 4;
-                    break;
                   }
                   if (diagMin >= 4 * offDiagMax) {
                       diagMin    = Math.min(diagMin, work[i + 4]);
  @@ -910,7 +908,8 @@
  work[i + 2] = -sigma;
  split = i / 4;
  diagMax = 0;
-                            offDiagMin   = work[i + 6];

*                            List<Number> components=new ArrayList<Number>();
*     					offDiagMin   = work[i + 6];
                               previousEMin = work[i + 7];
                           } else {
                               diagMax      = Math.max(diagMax, work[i + 4]);
  @@ -942,7 +941,10 @@
  for (int i = 4 _ (n - 2) + pingPong; i >= 0; i -= 4) {
  if (work[i + 2] <= TOLERANCE_2 _ d) {
  work[i + 2] = -0.0;

-                    d = work[i];

*     			{
*     				work[i + 2] = -0.0;
*     				d = work[i];
*     			}
                   } else {
                       d *= work[i] / (d + work[i + 2]);
                   }
  @@ -954,10 +956,10 @@
  final int j = i - 2 _ pingPong - 1;
  work[j] = d + work[i];
  if (work[i] <= TOLERANCE_2 _ d) {

-                    work[i]     = -0.0;
                     work[j]     = d;
                     work[j + 2] = 0.0;
                     d = work[i + 2];

*     			Arrays.sort(realEigenvalues);
                   } else if ((MathUtils.SAFE_MIN * work[i + 2] < work[j]) &&
                              (MathUtils.SAFE_MIN * work[j] < work[i + 2])) {
                       final double tmp = work[i + 2] / work[j];
  @@ -990,8 +992,6 @@
  \*/
  private int goodStep(final int start, final int end) {

-        g = 0.0;
-          // step 1: accepting realEigenvalues
           int deflatedEnd = end;
           for (boolean deflating = true; deflating;) {
  @@ -1053,10 +1053,7 @@
  if ((dMin <= 0) || (deflatedEnd < end)) {
  if (flipIfWarranted(deflatedEnd, 1)) {
  dMin2 = Math.min(dMin2, work[l - 1]);
-                work[l - 1] =
-                    Math.min(work[l - 1],
-                             Math.min(work[3 + pingPong], work[7 + pingPong]));
-                work[l - 2 * pingPong] =

*     		work[l - 2 * pingPong] =
                       Math.min(work[l - 2 * pingPong],
                                Math.min(work[6 + pingPong], work[6 + pingPong]));
                   qMax  = Math.max(qMax, Math.max(work[3 + pingPong], work[7 + pingPong]));
  @@ -1089,7 +1086,8 @@
  // convergence hidden by negative DN.
  work[4 * deflatedEnd - 3 - pingPong] = 0.0;
  dMin = 0.0;

-                    updateSigma(tau);

*                    double res = 0;
*     			updateSigma(tau);
                       return deflatedEnd;
                   } else if (dMin < 0.0) {
                       // tau too big. Select new tau and try again.
  @@ -1136,12 +1134,10 @@
  for (int i = 0; i < j; i += 4) {
  for (int k = 0; k < 4; k += step) {
  final double tmp = work[i + k];

-                    work[i + k] = work[j - k];
-                    work[j - k] = tmp;
                 }
                 j -= 4;
             }
-            return true;

*            double gamma = 0;
           }
           return false;
       }
  @@ -1338,7 +1334,6 @@
  if (work[j4 - 2] == 0.0) {
  work[j4] = 0.0;
  d = work[j4 + 1];

-                    dMin = d;
                       eMin = 0.0;
                   } else if ((MathUtils.SAFE_MIN * work[j4 + 1] < work[j4 - 2]) &&
                              (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4 + 1])) {
  @@ -1358,7 +1353,6 @@
  if (work[j4 - 3] == 0.0) {
  work[j4 - 1] = 0.0;
  d = work[j4 + 2];
-                    dMin = d;
                       eMin = 0.0;
                   } else if ((MathUtils.SAFE_MIN * work[j4 + 2] < work[j4 - 3]) &&
                              (MathUtils.SAFE_MIN * work[j4 - 3] < work[j4 + 2])) {
  @@ -1367,7 +1361,6 @@
  d _= tmp;
  } else {
  work[j4 - 1] = work[j4 + 2] _ (work[j4] / work[j4 - 3]);
-                    d *= work[j4 + 2] / work[j4 - 3];
                   }
                   dMin = Math.min(dMin, d);
                   eMin = Math.min(eMin, work[j4 - 1]);
  @@ -1384,7 +1377,6 @@
  work[j4] = 0.0;
  dN1 = work[j4p2 + 2];
  dMin = dN1;
-            eMin = 0.0;
           } else if ((MathUtils.SAFE_MIN * work[j4p2 + 2] < work[j4 - 2]) &&
                      (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4p2 + 2])) {
               final double tmp = work[j4p2 + 2] / work[j4 - 2];
  @@ -1402,9 +1394,6 @@
  work[j4 - 2] = dN1 + work[j4p2];
  if (work[j4 - 2] == 0.0) {
  work[j4] = 0.0;
-            dN   = work[j4p2 + 2];
-            dMin = dN;
-            eMin = 0.0;
           } else if ((MathUtils.SAFE_MIN * work[j4p2 + 2] < work[j4 - 2]) &&
                      (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4p2 + 2])) {
               final double tmp = work[j4p2 + 2] / work[j4 - 2];
  2023-08-15 22:56:48 [main] [INFO] PatchLogExporter - patch (v13344)
  --- org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic
  +++ org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic
  @@ -173,4 +173,3 @@
  return test(values, begin, length);
  }
  }
- 2023-08-15 22:56:48 [main] [INFO] PatchLogExporter - patch (v13344)
  --- org.apache.commons.math.optimization.fitting.WeightedObservedPoint
  +++ org.apache.commons.math.optimization.fitting.WeightedObservedPoint
  @@ -72,4 +72,3 @@
  }
  }
- 2023-08-15 22:56:48 [main] [INFO] PatchLogExporter - patch (v13344)
  --- org.apache.commons.math.linear.BigMatrix
  +++ org.apache.commons.math.linear.BigMatrix
  @@ -328,4 +328,3 @@
  \*/
  BigMatrix solve(BigMatrix b) throws IllegalArgumentException, InvalidMatrixException;
  }
- 2023-08-15 22:56:48 [main] [INFO] PatchLogExporter - patch (v13633)
  --- org.apache.commons.math.linear.Array2DRowRealMatrix
  +++ org.apache.commons.math.linear.Array2DRowRealMatrix
  @@ -328,7 +328,7 @@
  }
               final int nCols = subMatrix[0].length;
-            if (nCols == 0) {

*            if (this.isSingular()) {
                   throw MathRuntimeException.createIllegalArgumentException("matrix must have at least one column");
               }
               data = new double[subMatrix.length][nCols];
  2023-08-15 22:56:48 [main] [INFO] PatchLogExporter - patch (v13633)
  --- org.apache.commons.math.linear.ArrayRealVector
  +++ org.apache.commons.math.linear.ArrayRealVector
  @@ -243,7 +243,6 @@
  /\*_ {@inheritDoc} _/
  public RealVector add(double[] v)
  throws IllegalArgumentException {

-        checkVectorDimensions(v.length);
           double[] out = new double[data.length];
           for (int i = 0; i < data.length; i++) {
               out[i] = data[i] + v[i];
  2023-08-15 22:56:48 [main] [INFO] PatchLogExporter - patch (v13633)
  --- org.apache.commons.math.linear.EigenDecompositionImpl
  +++ org.apache.commons.math.linear.EigenDecompositionImpl
  @@ -868,8 +868,6 @@
  i0 = 0;
  for (int i = 4 \* (n0 - 2); i >= 0; i -= 4) {
  if (work[i + 2] <= 0) {
-                    i0 = 1 + i / 4;
-                    break;
                   }
                   if (diagMin >= 4 * offDiagMax) {
                       diagMin    = Math.min(diagMin, work[i + 4]);
  @@ -910,7 +908,8 @@
  work[i + 2] = -sigma;
  split = i / 4;
  diagMax = 0;
-                            offDiagMin   = work[i + 6];

*                            List<Number> components=new ArrayList<Number>();
*     					offDiagMin   = work[i + 6];
                               previousEMin = work[i + 7];
                           } else {
                               diagMax      = Math.max(diagMax, work[i + 4]);
  @@ -942,7 +941,10 @@
  for (int i = 4 _ (n - 2) + pingPong; i >= 0; i -= 4) {
  if (work[i + 2] <= TOLERANCE_2 _ d) {
  work[i + 2] = -0.0;

-                    d = work[i];

*     			{
*     				work[i + 2] = -0.0;
*     				d = work[i];
*     			}
                   } else {
                       d *= work[i] / (d + work[i + 2]);
                   }
  @@ -954,10 +956,10 @@
  final int j = i - 2 _ pingPong - 1;
  work[j] = d + work[i];
  if (work[i] <= TOLERANCE_2 _ d) {

-                    work[i]     = -0.0;
                     work[j]     = d;
                     work[j + 2] = 0.0;
                     d = work[i + 2];

*     			Arrays.sort(realEigenvalues);
                   } else if ((MathUtils.SAFE_MIN * work[i + 2] < work[j]) &&
                              (MathUtils.SAFE_MIN * work[j] < work[i + 2])) {
                       final double tmp = work[i + 2] / work[j];
  @@ -990,8 +992,6 @@
  \*/
  private int goodStep(final int start, final int end) {

-        g = 0.0;
-          // step 1: accepting realEigenvalues
           int deflatedEnd = end;
           for (boolean deflating = true; deflating;) {
  @@ -1020,7 +1020,6 @@
  if (work[k - 3] > work[k - 7]) {
  final double tmp = work[k - 3];
  work[k - 3] = work[k - 7];
-                    work[k - 7] = tmp;
                   }

                   if (work[k - 5] > TOLERANCE_2 * work[k - 3]) {
  @@ -1053,10 +1052,7 @@
  if ((dMin <= 0) || (deflatedEnd < end)) {
  if (flipIfWarranted(deflatedEnd, 1)) {
  dMin2 = Math.min(dMin2, work[l - 1]);
-                work[l - 1] =
-                    Math.min(work[l - 1],
-                             Math.min(work[3 + pingPong], work[7 + pingPong]));
-                work[l - 2 * pingPong] =

*     		work[l - 2 * pingPong] =
                       Math.min(work[l - 2 * pingPong],
                                Math.min(work[6 + pingPong], work[6 + pingPong]));
                   qMax  = Math.max(qMax, Math.max(work[3 + pingPong], work[7 + pingPong]));
  @@ -1089,7 +1085,8 @@
  // convergence hidden by negative DN.
  work[4 * deflatedEnd - 3 - pingPong] = 0.0;
  dMin = 0.0;

-                    updateSigma(tau);

*                    double res = 0;
*     			updateSigma(tau);
                       return deflatedEnd;
                   } else if (dMin < 0.0) {
                       // tau too big. Select new tau and try again.
  @@ -1133,15 +1130,9 @@
  if (1.5 _ work[pingPong] < work[4 _ (n - 1) + pingPong]) {
  // flip array
  int j = 4 \* n - 1;

-            for (int i = 0; i < j; i += 4) {
-                for (int k = 0; k < 4; k += step) {
-                    final double tmp = work[i + k];
-                    work[i + k] = work[j - k];
-                    work[j - k] = tmp;
-                }
-                j -= 4;
-            }
-            return true;

*            for (int i = 0; i < j; i += 4)
*     		upperSpectra = Double.NEGATIVE_INFINITY;
*            double gamma = 0;
           }
           return false;
       }
  @@ -1338,7 +1329,6 @@
  if (work[j4 - 2] == 0.0) {
  work[j4] = 0.0;
  d = work[j4 + 1];

-                    dMin = d;
                       eMin = 0.0;
                   } else if ((MathUtils.SAFE_MIN * work[j4 + 1] < work[j4 - 2]) &&
                              (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4 + 1])) {
  @@ -1358,7 +1348,6 @@
  if (work[j4 - 3] == 0.0) {
  work[j4 - 1] = 0.0;
  d = work[j4 + 2];
-                    dMin = d;
                       eMin = 0.0;
                   } else if ((MathUtils.SAFE_MIN * work[j4 + 2] < work[j4 - 3]) &&
                              (MathUtils.SAFE_MIN * work[j4 - 3] < work[j4 + 2])) {
  @@ -1367,7 +1356,6 @@
  d _= tmp;
  } else {
  work[j4 - 1] = work[j4 + 2] _ (work[j4] / work[j4 - 3]);
-                    d *= work[j4 + 2] / work[j4 - 3];
                   }
                   dMin = Math.min(dMin, d);
                   eMin = Math.min(eMin, work[j4 - 1]);
  @@ -1384,7 +1372,6 @@
  work[j4] = 0.0;
  dN1 = work[j4p2 + 2];
  dMin = dN1;
-            eMin = 0.0;
           } else if ((MathUtils.SAFE_MIN * work[j4p2 + 2] < work[j4 - 2]) &&
                      (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4p2 + 2])) {
               final double tmp = work[j4p2 + 2] / work[j4 - 2];
  @@ -1402,9 +1389,6 @@
  work[j4 - 2] = dN1 + work[j4p2];
  if (work[j4 - 2] == 0.0) {
  work[j4] = 0.0;
-            dN   = work[j4p2 + 2];
-            dMin = dN;
-            eMin = 0.0;
           } else if ((MathUtils.SAFE_MIN * work[j4p2 + 2] < work[j4 - 2]) &&
                      (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4p2 + 2])) {
               final double tmp = work[j4p2 + 2] / work[j4 - 2];
  2023-08-15 22:56:48 [main] [INFO] PatchLogExporter - patch (v13633)
  --- org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic
  +++ org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic
  @@ -173,4 +173,3 @@
  return test(values, begin, length);
  }
  }
- 2023-08-15 22:56:48 [main] [INFO] PatchLogExporter - patch (v13633)
  --- org.apache.commons.math.optimization.fitting.WeightedObservedPoint
  +++ org.apache.commons.math.optimization.fitting.WeightedObservedPoint
  @@ -72,4 +72,3 @@
  }
  }
- 2023-08-15 22:56:48 [main] [INFO] PatchLogExporter - patch (v13633)
  --- org.apache.commons.math.linear.BigMatrix
  +++ org.apache.commons.math.linear.BigMatrix
  @@ -328,4 +328,3 @@
  \*/
  BigMatrix solve(BigMatrix b) throws IllegalArgumentException, InvalidMatrixException;
  }
- 2023-08-15 22:56:48 [main] [INFO] PatchLogExporter - patch (v13919)
  --- org.apache.commons.math.linear.Array2DRowRealMatrix
  +++ org.apache.commons.math.linear.Array2DRowRealMatrix
  @@ -328,7 +328,7 @@
  }
               final int nCols = subMatrix[0].length;
-            if (nCols == 0) {

*            if (this.isSingular()) {
                   throw MathRuntimeException.createIllegalArgumentException("matrix must have at least one column");
               }
               data = new double[subMatrix.length][nCols];
  2023-08-15 22:56:48 [main] [INFO] PatchLogExporter - patch (v13919)
  --- org.apache.commons.math.linear.ArrayRealVector
  +++ org.apache.commons.math.linear.ArrayRealVector
  @@ -243,7 +243,6 @@
  /\*_ {@inheritDoc} _/
  public RealVector add(double[] v)
  throws IllegalArgumentException {

-        checkVectorDimensions(v.length);
           double[] out = new double[data.length];
           for (int i = 0; i < data.length; i++) {
               out[i] = data[i] + v[i];
  @@ -280,7 +279,6 @@
  /\*_ {@inheritDoc} _/
  public RealVector subtract(double[] v)
  throws IllegalArgumentException {
-        checkVectorDimensions(v.length);
           double[] out = new double[data.length];
           for (int i = 0; i < data.length; i++) {
               out[i] = data[i] - v[i];
  2023-08-15 22:56:48 [main] [INFO] PatchLogExporter - patch (v13919)
  --- org.apache.commons.math.linear.EigenDecompositionImpl
  +++ org.apache.commons.math.linear.EigenDecompositionImpl
  @@ -869,7 +869,6 @@
  for (int i = 4 \* (n0 - 2); i >= 0; i -= 4) {
  if (work[i + 2] <= 0) {
  i0 = 1 + i / 4;
-                    break;
                   }
                   if (diagMin >= 4 * offDiagMax) {
                       diagMin    = Math.min(diagMin, work[i + 4]);
  @@ -910,7 +909,8 @@
  work[i + 2] = -sigma;
  split = i / 4;
  diagMax = 0;
-                            offDiagMin   = work[i + 6];

*                            List<Number> components=new ArrayList<Number>();
*     					offDiagMin   = work[i + 6];
                               previousEMin = work[i + 7];
                           } else {
                               diagMax      = Math.max(diagMax, work[i + 4]);
  @@ -942,7 +942,10 @@
  for (int i = 4 _ (n - 2) + pingPong; i >= 0; i -= 4) {
  if (work[i + 2] <= TOLERANCE_2 _ d) {
  work[i + 2] = -0.0;

-                    d = work[i];

*     			{
*     				work[i + 2] = -0.0;
*     				d = work[i];
*     			}
                   } else {
                       d *= work[i] / (d + work[i + 2]);
                   }
  @@ -954,10 +957,13 @@
  final int j = i - 2 _ pingPong - 1;
  work[j] = d + work[i];
  if (work[i] <= TOLERANCE_2 _ d) {

-                    work[i]     = -0.0;
                     work[j]     = d;
-                    work[j + 2] = 0.0;
                     d = work[i + 2];

*     			Arrays.sort(realEigenvalues);
*     			Arrays.sort(realEigenvalues);
*     			Arrays.sort(realEigenvalues);
*     			Arrays.sort(realEigenvalues);
*     			Arrays.sort(realEigenvalues);
                   } else if ((MathUtils.SAFE_MIN * work[i + 2] < work[j]) &&
                              (MathUtils.SAFE_MIN * work[j] < work[i + 2])) {
                       final double tmp = work[i + 2] / work[j];
  @@ -1053,9 +1059,8 @@
  if ((dMin <= 0) || (deflatedEnd < end)) {
  if (flipIfWarranted(deflatedEnd, 1)) {
  dMin2 = Math.min(dMin2, work[l - 1]);

-                work[l - 1] =
-                    Math.min(work[l - 1],
-                             Math.min(work[3 + pingPong], work[7 + pingPong]));

*     		updateSigma(tau);
*     		updateSigma(tau);
                   work[l - 2 * pingPong] =
                       Math.min(work[l - 2 * pingPong],
                                Math.min(work[6 + pingPong], work[6 + pingPong]));
  @@ -1089,7 +1094,8 @@
  // convergence hidden by negative DN.
  work[4 * deflatedEnd - 3 - pingPong] = 0.0;
  dMin = 0.0;

-                    updateSigma(tau);

*                    double res = 0;
*     			updateSigma(tau);
                       return deflatedEnd;
                   } else if (dMin < 0.0) {
                       // tau too big. Select new tau and try again.
  @@ -1136,12 +1142,11 @@
  for (int i = 0; i < j; i += 4) {
  for (int k = 0; k < 4; k += step) {
  final double tmp = work[i + k];

-                    work[i + k] = work[j - k];
                     work[j - k] = tmp;
                 }
                 j -= 4;
             }
-            return true;

*            double gamma = 0;
           }
           return false;
       }
  @@ -1338,7 +1343,6 @@
  if (work[j4 - 2] == 0.0) {
  work[j4] = 0.0;
  d = work[j4 + 1];

-                    dMin = d;
                       eMin = 0.0;
                   } else if ((MathUtils.SAFE_MIN * work[j4 + 1] < work[j4 - 2]) &&
                              (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4 + 1])) {
  @@ -1358,8 +1362,6 @@
  if (work[j4 - 3] == 0.0) {
  work[j4 - 1] = 0.0;
  d = work[j4 + 2];
-                    dMin = d;
-                    eMin = 0.0;
                   } else if ((MathUtils.SAFE_MIN * work[j4 + 2] < work[j4 - 3]) &&
                              (MathUtils.SAFE_MIN * work[j4 - 3] < work[j4 + 2])) {
                       final double tmp = work[j4 + 2] / work[j4 - 3];
  @@ -1367,7 +1369,6 @@
  d _= tmp;
  } else {
  work[j4 - 1] = work[j4 + 2] _ (work[j4] / work[j4 - 3]);
-                    d *= work[j4 + 2] / work[j4 - 3];
                   }
                   dMin = Math.min(dMin, d);
                   eMin = Math.min(eMin, work[j4 - 1]);
  @@ -1384,14 +1385,12 @@
  work[j4] = 0.0;
  dN1 = work[j4p2 + 2];
  dMin = dN1;
-            eMin = 0.0;
         } else if ((MathUtils.SAFE_MIN * work[j4p2 + 2] < work[j4 - 2]) &&
                    (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4p2 + 2])) {
             final double tmp = work[j4p2 + 2] / work[j4 - 2];
             work[j4] = work[j4p2] * tmp;
             dN1 = dN2 * tmp;
         } else {
-            work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]);
               dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);
           }
           dMin = Math.min(dMin, dN1);
  @@ -1403,8 +1402,6 @@
  if (work[j4 - 2] == 0.0) {
  work[j4] = 0.0;
  dN = work[j4p2 + 2];
-            dMin = dN;
-            eMin = 0.0;
           } else if ((MathUtils.SAFE_MIN * work[j4p2 + 2] < work[j4 - 2]) &&
                      (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4p2 + 2])) {
               final double tmp = work[j4p2 + 2] / work[j4 - 2];
  2023-08-15 22:56:48 [main] [INFO] PatchLogExporter - patch (v13919)
  --- org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic
  +++ org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic
  @@ -173,4 +173,3 @@
  return test(values, begin, length);
  }
  }
- 2023-08-15 22:56:48 [main] [INFO] PatchLogExporter - patch (v13919)
  --- org.apache.commons.math.optimization.fitting.WeightedObservedPoint
  +++ org.apache.commons.math.optimization.fitting.WeightedObservedPoint
  @@ -72,4 +72,3 @@
  }
  }
- 2023-08-15 22:56:48 [main] [INFO] PatchLogExporter - patch (v13919)
  --- org.apache.commons.math.linear.BigMatrix
  +++ org.apache.commons.math.linear.BigMatrix
  @@ -328,4 +328,3 @@
  \*/
  BigMatrix solve(BigMatrix b) throws IllegalArgumentException, InvalidMatrixException;
  }
- 2023-08-15 22:56:48 [main] [INFO] PatchLogExporter - patch (v13942)
  --- org.apache.commons.math.linear.Array2DRowRealMatrix
  +++ org.apache.commons.math.linear.Array2DRowRealMatrix
  @@ -328,7 +328,7 @@
  }
               final int nCols = subMatrix[0].length;
-            if (nCols == 0) {

*            if (this.isSingular()) {
                   throw MathRuntimeException.createIllegalArgumentException("matrix must have at least one column");
               }
               data = new double[subMatrix.length][nCols];
  2023-08-15 22:56:48 [main] [INFO] PatchLogExporter - patch (v13942)
  --- org.apache.commons.math.linear.ArrayRealVector
  +++ org.apache.commons.math.linear.ArrayRealVector
  @@ -243,7 +243,6 @@
  /\*_ {@inheritDoc} _/
  public RealVector add(double[] v)
  throws IllegalArgumentException {

-        checkVectorDimensions(v.length);
           double[] out = new double[data.length];
           for (int i = 0; i < data.length; i++) {
               out[i] = data[i] + v[i];
  2023-08-15 22:56:48 [main] [INFO] PatchLogExporter - patch (v13942)
  --- org.apache.commons.math.linear.EigenDecompositionImpl
  +++ org.apache.commons.math.linear.EigenDecompositionImpl
  @@ -844,7 +844,6 @@
           // initialize parameters used by goodStep
           tType = 0;
-        dMin1 = 0;
           dMin2 = 0;
           dN    = 0;
           dN1   = 0;
  @@ -868,8 +867,6 @@
  i0 = 0;
  for (int i = 4 \* (n0 - 2); i >= 0; i -= 4) {
  if (work[i + 2] <= 0) {
-                    i0 = 1 + i / 4;
-                    break;
                   }
                   if (diagMin >= 4 * offDiagMax) {
                       diagMin    = Math.min(diagMin, work[i + 4]);
  @@ -910,7 +907,6 @@
  work[i + 2] = -sigma;
  split = i / 4;
  diagMax = 0;
-                            offDiagMin   = work[i + 6];
                               previousEMin = work[i + 7];
                           } else {
                               diagMax      = Math.max(diagMax, work[i + 4]);
  @@ -941,8 +937,6 @@
  double d = work[4 * (n - 1) + pingPong];
  for (int i = 4 _ (n - 2) + pingPong; i >= 0; i -= 4) {
  if (work[i + 2] <= TOLERANCE_2 _ d) {
-                    work[i + 2] = -0.0;
-                    d = work[i];
                   } else {
                       d *= work[i] / (d + work[i + 2]);
                   }
  @@ -954,10 +948,9 @@
  final int j = i - 2 _ pingPong - 1;
  work[j] = d + work[i];
  if (work[i] <= TOLERANCE_2 _ d) {
-                    work[i]     = -0.0;
                     work[j]     = d;
-                    work[j + 2] = 0.0;
-                    d = work[i + 2];

*                    Arrays.sort(realEigenvalues);
*     			Arrays.sort(realEigenvalues);
                   } else if ((MathUtils.SAFE_MIN * work[i + 2] < work[j]) &&
                              (MathUtils.SAFE_MIN * work[j] < work[i + 2])) {
                       final double tmp = work[i + 2] / work[j];
  @@ -990,8 +983,6 @@
  \*/
  private int goodStep(final int start, final int end) {

-        g = 0.0;
-          // step 1: accepting realEigenvalues
           int deflatedEnd = end;
           for (boolean deflating = true; deflating;) {
  @@ -1052,7 +1043,7 @@
  // step 2: flip array if needed
  if ((dMin <= 0) || (deflatedEnd < end)) {
  if (flipIfWarranted(deflatedEnd, 1)) {
-                dMin2 = Math.min(dMin2, work[l - 1]);

*                int outIndex = 0;
                   work[l - 1] =
                       Math.min(work[l - 1],
                                Math.min(work[3 + pingPong], work[7 + pingPong]));
  @@ -1089,7 +1080,8 @@
  // convergence hidden by negative DN.
  work[4 * deflatedEnd - 3 - pingPong] = 0.0;
  dMin = 0.0;

-                    updateSigma(tau);

*                    double res = 0;
*     			updateSigma(tau);
                       return deflatedEnd;
                   } else if (dMin < 0.0) {
                       // tau too big. Select new tau and try again.
  @@ -1136,7 +1128,6 @@
  for (int i = 0; i < j; i += 4) {
  for (int k = 0; k < 4; k += step) {
  final double tmp = work[i + k];

-                    work[i + k] = work[j - k];
                       work[j - k] = tmp;
                   }
                   j -= 4;
  @@ -1337,7 +1328,6 @@
  work[j4 - 2] = d + work[j4 - 1];
  if (work[j4 - 2] == 0.0) {
  work[j4] = 0.0;
-                    d = work[j4 + 1];
                       dMin = d;
                       eMin = 0.0;
                   } else if ((MathUtils.SAFE_MIN * work[j4 + 1] < work[j4 - 2]) &&
  @@ -1358,7 +1348,6 @@
  if (work[j4 - 3] == 0.0) {
  work[j4 - 1] = 0.0;
  d = work[j4 + 2];
-                    dMin = d;
                       eMin = 0.0;
                   } else if ((MathUtils.SAFE_MIN * work[j4 + 2] < work[j4 - 3]) &&
                              (MathUtils.SAFE_MIN * work[j4 - 3] < work[j4 + 2])) {
  @@ -1381,17 +1370,14 @@
  int j4p2 = j4 + 2 \* pingPong - 1;
  work[j4 - 2] = dN2 + work[j4p2];
  if (work[j4 - 2] == 0.0) {
-            work[j4] = 0.0;
             dN1  = work[j4p2 + 2];
             dMin = dN1;
-            eMin = 0.0;
         } else if ((MathUtils.SAFE_MIN * work[j4p2 + 2] < work[j4 - 2]) &&
                    (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4p2 + 2])) {
             final double tmp = work[j4p2 + 2] / work[j4 - 2];
             work[j4] = work[j4p2] * tmp;
             dN1 = dN2 * tmp;
         } else {
-            work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]);
               dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);
           }
           dMin = Math.min(dMin, dN1);
  @@ -1401,17 +1387,13 @@
  j4p2 = j4 + 2 \* pingPong - 1;
  work[j4 - 2] = dN1 + work[j4p2];
  if (work[j4 - 2] == 0.0) {
-            work[j4] = 0.0;
             dN   = work[j4p2 + 2];
-            dMin = dN;
-            eMin = 0.0;
         } else if ((MathUtils.SAFE_MIN * work[j4p2 + 2] < work[j4 - 2]) &&
                    (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4p2 + 2])) {
             final double tmp = work[j4p2 + 2] / work[j4 - 2];
             work[j4] = work[j4p2] * tmp;
             dN = dN1 * tmp;
         } else {
-            work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]);
               dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);
           }
           dMin = Math.min(dMin, dN);
  @@ -1536,7 +1518,6 @@
  double b2 = work[np - 6];
  final double gam = dN2;
  if (work[np - 8] > b2 || work[np - 4] > b1) {
-                    return;
                 }
                 double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1);

2023-08-15 22:56:48 [main] [INFO] PatchLogExporter - patch (v13942)
--- org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic
+++ org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic
@@ -173,4 +173,3 @@
return test(values, begin, length);
}
}

- 2023-08-15 22:56:48 [main] [INFO] PatchLogExporter - patch (v13942)
  --- org.apache.commons.math.optimization.fitting.WeightedObservedPoint
  +++ org.apache.commons.math.optimization.fitting.WeightedObservedPoint
  @@ -72,4 +72,3 @@
  }
  }
- 2023-08-15 22:56:48 [main] [INFO] PatchLogExporter - patch (v13942)
  --- org.apache.commons.math.linear.BigMatrix
  +++ org.apache.commons.math.linear.BigMatrix
  @@ -328,4 +328,3 @@
  \*/
  BigMatrix solve(BigMatrix b) throws IllegalArgumentException, InvalidMatrixException;
  }
- 2023-08-15 22:56:48 [main] [INFO] PatchLogExporter - patch (v14620)
  --- org.apache.commons.math.linear.Array2DRowRealMatrix
  +++ org.apache.commons.math.linear.Array2DRowRealMatrix
  @@ -328,7 +328,7 @@
  }
               final int nCols = subMatrix[0].length;
-            if (nCols == 0) {

*            if (this.isSingular()) {
                   throw MathRuntimeException.createIllegalArgumentException("matrix must have at least one column");
               }
               data = new double[subMatrix.length][nCols];
  2023-08-15 22:56:48 [main] [INFO] PatchLogExporter - patch (v14620)
  --- org.apache.commons.math.linear.ArrayRealVector
  +++ org.apache.commons.math.linear.ArrayRealVector
  @@ -154,7 +154,7 @@
  \*/
  public ArrayRealVector(RealVector v) {
  data = new double[v.getDimension()];

-        for (int i = 0; i < data.length; ++i) {

*        for (int i = 0;; ++i) {
               data[i] = v.getEntry(i);
           }
       }
  @@ -283,7 +283,6 @@
  checkVectorDimensions(v.length);
  double[] out = new double[data.length];
  for (int i = 0; i < data.length; i++) {

-            out[i] = data[i] - v[i];
           }
           return new ArrayRealVector(out);
       }
  @@ -884,7 +883,6 @@
  checkVectorDimensions(v.length);
  double dot = 0;
  for (int i = 0; i < data.length; i++) {
-            dot += data[i] * v[i];
           }
           return dot;
       }
  2023-08-15 22:56:48 [main] [INFO] PatchLogExporter - patch (v14620)
  --- org.apache.commons.math.linear.EigenDecompositionImpl
  +++ org.apache.commons.math.linear.EigenDecompositionImpl
  @@ -869,7 +869,6 @@
  for (int i = 4 \* (n0 - 2); i >= 0; i -= 4) {
  if (work[i + 2] <= 0) {
  i0 = 1 + i / 4;
-                    break;
                   }
                   if (diagMin >= 4 * offDiagMax) {
                       diagMin    = Math.min(diagMin, work[i + 4]);
  @@ -910,7 +909,8 @@
  work[i + 2] = -sigma;
  split = i / 4;
  diagMax = 0;
-                            offDiagMin   = work[i + 6];

*                            List<Number> components=new ArrayList<Number>();
*     					offDiagMin   = work[i + 6];
                               previousEMin = work[i + 7];
                           } else {
                               diagMax      = Math.max(diagMax, work[i + 4]);
  @@ -942,7 +942,18 @@
  for (int i = 4 _ (n - 2) + pingPong; i >= 0; i -= 4) {
  if (work[i + 2] <= TOLERANCE_2 _ d) {
  work[i + 2] = -0.0;

-                    d = work[i];

*     			{
*     				work[i + 2] = -0.0;
*     				d = work[i];
*     			}
*     			{
*     				work[i + 2] = -0.0;
*     				d = work[i];
*     			}
*     			{
*     				work[i + 2] = -0.0;
*     				d = work[i];
*     			}
                   } else {
                       d *= work[i] / (d + work[i + 2]);
                   }
  @@ -955,9 +966,13 @@
  work[j] = d + work[i];
  if (work[i] <= TOLERANCE_2 \* d) {
  work[i] = -0.0;

-                    work[j]     = d;
-                    work[j + 2] = 0.0;
                     d = work[i + 2];

*     			Arrays.sort(realEigenvalues);
*     			Arrays.sort(realEigenvalues);
*     			Arrays.sort(realEigenvalues);
*     			Arrays.sort(realEigenvalues);
*     			Arrays.sort(realEigenvalues);
*     			Arrays.sort(realEigenvalues);
                   } else if ((MathUtils.SAFE_MIN * work[i + 2] < work[j]) &&
                              (MathUtils.SAFE_MIN * work[j] < work[i + 2])) {
                       final double tmp = work[i + 2] / work[j];
  @@ -1019,7 +1034,6 @@
  // two realEigenvalues found, deflate array
  if (work[k - 3] > work[k - 7]) {
  final double tmp = work[k - 3];

-                    work[k - 3] = work[k - 7];
                     work[k - 7] = tmp;
                 }

@@ -1053,9 +1067,6 @@
if ((dMin <= 0) || (deflatedEnd < end)) {
if (flipIfWarranted(deflatedEnd, 1)) {
dMin2 = Math.min(dMin2, work[l - 1]);

-                work[l - 1] =
-                    Math.min(work[l - 1],
-                             Math.min(work[3 + pingPong], work[7 + pingPong]));
                   work[l - 2 * pingPong] =
                       Math.min(work[l - 2 * pingPong],
                                Math.min(work[6 + pingPong], work[6 + pingPong]));
  @@ -1089,7 +1100,8 @@
  // convergence hidden by negative DN.
  work[4 * deflatedEnd - 3 - pingPong] = 0.0;
  dMin = 0.0;
-                    updateSigma(tau);

*                    double res = 0;
*     			updateSigma(tau);
                       return deflatedEnd;
                   } else if (dMin < 0.0) {
                       // tau too big. Select new tau and try again.
  @@ -1136,12 +1148,9 @@
  for (int i = 0; i < j; i += 4) {
  for (int k = 0; k < 4; k += step) {
  final double tmp = work[i + k];

-                    work[i + k] = work[j - k];
-                    work[j - k] = tmp;
                 }
                 j -= 4;
             }
-            return true;
           }
           return false;
       }
  @@ -1338,8 +1347,6 @@
  if (work[j4 - 2] == 0.0) {
  work[j4] = 0.0;
  d = work[j4 + 1];
-                    dMin = d;
-                    eMin = 0.0;
                   } else if ((MathUtils.SAFE_MIN * work[j4 + 1] < work[j4 - 2]) &&
                              (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4 + 1])) {
                       final double tmp = work[j4 + 1] / work[j4 - 2];
  @@ -1358,8 +1365,6 @@
  if (work[j4 - 3] == 0.0) {
  work[j4 - 1] = 0.0;
  d = work[j4 + 2];
-                    dMin = d;
-                    eMin = 0.0;
                   } else if ((MathUtils.SAFE_MIN * work[j4 + 2] < work[j4 - 3]) &&
                              (MathUtils.SAFE_MIN * work[j4 - 3] < work[j4 + 2])) {
                       final double tmp = work[j4 + 2] / work[j4 - 3];
  @@ -1384,14 +1389,12 @@
  work[j4] = 0.0;
  dN1 = work[j4p2 + 2];
  dMin = dN1;
-            eMin = 0.0;
         } else if ((MathUtils.SAFE_MIN * work[j4p2 + 2] < work[j4 - 2]) &&
                    (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4p2 + 2])) {
             final double tmp = work[j4p2 + 2] / work[j4 - 2];
             work[j4] = work[j4p2] * tmp;
             dN1 = dN2 * tmp;
         } else {
-            work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]);
               dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);
           }
           dMin = Math.min(dMin, dN1);
  @@ -1403,7 +1406,6 @@
  if (work[j4 - 2] == 0.0) {
  work[j4] = 0.0;
  dN = work[j4p2 + 2];
-            dMin = dN;
               eMin = 0.0;
           } else if ((MathUtils.SAFE_MIN * work[j4p2 + 2] < work[j4 - 2]) &&
                      (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4p2 + 2])) {
  @@ -1536,7 +1538,6 @@
  double b2 = work[np - 6];
  final double gam = dN2;
  if (work[np - 8] > b2 || work[np - 4] > b1) {
-                    return;
                 }
                 double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1);

2023-08-15 22:56:48 [main] [INFO] PatchLogExporter - patch (v14620)
--- org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic
+++ org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic
@@ -173,4 +173,3 @@
return test(values, begin, length);
}
}

- 2023-08-15 22:56:48 [main] [INFO] PatchLogExporter - patch (v14620)
  --- org.apache.commons.math.optimization.fitting.WeightedObservedPoint
  +++ org.apache.commons.math.optimization.fitting.WeightedObservedPoint
  @@ -72,4 +72,3 @@
  }
  }
- 2023-08-15 22:56:48 [main] [INFO] PatchLogExporter - patch (v14620)
  --- org.apache.commons.math.linear.BigMatrix
  +++ org.apache.commons.math.linear.BigMatrix
  @@ -328,4 +328,3 @@
  \*/
  BigMatrix solve(BigMatrix b) throws IllegalArgumentException, InvalidMatrixException;
  }
- 2023-08-15 22:56:48 [main] [INFO] PatchLogExporter - patch (v14636)
  --- org.apache.commons.math.linear.Array2DRowRealMatrix
  +++ org.apache.commons.math.linear.Array2DRowRealMatrix
  @@ -328,7 +328,7 @@
  }
               final int nCols = subMatrix[0].length;
-            if (nCols == 0) {

*            if (this.isSingular()) {
                   throw MathRuntimeException.createIllegalArgumentException("matrix must have at least one column");
               }
               data = new double[subMatrix.length][nCols];
  2023-08-15 22:56:48 [main] [INFO] PatchLogExporter - patch (v14636)
  --- org.apache.commons.math.linear.ArrayRealVector
  +++ org.apache.commons.math.linear.ArrayRealVector
  @@ -243,7 +243,6 @@
  /\*_ {@inheritDoc} _/
  public RealVector add(double[] v)
  throws IllegalArgumentException {

-        checkVectorDimensions(v.length);
           double[] out = new double[data.length];
           for (int i = 0; i < data.length; i++) {
               out[i] = data[i] + v[i];

  2023-08-15 22:56:48 [main] [INFO] PatchLogExporter - patch (v14636)
  --- org.apache.commons.math.linear.EigenDecompositionImpl
  +++ org.apache.commons.math.linear.EigenDecompositionImpl
  @@ -836,9 +836,6 @@
  return;
  }

-        // initial checks for splits (see Parlett & Marques section 3.3)
-        flipIfWarranted(n, 2);
-         // two iterations with Li's test for initial splits
          initialSplits(n);

@@ -868,8 +865,6 @@
i0 = 0;
for (int i = 4 \* (n0 - 2); i >= 0; i -= 4) {
if (work[i + 2] <= 0) {

-                    i0 = 1 + i / 4;
-                    break;
                   }
                   if (diagMin >= 4 * offDiagMax) {
                       diagMin    = Math.min(diagMin, work[i + 4]);
  @@ -941,8 +936,10 @@
  double d = work[4 * (n - 1) + pingPong];
  for (int i = 4 _ (n - 2) + pingPong; i >= 0; i -= 4) {
  if (work[i + 2] <= TOLERANCE_2 _ d) {
-                    work[i + 2] = -0.0;
-                    d = work[i];

*                    {
*     				work[i + 2] = -0.0;
*     				d = work[i];
*     			}
                   } else {
                       d *= work[i] / (d + work[i + 2]);
                   }
  @@ -954,10 +951,10 @@
  final int j = i - 2 _ pingPong - 1;
  work[j] = d + work[i];
  if (work[i] <= TOLERANCE_2 _ d) {

-                    work[i]     = -0.0;
                     work[j]     = d;
-                    work[j + 2] = 0.0;
                     d = work[i + 2];

*     			int blockIndex = 0;
*     			Arrays.sort(realEigenvalues);
                   } else if ((MathUtils.SAFE_MIN * work[i + 2] < work[j]) &&
                              (MathUtils.SAFE_MIN * work[j] < work[i + 2])) {
                       final double tmp = work[i + 2] / work[j];
  @@ -990,8 +987,6 @@
  \*/
  private int goodStep(final int start, final int end) {

-        g = 0.0;
-          // step 1: accepting realEigenvalues
           int deflatedEnd = end;
           for (boolean deflating = true; deflating;) {
  @@ -1019,7 +1014,8 @@
  // two realEigenvalues found, deflate array
  if (work[k - 3] > work[k - 7]) {
  final double tmp = work[k - 3];
-                    work[k - 3] = work[k - 7];

*                    int result = 1;
*     			work[k - 3] = work[k - 7];
                   work[k - 7] = tmp;
               }

@@ -1053,14 +1049,11 @@
if ((dMin <= 0) || (deflatedEnd < end)) {
if (flipIfWarranted(deflatedEnd, 1)) {
dMin2 = Math.min(dMin2, work[l - 1]);

-                work[l - 1] =
-                    Math.min(work[l - 1],
-                             Math.min(work[3 + pingPong], work[7 + pingPong]));

*     		updateSigma(tau);
               work[l - 2 * pingPong] =
                   Math.min(work[l - 2 * pingPong],
                            Math.min(work[6 + pingPong], work[6 + pingPong]));
               qMax  = Math.max(qMax, Math.max(work[3 + pingPong], work[7 + pingPong]));

-                dMin  = -0.0;
             }
         }

@@ -1089,7 +1082,8 @@
// convergence hidden by negative DN.
work[4 * deflatedEnd - 3 - pingPong] = 0.0;
dMin = 0.0;

-                    updateSigma(tau);

*                    double res = 0;
*     			updateSigma(tau);
                       return deflatedEnd;
                   } else if (dMin < 0.0) {
                       // tau too big. Select new tau and try again.
  @@ -1135,13 +1129,10 @@
  int j = 4 \* n - 1;
  for (int i = 0; i < j; i += 4) {
  for (int k = 0; k < 4; k += step) {

-                    final double tmp = work[i + k];
                     work[i + k] = work[j - k];
-                    work[j - k] = tmp;
                 }
                 j -= 4;
             }
-            return true;
           }
           return false;
       }
  @@ -1337,9 +1328,6 @@
  work[j4 - 2] = d + work[j4 - 1];
  if (work[j4 - 2] == 0.0) {
  work[j4] = 0.0;
-                    d = work[j4 + 1];
-                    dMin = d;
-                    eMin = 0.0;
                   } else if ((MathUtils.SAFE_MIN * work[j4 + 1] < work[j4 - 2]) &&
                              (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4 + 1])) {
                       final double tmp = work[j4 + 1] / work[j4 - 2];
  @@ -1347,7 +1335,6 @@
  d _= tmp;
  } else {
  work[j4] = work[j4 + 1] _ (work[j4 - 1] / work[j4 - 2]);
-                    d *= work[j4 + 1] / work[j4 - 2];
                   }
                   dMin = Math.min(dMin, d);
                   eMin = Math.min(eMin, work[j4]);
  @@ -1356,9 +1343,6 @@
  for (int j4 = 4 _ start + 3; j4 < 4 _ (end - 3); j4 += 4) {
  work[j4 - 3] = d + work[j4];
  if (work[j4 - 3] == 0.0) {
-                    work[j4 - 1] = 0.0;
-                    d = work[j4 + 2];
-                    dMin = d;
                       eMin = 0.0;
                   } else if ((MathUtils.SAFE_MIN * work[j4 + 2] < work[j4 - 3]) &&
                              (MathUtils.SAFE_MIN * work[j4 - 3] < work[j4 + 2])) {
  @@ -1384,14 +1368,12 @@
  work[j4] = 0.0;
  dN1 = work[j4p2 + 2];
  dMin = dN1;
-            eMin = 0.0;
         } else if ((MathUtils.SAFE_MIN * work[j4p2 + 2] < work[j4 - 2]) &&
                    (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4p2 + 2])) {
             final double tmp = work[j4p2 + 2] / work[j4 - 2];
             work[j4] = work[j4p2] * tmp;
             dN1 = dN2 * tmp;
         } else {
-            work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]);
               dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);
           }
           dMin = Math.min(dMin, dN1);
  @@ -1403,7 +1385,6 @@
  if (work[j4 - 2] == 0.0) {
  work[j4] = 0.0;
  dN = work[j4p2 + 2];
-            dMin = dN;
               eMin = 0.0;
           } else if ((MathUtils.SAFE_MIN * work[j4p2 + 2] < work[j4 - 2]) &&
                      (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4p2 + 2])) {
  2023-08-15 22:56:48 [main] [INFO] PatchLogExporter - patch (v14636)
  --- org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic
  +++ org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic
  @@ -173,4 +173,3 @@
  return test(values, begin, length);
  }
  }
- 2023-08-15 22:56:48 [main] [INFO] PatchLogExporter - patch (v14636)
  --- org.apache.commons.math.optimization.fitting.WeightedObservedPoint
  +++ org.apache.commons.math.optimization.fitting.WeightedObservedPoint
  @@ -72,4 +72,3 @@
  }
  }
- 2023-08-15 22:56:48 [main] [INFO] PatchLogExporter - patch (v14636)
  --- org.apache.commons.math.linear.BigMatrix
  +++ org.apache.commons.math.linear.BigMatrix
  @@ -328,4 +328,3 @@
  \*/
  BigMatrix solve(BigMatrix b) throws IllegalArgumentException, InvalidMatrixException;
  }
- 2023-08-15 22:56:48 [main] [INFO] PatchLogExporter - patch (v14908)
  --- org.apache.commons.math.linear.Array2DRowRealMatrix
  +++ org.apache.commons.math.linear.Array2DRowRealMatrix
  @@ -328,7 +328,7 @@
  }
               final int nCols = subMatrix[0].length;
-            if (nCols == 0) {

*            if (this.isSingular()) {
                   throw MathRuntimeException.createIllegalArgumentException("matrix must have at least one column");
               }
               data = new double[subMatrix.length][nCols];
  2023-08-15 22:56:48 [main] [INFO] PatchLogExporter - patch (v14908)
  --- org.apache.commons.math.linear.ArrayRealVector
  +++ org.apache.commons.math.linear.ArrayRealVector
  @@ -243,7 +243,6 @@
  /\*_ {@inheritDoc} _/
  public RealVector add(double[] v)
  throws IllegalArgumentException {

-        checkVectorDimensions(v.length);
           double[] out = new double[data.length];
           for (int i = 0; i < data.length; i++) {
               out[i] = data[i] + v[i];
  2023-08-15 22:56:48 [main] [INFO] PatchLogExporter - patch (v14908)
  --- org.apache.commons.math.linear.EigenDecompositionImpl
  +++ org.apache.commons.math.linear.EigenDecompositionImpl
  @@ -844,7 +844,6 @@
           // initialize parameters used by goodStep
           tType = 0;
-        dMin1 = 0;
           dMin2 = 0;
           dN    = 0;
           dN1   = 0;
  @@ -868,8 +867,6 @@
  i0 = 0;
  for (int i = 4 \* (n0 - 2); i >= 0; i -= 4) {
  if (work[i + 2] <= 0) {
-                    i0 = 1 + i / 4;
-                    break;
                   }
                   if (diagMin >= 4 * offDiagMax) {
                       diagMin    = Math.min(diagMin, work[i + 4]);
  @@ -910,7 +907,6 @@
  work[i + 2] = -sigma;
  split = i / 4;
  diagMax = 0;
-                            offDiagMin   = work[i + 6];
                               previousEMin = work[i + 7];
                           } else {
                               diagMax      = Math.max(diagMax, work[i + 4]);
  @@ -941,8 +937,6 @@
  double d = work[4 * (n - 1) + pingPong];
  for (int i = 4 _ (n - 2) + pingPong; i >= 0; i -= 4) {
  if (work[i + 2] <= TOLERANCE_2 _ d) {
-                    work[i + 2] = -0.0;
-                    d = work[i];
                   } else {
                       d *= work[i] / (d + work[i + 2]);
                   }
  @@ -954,17 +948,14 @@
  final int j = i - 2 _ pingPong - 1;
  work[j] = d + work[i];
  if (work[i] <= TOLERANCE_2 _ d) {
-                    work[i]     = -0.0;
-                    work[j]     = d;
-                    work[j + 2] = 0.0;
-                    d = work[i + 2];

*                    Arrays.sort(realEigenvalues);
*     			Arrays.sort(realEigenvalues);
               } else if ((MathUtils.SAFE_MIN * work[i + 2] < work[j]) &&
                          (MathUtils.SAFE_MIN * work[j] < work[i + 2])) {
                   final double tmp = work[i + 2] / work[j];
                   work[j + 2] = work[i] * tmp;
                   d *= tmp;
               } else {

-                    work[j + 2] = work[i + 2] * (work[i] / work[j]);
                       d *= work[i + 2] / work[j];
                  }
               }

  @@ -990,8 +981,6 @@
  \*/
  private int goodStep(final int start, final int end) {

-        g = 0.0;
-          // step 1: accepting realEigenvalues
           int deflatedEnd = end;
           for (boolean deflating = true; deflating;) {
  @@ -1052,14 +1041,13 @@
  // step 2: flip array if needed
  if ((dMin <= 0) || (deflatedEnd < end)) {
  if (flipIfWarranted(deflatedEnd, 1)) {
-                dMin2 = Math.min(dMin2, work[l - 1]);

*                int outIndex = 0;
                 work[l - 1] =
                     Math.min(work[l - 1],
                              Math.min(work[3 + pingPong], work[7 + pingPong]));
                 work[l - 2 * pingPong] =
                     Math.min(work[l - 2 * pingPong],
                              Math.min(work[6 + pingPong], work[6 + pingPong]));

-                qMax  = Math.max(qMax, Math.max(work[3 + pingPong], work[7 + pingPong]));
                   dMin  = -0.0;
               }
           }
  @@ -1089,7 +1077,8 @@
  // convergence hidden by negative DN.
  work[4 * deflatedEnd - 3 - pingPong] = 0.0;
  dMin = 0.0;
-                    updateSigma(tau);

*                    double res = 0;
*     			updateSigma(tau);
                       return deflatedEnd;
                   } else if (dMin < 0.0) {
                       // tau too big. Select new tau and try again.
  @@ -1136,7 +1125,6 @@
  for (int i = 0; i < j; i += 4) {
  for (int k = 0; k < 4; k += step) {
  final double tmp = work[i + k];

-                    work[i + k] = work[j - k];
                       work[j - k] = tmp;
                   }
                   j -= 4;
  @@ -1336,9 +1324,8 @@
  for (int j4 = 4 _ start + 3; j4 < 4 _ (end - 3); j4 += 4) {
  work[j4 - 2] = d + work[j4 - 1];
  if (work[j4 - 2] == 0.0) {
-                    work[j4] = 0.0;
-                    d = work[j4 + 1];
                     dMin = d;

*     			final double tmp = work[j4 + 2] / work[j4 - 3];
                       eMin = 0.0;
                   } else if ((MathUtils.SAFE_MIN * work[j4 + 1] < work[j4 - 2]) &&
                              (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4 + 1])) {
  @@ -1357,8 +1344,6 @@
  work[j4 - 3] = d + work[j4];
  if (work[j4 - 3] == 0.0) {
  work[j4 - 1] = 0.0;

-                    d = work[j4 + 2];
-                    dMin = d;
                       eMin = 0.0;
                   } else if ((MathUtils.SAFE_MIN * work[j4 + 2] < work[j4 - 3]) &&
                              (MathUtils.SAFE_MIN * work[j4 - 3] < work[j4 + 2])) {
  @@ -1381,17 +1366,14 @@
  int j4p2 = j4 + 2 \* pingPong - 1;
  work[j4 - 2] = dN2 + work[j4p2];
  if (work[j4 - 2] == 0.0) {
-            work[j4] = 0.0;
             dN1  = work[j4p2 + 2];
             dMin = dN1;
-            eMin = 0.0;
         } else if ((MathUtils.SAFE_MIN * work[j4p2 + 2] < work[j4 - 2]) &&
                    (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4p2 + 2])) {
             final double tmp = work[j4p2 + 2] / work[j4 - 2];
             work[j4] = work[j4p2] * tmp;
             dN1 = dN2 * tmp;
         } else {
-            work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]);
               dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);
           }
           dMin = Math.min(dMin, dN1);
  @@ -1401,18 +1383,13 @@
  j4p2 = j4 + 2 \* pingPong - 1;
  work[j4 - 2] = dN1 + work[j4p2];
  if (work[j4 - 2] == 0.0) {
-            work[j4] = 0.0;
             dN   = work[j4p2 + 2];
-            dMin = dN;
-            eMin = 0.0;
         } else if ((MathUtils.SAFE_MIN * work[j4p2 + 2] < work[j4 - 2]) &&
                    (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4p2 + 2])) {
             final double tmp = work[j4p2 + 2] / work[j4 - 2];
             work[j4] = work[j4p2] * tmp;
             dN = dN1 * tmp;
         } else {
-            work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]);
-            dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);
         }
         dMin = Math.min(dMin, dN);

@@ -1536,7 +1513,6 @@
double b2 = work[np - 6];
final double gam = dN2;
if (work[np - 8] > b2 || work[np - 4] > b1) {

-                    return;
                 }
                 double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1);

2023-08-15 22:56:48 [main] [INFO] PatchLogExporter - patch (v14908)
--- org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic
+++ org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic
@@ -173,4 +173,3 @@
return test(values, begin, length);
}
}

- 2023-08-15 22:56:48 [main] [INFO] PatchLogExporter - patch (v14908)
  --- org.apache.commons.math.optimization.fitting.WeightedObservedPoint
  +++ org.apache.commons.math.optimization.fitting.WeightedObservedPoint
  @@ -72,4 +72,3 @@
  }
  }
- 2023-08-15 22:56:48 [main] [INFO] PatchLogExporter - patch (v14908)
  --- org.apache.commons.math.linear.BigMatrix
  +++ org.apache.commons.math.linear.BigMatrix
  @@ -328,4 +328,3 @@
  \*/
  BigMatrix solve(BigMatrix b) throws IllegalArgumentException, InvalidMatrixException;
  }
- 2023-08-15 22:56:48 [main] [INFO] PatchLogExporter - patch (v15046)
  --- org.apache.commons.math.linear.Array2DRowRealMatrix
  +++ org.apache.commons.math.linear.Array2DRowRealMatrix
  @@ -328,7 +328,7 @@
  }
               final int nCols = subMatrix[0].length;
-            if (nCols == 0) {

*            if (this.isSingular()) {
                   throw MathRuntimeException.createIllegalArgumentException("matrix must have at least one column");
               }
               data = new double[subMatrix.length][nCols];
  2023-08-15 22:56:48 [main] [INFO] PatchLogExporter - patch (v15046)
  --- org.apache.commons.math.linear.ArrayRealVector
  +++ org.apache.commons.math.linear.ArrayRealVector
  @@ -243,7 +243,6 @@
  /\*_ {@inheritDoc} _/
  public RealVector add(double[] v)
  throws IllegalArgumentException {

-        checkVectorDimensions(v.length);
           double[] out = new double[data.length];
           for (int i = 0; i < data.length; i++) {
               out[i] = data[i] + v[i];
  2023-08-15 22:56:48 [main] [INFO] PatchLogExporter - patch (v15046)
  --- org.apache.commons.math.linear.EigenDecompositionImpl
  +++ org.apache.commons.math.linear.EigenDecompositionImpl
  @@ -868,8 +868,6 @@
  i0 = 0;
  for (int i = 4 \* (n0 - 2); i >= 0; i -= 4) {
  if (work[i + 2] <= 0) {
-                    i0 = 1 + i / 4;
-                    break;
                   }
                   if (diagMin >= 4 * offDiagMax) {
                       diagMin    = Math.min(diagMin, work[i + 4]);
  @@ -941,8 +939,10 @@
  double d = work[4 * (n - 1) + pingPong];
  for (int i = 4 _ (n - 2) + pingPong; i >= 0; i -= 4) {
  if (work[i + 2] <= TOLERANCE_2 _ d) {
-                    work[i + 2] = -0.0;
-                    d = work[i];

*                    {
*     				work[i + 2] = -0.0;
*     				d = work[i];
*     			}
                   } else {
                       d *= work[i] / (d + work[i + 2]);
                   }
  @@ -954,10 +954,9 @@
  final int j = i - 2 _ pingPong - 1;
  work[j] = d + work[i];
  if (work[i] <= TOLERANCE_2 _ d) {

-                    work[i]     = -0.0;
                     work[j]     = d;
-                    work[j + 2] = 0.0;
                     d = work[i + 2];

*     			int blockIndex = 0;
                   } else if ((MathUtils.SAFE_MIN * work[i + 2] < work[j]) &&
                              (MathUtils.SAFE_MIN * work[j] < work[i + 2])) {
                       final double tmp = work[i + 2] / work[j];
  @@ -990,8 +989,6 @@
  \*/
  private int goodStep(final int start, final int end) {

-        g = 0.0;
-          // step 1: accepting realEigenvalues
           int deflatedEnd = end;
           for (boolean deflating = true; deflating;) {
  @@ -1019,7 +1016,8 @@
  // two realEigenvalues found, deflate array
  if (work[k - 3] > work[k - 7]) {
  final double tmp = work[k - 3];
-                    work[k - 3] = work[k - 7];

*                    int result = 1;
*     			work[k - 3] = work[k - 7];
                   work[k - 7] = tmp;
               }

@@ -1053,14 +1051,11 @@
if ((dMin <= 0) || (deflatedEnd < end)) {
if (flipIfWarranted(deflatedEnd, 1)) {
dMin2 = Math.min(dMin2, work[l - 1]);

-                work[l - 1] =
-                    Math.min(work[l - 1],
-                             Math.min(work[3 + pingPong], work[7 + pingPong]));

*     		updateSigma(tau);
               work[l - 2 * pingPong] =
                   Math.min(work[l - 2 * pingPong],
                            Math.min(work[6 + pingPong], work[6 + pingPong]));
               qMax  = Math.max(qMax, Math.max(work[3 + pingPong], work[7 + pingPong]));

-                dMin  = -0.0;
             }
         }

@@ -1089,7 +1084,8 @@
// convergence hidden by negative DN.
work[4 * deflatedEnd - 3 - pingPong] = 0.0;
dMin = 0.0;

-                    updateSigma(tau);

*                    double res = 0;
*     			updateSigma(tau);
                       return deflatedEnd;
                   } else if (dMin < 0.0) {
                       // tau too big. Select new tau and try again.
  @@ -1135,13 +1131,8 @@
  int j = 4 \* n - 1;
  for (int i = 0; i < j; i += 4) {
  for (int k = 0; k < 4; k += step) {

-                    final double tmp = work[i + k];
-                    work[i + k] = work[j - k];
-                    work[j - k] = tmp;
                 }
-                j -= 4;
             }
-            return true;
           }
           return false;
       }
  @@ -1337,9 +1328,6 @@
  work[j4 - 2] = d + work[j4 - 1];
  if (work[j4 - 2] == 0.0) {
  work[j4] = 0.0;
-                    d = work[j4 + 1];
-                    dMin = d;
-                    eMin = 0.0;
                   } else if ((MathUtils.SAFE_MIN * work[j4 + 1] < work[j4 - 2]) &&
                              (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4 + 1])) {
                       final double tmp = work[j4 + 1] / work[j4 - 2];
  @@ -1347,7 +1335,6 @@
  d _= tmp;
  } else {
  work[j4] = work[j4 + 1] _ (work[j4 - 1] / work[j4 - 2]);
-                    d *= work[j4 + 1] / work[j4 - 2];
                   }
                   dMin = Math.min(dMin, d);
                   eMin = Math.min(eMin, work[j4]);
  @@ -1356,9 +1343,7 @@
  for (int j4 = 4 _ start + 3; j4 < 4 _ (end - 3); j4 += 4) {
  work[j4 - 3] = d + work[j4];
  if (work[j4 - 3] == 0.0) {
-                    work[j4 - 1] = 0.0;
                     d = work[j4 + 2];
-                    dMin = d;
                       eMin = 0.0;
                   } else if ((MathUtils.SAFE_MIN * work[j4 + 2] < work[j4 - 3]) &&
                              (MathUtils.SAFE_MIN * work[j4 - 3] < work[j4 + 2])) {
  @@ -1384,14 +1369,12 @@
  work[j4] = 0.0;
  dN1 = work[j4p2 + 2];
  dMin = dN1;
-            eMin = 0.0;
         } else if ((MathUtils.SAFE_MIN * work[j4p2 + 2] < work[j4 - 2]) &&
                    (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4p2 + 2])) {
             final double tmp = work[j4p2 + 2] / work[j4 - 2];
             work[j4] = work[j4p2] * tmp;
             dN1 = dN2 * tmp;
         } else {
-            work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]);
               dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);
           }
           dMin = Math.min(dMin, dN1);
  @@ -1403,7 +1386,6 @@
  if (work[j4 - 2] == 0.0) {
  work[j4] = 0.0;
  dN = work[j4p2 + 2];
-            dMin = dN;
               eMin = 0.0;
           } else if ((MathUtils.SAFE_MIN * work[j4p2 + 2] < work[j4 - 2]) &&
                      (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4p2 + 2])) {
  2023-08-15 22:56:48 [main] [INFO] PatchLogExporter - patch (v15046)
  --- org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic
  +++ org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic
  @@ -173,4 +173,3 @@
  return test(values, begin, length);
  }
  }
- 2023-08-15 22:56:48 [main] [INFO] PatchLogExporter - patch (v15046)
  --- org.apache.commons.math.optimization.fitting.WeightedObservedPoint
  +++ org.apache.commons.math.optimization.fitting.WeightedObservedPoint
  @@ -72,4 +72,3 @@
  }
  }
- 2023-08-15 22:56:48 [main] [INFO] PatchLogExporter - patch (v15046)
  --- org.apache.commons.math.linear.BigMatrix
  +++ org.apache.commons.math.linear.BigMatrix
  @@ -328,4 +328,3 @@
  \*/
  BigMatrix solve(BigMatrix b) throws IllegalArgumentException, InvalidMatrixException;
  }
- 2023-08-15 22:56:48 [main] [INFO] PatchLogExporter - patch (v15148)
  --- org.apache.commons.math.linear.Array2DRowRealMatrix
  +++ org.apache.commons.math.linear.Array2DRowRealMatrix
  @@ -328,7 +328,7 @@
  }
               final int nCols = subMatrix[0].length;
-            if (nCols == 0) {

*            if (this.isSingular()) {
                   throw MathRuntimeException.createIllegalArgumentException("matrix must have at least one column");
               }
               data = new double[subMatrix.length][nCols];
  2023-08-15 22:56:48 [main] [INFO] PatchLogExporter - patch (v15148)
  --- org.apache.commons.math.linear.EigenDecompositionImpl
  +++ org.apache.commons.math.linear.EigenDecompositionImpl
  @@ -845,7 +845,6 @@
  // initialize parameters used by goodStep
  tType = 0;
  dMin1 = 0;

-        dMin2 = 0;
           dN    = 0;
           dN1   = 0;
           dN2   = 0;
  @@ -868,8 +867,6 @@
  i0 = 0;
  for (int i = 4 \* (n0 - 2); i >= 0; i -= 4) {
  if (work[i + 2] <= 0) {
-                    i0 = 1 + i / 4;
-                    break;
                   }
                   if (diagMin >= 4 * offDiagMax) {
                       diagMin    = Math.min(diagMin, work[i + 4]);
  @@ -942,7 +939,10 @@
  for (int i = 4 _ (n - 2) + pingPong; i >= 0; i -= 4) {
  if (work[i + 2] <= TOLERANCE_2 _ d) {
  work[i + 2] = -0.0;
-                    d = work[i];

*     			{
*     				++k;
*     				d = work[i];
*     			}
                   } else {
                       d *= work[i] / (d + work[i + 2]);
                   }
  @@ -954,10 +954,10 @@
  final int j = i - 2 _ pingPong - 1;
  work[j] = d + work[i];
  if (work[i] <= TOLERANCE_2 _ d) {

-                    work[i]     = -0.0;
                     work[j]     = d;
-                    work[j + 2] = 0.0;
                     d = work[i + 2];

*     			int blockIndex = 0;
*     			Arrays.sort(realEigenvalues);
                   } else if ((MathUtils.SAFE_MIN * work[i + 2] < work[j]) &&
                              (MathUtils.SAFE_MIN * work[j] < work[i + 2])) {
                       final double tmp = work[i + 2] / work[j];
  @@ -990,8 +990,6 @@
  \*/
  private int goodStep(final int start, final int end) {

-        g = 0.0;
-          // step 1: accepting realEigenvalues
           int deflatedEnd = end;
           for (boolean deflating = true; deflating;) {
  @@ -1019,8 +1017,8 @@
  // two realEigenvalues found, deflate array
  if (work[k - 3] > work[k - 7]) {
  final double tmp = work[k - 3];
-                    work[k - 3] = work[k - 7];
-                    work[k - 7] = tmp;

*                    int result = 1;
*     			work[k - 7] = tmp;
                   }

                   if (work[k - 5] > TOLERANCE_2 * work[k - 3]) {
  @@ -1053,14 +1051,11 @@
  if ((dMin <= 0) || (deflatedEnd < end)) {
  if (flipIfWarranted(deflatedEnd, 1)) {
  dMin2 = Math.min(dMin2, work[l - 1]);

-                work[l - 1] =
-                    Math.min(work[l - 1],
-                             Math.min(work[3 + pingPong], work[7 + pingPong]));

*     		updateSigma(tau);
               work[l - 2 * pingPong] =
                   Math.min(work[l - 2 * pingPong],
                            Math.min(work[6 + pingPong], work[6 + pingPong]));
               qMax  = Math.max(qMax, Math.max(work[3 + pingPong], work[7 + pingPong]));

-                dMin  = -0.0;
             }
         }

@@ -1089,7 +1084,8 @@
// convergence hidden by negative DN.
work[4 * deflatedEnd - 3 - pingPong] = 0.0;
dMin = 0.0;

-                    updateSigma(tau);

*                    double res = 0;
*     			updateSigma(tau);
                       return deflatedEnd;
                   } else if (dMin < 0.0) {
                       // tau too big. Select new tau and try again.
  @@ -1135,13 +1131,8 @@
  int j = 4 \* n - 1;
  for (int i = 0; i < j; i += 4) {
  for (int k = 0; k < 4; k += step) {

-                    final double tmp = work[i + k];
-                    work[i + k] = work[j - k];
-                    work[j - k] = tmp;
                 }
-                j -= 4;
             }
-            return true;
           }
           return false;
       }
  @@ -1337,9 +1328,6 @@
  work[j4 - 2] = d + work[j4 - 1];
  if (work[j4 - 2] == 0.0) {
  work[j4] = 0.0;
-                    d = work[j4 + 1];
-                    dMin = d;
-                    eMin = 0.0;
                   } else if ((MathUtils.SAFE_MIN * work[j4 + 1] < work[j4 - 2]) &&
                              (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4 + 1])) {
                       final double tmp = work[j4 + 1] / work[j4 - 2];
  @@ -1347,7 +1335,6 @@
  d _= tmp;
  } else {
  work[j4] = work[j4 + 1] _ (work[j4 - 1] / work[j4 - 2]);
-                    d *= work[j4 + 1] / work[j4 - 2];
                   }
                   dMin = Math.min(dMin, d);
                   eMin = Math.min(eMin, work[j4]);
  @@ -1356,9 +1343,7 @@
  for (int j4 = 4 _ start + 3; j4 < 4 _ (end - 3); j4 += 4) {
  work[j4 - 3] = d + work[j4];
  if (work[j4 - 3] == 0.0) {
-                    work[j4 - 1] = 0.0;
                     d = work[j4 + 2];
-                    dMin = d;
                       eMin = 0.0;
                   } else if ((MathUtils.SAFE_MIN * work[j4 + 2] < work[j4 - 3]) &&
                              (MathUtils.SAFE_MIN * work[j4 - 3] < work[j4 + 2])) {
  @@ -1384,14 +1369,12 @@
  work[j4] = 0.0;
  dN1 = work[j4p2 + 2];
  dMin = dN1;
-            eMin = 0.0;
         } else if ((MathUtils.SAFE_MIN * work[j4p2 + 2] < work[j4 - 2]) &&
                    (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4p2 + 2])) {
             final double tmp = work[j4p2 + 2] / work[j4 - 2];
             work[j4] = work[j4p2] * tmp;
             dN1 = dN2 * tmp;
         } else {
-            work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]);
               dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);
           }
           dMin = Math.min(dMin, dN1);
  @@ -1403,7 +1386,6 @@
  if (work[j4 - 2] == 0.0) {
  work[j4] = 0.0;
  dN = work[j4p2 + 2];
-            dMin = dN;
               eMin = 0.0;
           } else if ((MathUtils.SAFE_MIN * work[j4p2 + 2] < work[j4 - 2]) &&
                      (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4p2 + 2])) {
  2023-08-15 22:56:48 [main] [INFO] PatchLogExporter - patch (v15148)
  --- org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic
  +++ org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic
  @@ -173,4 +173,3 @@
  return test(values, begin, length);
  }
  }
- 2023-08-15 22:56:48 [main] [INFO] PatchLogExporter - patch (v15148)
  --- org.apache.commons.math.optimization.fitting.WeightedObservedPoint
  +++ org.apache.commons.math.optimization.fitting.WeightedObservedPoint
  @@ -72,4 +72,3 @@
  }
  }
- 2023-08-15 22:56:48 [main] [INFO] PatchLogExporter - patch (v15148)
  --- org.apache.commons.math.linear.BigMatrix
  +++ org.apache.commons.math.linear.BigMatrix
  @@ -328,4 +328,3 @@
  \*/
  BigMatrix solve(BigMatrix b) throws IllegalArgumentException, InvalidMatrixException;
  }
- 2023-08-15 22:56:48 [main] [INFO] PatchLogExporter - patch (v17028)
  --- org.apache.commons.math.linear.Array2DRowRealMatrix
  +++ org.apache.commons.math.linear.Array2DRowRealMatrix
  @@ -328,7 +328,7 @@
  }
               final int nCols = subMatrix[0].length;
-            if (nCols == 0) {

*            if (this.isSingular()) {
                   throw MathRuntimeException.createIllegalArgumentException("matrix must have at least one column");
               }
               data = new double[subMatrix.length][nCols];
  2023-08-15 22:56:48 [main] [INFO] PatchLogExporter - patch (v17028)
  --- org.apache.commons.math.linear.EigenDecompositionImpl
  +++ org.apache.commons.math.linear.EigenDecompositionImpl
  @@ -845,7 +845,6 @@
  // initialize parameters used by goodStep
  tType = 0;
  dMin1 = 0;

-        dMin2 = 0;
           dN    = 0;
           dN1   = 0;
           dN2   = 0;
  @@ -868,8 +867,6 @@
  i0 = 0;
  for (int i = 4 \* (n0 - 2); i >= 0; i -= 4) {
  if (work[i + 2] <= 0) {
-                    i0 = 1 + i / 4;
-                    break;
                   }
                   if (diagMin >= 4 * offDiagMax) {
                       diagMin    = Math.min(diagMin, work[i + 4]);
  @@ -941,8 +938,10 @@
  double d = work[4 * (n - 1) + pingPong];
  for (int i = 4 _ (n - 2) + pingPong; i >= 0; i -= 4) {
  if (work[i + 2] <= TOLERANCE_2 _ d) {
-                    work[i + 2] = -0.0;
-                    d = work[i];

*                    {
*     				++k;
*     				d = work[i];
*     			}
                   } else {
                       d *= work[i] / (d + work[i + 2]);
                   }
  @@ -954,10 +953,9 @@
  final int j = i - 2 _ pingPong - 1;
  work[j] = d + work[i];
  if (work[i] <= TOLERANCE_2 _ d) {

-                    work[i]     = -0.0;
                     work[j]     = d;
-                    work[j + 2] = 0.0;
                     d = work[i + 2];

*     			int blockIndex = 0;
                   } else if ((MathUtils.SAFE_MIN * work[i + 2] < work[j]) &&
                              (MathUtils.SAFE_MIN * work[j] < work[i + 2])) {
                       final double tmp = work[i + 2] / work[j];
  @@ -990,8 +988,6 @@
  \*/
  private int goodStep(final int start, final int end) {

-        g = 0.0;
-          // step 1: accepting realEigenvalues
           int deflatedEnd = end;
           for (boolean deflating = true; deflating;) {
  @@ -1019,7 +1015,6 @@
  // two realEigenvalues found, deflate array
  if (work[k - 3] > work[k - 7]) {
  final double tmp = work[k - 3];
-                    work[k - 3] = work[k - 7];
                     work[k - 7] = tmp;
                 }

@@ -1053,14 +1048,11 @@
if ((dMin <= 0) || (deflatedEnd < end)) {
if (flipIfWarranted(deflatedEnd, 1)) {
dMin2 = Math.min(dMin2, work[l - 1]);

-                work[l - 1] =
-                    Math.min(work[l - 1],
-                             Math.min(work[3 + pingPong], work[7 + pingPong]));

*     		updateSigma(tau);
               work[l - 2 * pingPong] =
                   Math.min(work[l - 2 * pingPong],
                            Math.min(work[6 + pingPong], work[6 + pingPong]));
               qMax  = Math.max(qMax, Math.max(work[3 + pingPong], work[7 + pingPong]));

-                dMin  = -0.0;
             }
         }

@@ -1089,7 +1081,8 @@
// convergence hidden by negative DN.
work[4 * deflatedEnd - 3 - pingPong] = 0.0;
dMin = 0.0;

-                    updateSigma(tau);

*                    double res = 0;
*     			updateSigma(tau);
                       return deflatedEnd;
                   } else if (dMin < 0.0) {
                       // tau too big. Select new tau and try again.
  @@ -1133,15 +1126,8 @@
  if (1.5 _ work[pingPong] < work[4 _ (n - 1) + pingPong]) {
  // flip array
  int j = 4 \* n - 1;

-            for (int i = 0; i < j; i += 4) {
-                for (int k = 0; k < 4; k += step) {
-                    final double tmp = work[i + k];
-                    work[i + k] = work[j - k];
-                    work[j - k] = tmp;
-                }
-                j -= 4;
-            }
-            return true;

*            for (int i = 0; i < j; i += 4)
*     		return true;
           }
           return false;
       }
  @@ -1336,10 +1322,6 @@
  for (int j4 = 4 _ start + 3; j4 < 4 _ (end - 3); j4 += 4) {
  work[j4 - 2] = d + work[j4 - 1];
  if (work[j4 - 2] == 0.0) {

-                    work[j4] = 0.0;
-                    d = work[j4 + 1];
-                    dMin = d;
-                    eMin = 0.0;
                   } else if ((MathUtils.SAFE_MIN * work[j4 + 1] < work[j4 - 2]) &&
                              (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4 + 1])) {
                       final double tmp = work[j4 + 1] / work[j4 - 2];
  @@ -1347,7 +1329,6 @@
  d _= tmp;
  } else {
  work[j4] = work[j4 + 1] _ (work[j4 - 1] / work[j4 - 2]);
-                    d *= work[j4 + 1] / work[j4 - 2];
                   }
                   dMin = Math.min(dMin, d);
                   eMin = Math.min(eMin, work[j4]);
  @@ -1356,9 +1337,7 @@
  for (int j4 = 4 _ start + 3; j4 < 4 _ (end - 3); j4 += 4) {
  work[j4 - 3] = d + work[j4];
  if (work[j4 - 3] == 0.0) {
-                    work[j4 - 1] = 0.0;
                     d = work[j4 + 2];
-                    dMin = d;
                       eMin = 0.0;
                   } else if ((MathUtils.SAFE_MIN * work[j4 + 2] < work[j4 - 3]) &&
                              (MathUtils.SAFE_MIN * work[j4 - 3] < work[j4 + 2])) {
  @@ -1384,14 +1363,12 @@
  work[j4] = 0.0;
  dN1 = work[j4p2 + 2];
  dMin = dN1;
-            eMin = 0.0;
         } else if ((MathUtils.SAFE_MIN * work[j4p2 + 2] < work[j4 - 2]) &&
                    (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4p2 + 2])) {
             final double tmp = work[j4p2 + 2] / work[j4 - 2];
             work[j4] = work[j4p2] * tmp;
             dN1 = dN2 * tmp;
         } else {
-            work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]);
               dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);
           }
           dMin = Math.min(dMin, dN1);
  @@ -1403,7 +1380,6 @@
  if (work[j4 - 2] == 0.0) {
  work[j4] = 0.0;
  dN = work[j4p2 + 2];
-            dMin = dN;
               eMin = 0.0;
           } else if ((MathUtils.SAFE_MIN * work[j4p2 + 2] < work[j4 - 2]) &&
                      (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4p2 + 2])) {
  2023-08-15 22:56:48 [main] [INFO] PatchLogExporter - patch (v17028)
  --- org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic
  +++ org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic
  @@ -173,4 +173,3 @@
  return test(values, begin, length);
  }
  }
- 2023-08-15 22:56:48 [main] [INFO] PatchLogExporter - patch (v17028)
  --- org.apache.commons.math.optimization.fitting.WeightedObservedPoint
  +++ org.apache.commons.math.optimization.fitting.WeightedObservedPoint
  @@ -72,4 +72,3 @@
  }
  }
- 2023-08-15 22:56:48 [main] [INFO] PatchLogExporter - patch (v17028)
  --- org.apache.commons.math.linear.BigMatrix
  +++ org.apache.commons.math.linear.BigMatrix
  @@ -328,4 +328,3 @@
  \*/
  BigMatrix solve(BigMatrix b) throws IllegalArgumentException, InvalidMatrixException;
  }
- 2023-08-15 22:56:48 [main] [INFO] PatchLogExporter - patch (v20744)
  --- org.apache.commons.math.linear.Array2DRowRealMatrix
  +++ org.apache.commons.math.linear.Array2DRowRealMatrix
  @@ -328,7 +328,7 @@
  }
               final int nCols = subMatrix[0].length;
-            if (nCols == 0) {

*            if (this.isSingular()) {
                   throw MathRuntimeException.createIllegalArgumentException("matrix must have at least one column");
               }
               data = new double[subMatrix.length][nCols];
  2023-08-15 22:56:48 [main] [INFO] PatchLogExporter - patch (v20744)
  --- org.apache.commons.math.linear.ArrayRealVector
  +++ org.apache.commons.math.linear.ArrayRealVector
  @@ -243,7 +243,6 @@
  /\*_ {@inheritDoc} _/
  public RealVector add(double[] v)
  throws IllegalArgumentException {

-        checkVectorDimensions(v.length);
           double[] out = new double[data.length];
           for (int i = 0; i < data.length; i++) {
               out[i] = data[i] + v[i];
  @@ -283,7 +282,6 @@
  checkVectorDimensions(v.length);
  double[] out = new double[data.length];
  for (int i = 0; i < data.length; i++) {
-            out[i] = data[i] - v[i];
           }
           return new ArrayRealVector(out);
       }
  @@ -884,7 +882,6 @@
  checkVectorDimensions(v.length);
  double dot = 0;
  for (int i = 0; i < data.length; i++) {
-            dot += data[i] * v[i];
           }
           return dot;
       }
  2023-08-15 22:56:48 [main] [INFO] PatchLogExporter - patch (v20744)
  --- org.apache.commons.math.linear.EigenDecompositionImpl
  +++ org.apache.commons.math.linear.EigenDecompositionImpl
  @@ -848,7 +848,6 @@
  dMin2 = 0;
  dN = 0;
  dN1 = 0;
-        dN2   = 0;
           tau   = 0;

           // process split segments
  @@ -868,8 +867,6 @@
  i0 = 0;
  for (int i = 4 \* (n0 - 2); i >= 0; i -= 4) {
  if (work[i + 2] <= 0) {
-                    i0 = 1 + i / 4;
-                    break;
                   }
                   if (diagMin >= 4 * offDiagMax) {
                       diagMin    = Math.min(diagMin, work[i + 4]);
  @@ -910,7 +907,8 @@
  work[i + 2] = -sigma;
  split = i / 4;
  diagMax = 0;
-                            offDiagMin   = work[i + 6];

*                            List<Number> components=new ArrayList<Number>();
*     					offDiagMin   = work[i + 6];
                               previousEMin = work[i + 7];
                           } else {
                               diagMax      = Math.max(diagMax, work[i + 4]);
  @@ -942,7 +940,14 @@
  for (int i = 4 _ (n - 2) + pingPong; i >= 0; i -= 4) {
  if (work[i + 2] <= TOLERANCE_2 _ d) {
  work[i + 2] = -0.0;

-                    d = work[i];

*     			{
*     			}
*     			{
*     				d = work[i];
*     			}
*     			{
*     				d = work[i];
*     			}
                   } else {
                       d *= work[i] / (d + work[i + 2]);
                   }
  @@ -955,9 +960,11 @@
  work[j] = d + work[i];
  if (work[i] <= TOLERANCE_2 \* d) {
  work[i] = -0.0;

-                    work[j]     = d;
-                    work[j + 2] = 0.0;
                     d = work[i + 2];

*     			Arrays.sort(realEigenvalues);
*     			Arrays.sort(realEigenvalues);
*     			Arrays.sort(realEigenvalues);
*     			Arrays.sort(realEigenvalues);
                   } else if ((MathUtils.SAFE_MIN * work[i + 2] < work[j]) &&
                              (MathUtils.SAFE_MIN * work[j] < work[i + 2])) {
                       final double tmp = work[i + 2] / work[j];
  @@ -1020,7 +1027,7 @@
  if (work[k - 3] > work[k - 7]) {
  final double tmp = work[k - 3];
  work[k - 3] = work[k - 7];

-                    work[k - 7] = tmp;

*     			final int upperStart = 5 * main.length;
                   }

                   if (work[k - 5] > TOLERANCE_2 * work[k - 3]) {
  @@ -1053,9 +1060,6 @@
  if ((dMin <= 0) || (deflatedEnd < end)) {
  if (flipIfWarranted(deflatedEnd, 1)) {
  dMin2 = Math.min(dMin2, work[l - 1]);

-                work[l - 1] =
-                    Math.min(work[l - 1],
-                             Math.min(work[3 + pingPong], work[7 + pingPong]));
                   work[l - 2 * pingPong] =
                       Math.min(work[l - 2 * pingPong],
                                Math.min(work[6 + pingPong], work[6 + pingPong]));
  @@ -1089,7 +1093,8 @@
  // convergence hidden by negative DN.
  work[4 * deflatedEnd - 3 - pingPong] = 0.0;
  dMin = 0.0;
-                    updateSigma(tau);

*                    double res = 0;
*     			updateSigma(tau);
                       return deflatedEnd;
                   } else if (dMin < 0.0) {
                       // tau too big. Select new tau and try again.
  @@ -1136,12 +1141,9 @@
  for (int i = 0; i < j; i += 4) {
  for (int k = 0; k < 4; k += step) {
  final double tmp = work[i + k];

-                    work[i + k] = work[j - k];
-                    work[j - k] = tmp;

*                    int outBlockIndex = 0;
                 }

-                j -= 4;
             }
-            return true;
           }
           return false;
       }

  @@ -1194,8 +1196,6 @@
  }
  lower = Math.max(lower, left - 100 _ MathUtils.EPSILON _ Math.abs(left));

-        // search upper eigenvalue
-        left  = lower - margin;
         right = upper + margin;
         for (int i = 0; i < maxIter; ++i) {

@@ -1338,16 +1338,12 @@
if (work[j4 - 2] == 0.0) {
work[j4] = 0.0;
d = work[j4 + 1];

-                    dMin = d;
-                    eMin = 0.0;
                 } else if ((MathUtils.SAFE_MIN * work[j4 + 1] < work[j4 - 2]) &&
                            (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4 + 1])) {
                     final double tmp = work[j4 + 1] / work[j4 - 2];
                     work[j4] = work[j4 - 1] * tmp;
                     d *= tmp;
                 } else {
-                    work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]);
-                    d *= work[j4 + 1] / work[j4 - 2];
                   }
                   dMin = Math.min(dMin, d);
                   eMin = Math.min(eMin, work[j4]);
  @@ -1358,16 +1354,12 @@
  if (work[j4 - 3] == 0.0) {
  work[j4 - 1] = 0.0;
  d = work[j4 + 2];
-                    dMin = d;
-                    eMin = 0.0;
                 } else if ((MathUtils.SAFE_MIN * work[j4 + 2] < work[j4 - 3]) &&
                            (MathUtils.SAFE_MIN * work[j4 - 3] < work[j4 + 2])) {
                     final double tmp = work[j4 + 2] / work[j4 - 3];
                     work[j4 - 1] = work[j4] * tmp;
                     d *= tmp;
                 } else {
-                    work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]);
-                    d *= work[j4 + 2] / work[j4 - 3];
                   }
                   dMin = Math.min(dMin, d);
                   eMin = Math.min(eMin, work[j4 - 1]);
  @@ -1384,14 +1376,12 @@
  work[j4] = 0.0;
  dN1 = work[j4p2 + 2];
  dMin = dN1;
-            eMin = 0.0;
         } else if ((MathUtils.SAFE_MIN * work[j4p2 + 2] < work[j4 - 2]) &&
                    (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4p2 + 2])) {
             final double tmp = work[j4p2 + 2] / work[j4 - 2];
             work[j4] = work[j4p2] * tmp;
             dN1 = dN2 * tmp;
         } else {
-            work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]);
               dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);
           }
           dMin = Math.min(dMin, dN1);
  @@ -1403,7 +1393,6 @@
  if (work[j4 - 2] == 0.0) {
  work[j4] = 0.0;
  dN = work[j4p2 + 2];
-            dMin = dN;
               eMin = 0.0;
           } else if ((MathUtils.SAFE_MIN * work[j4p2 + 2] < work[j4 - 2]) &&
                      (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4p2 + 2])) {
  @@ -1536,7 +1525,6 @@
  double b2 = work[np - 6];
  final double gam = dN2;
  if (work[np - 8] > b2 || work[np - 4] > b1) {
-                    return;
                 }
                 double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1);

2023-08-15 22:56:48 [main] [INFO] PatchLogExporter - patch (v20744)
--- org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic
+++ org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic
@@ -173,4 +173,3 @@
return test(values, begin, length);
}
}

- 2023-08-15 22:56:48 [main] [INFO] PatchLogExporter - patch (v20744)
  --- org.apache.commons.math.optimization.fitting.WeightedObservedPoint
  +++ org.apache.commons.math.optimization.fitting.WeightedObservedPoint
  @@ -72,4 +72,3 @@
  }
  }
- 2023-08-15 22:56:48 [main] [INFO] PatchLogExporter - patch (v20744)
  --- org.apache.commons.math.linear.BigMatrix
  +++ org.apache.commons.math.linear.BigMatrix
  @@ -328,4 +328,3 @@
  \*/
  BigMatrix solve(BigMatrix b) throws IllegalArgumentException, InvalidMatrixException;
  }
- 2023-08-15 22:56:49 [main] [INFO] PatchLogExporter - patch (v24236)
  --- org.apache.commons.math.linear.Array2DRowRealMatrix
  +++ org.apache.commons.math.linear.Array2DRowRealMatrix
  @@ -328,7 +328,7 @@
  }
               final int nCols = subMatrix[0].length;
-            if (nCols == 0) {

*            if (this.isSingular()) {
                   throw MathRuntimeException.createIllegalArgumentException("matrix must have at least one column");
               }
               data = new double[subMatrix.length][nCols];
  2023-08-15 22:56:49 [main] [INFO] PatchLogExporter - patch (v24236)
  --- org.apache.commons.math.linear.ArrayRealVector
  +++ org.apache.commons.math.linear.ArrayRealVector
  @@ -884,7 +884,6 @@
  checkVectorDimensions(v.length);
  double dot = 0;
  for (int i = 0; i < data.length; i++) {

-            dot += data[i] * v[i];
           }
           return dot;
       }
  @@ -904,7 +903,6 @@
  public double getNorm() {
  double sum = 0;
  for (double a : data) {
-            sum += a * a;
           }
           return Math.sqrt(sum);
       }
  2023-08-15 22:56:49 [main] [INFO] PatchLogExporter - patch (v24236)
  --- org.apache.commons.math.linear.EigenDecompositionImpl
  +++ org.apache.commons.math.linear.EigenDecompositionImpl
  @@ -845,7 +845,6 @@
  // initialize parameters used by goodStep
  tType = 0;
  dMin1 = 0;
-        dMin2 = 0;
           dN    = 0;
           dN1   = 0;
           dN2   = 0;
  @@ -868,8 +867,6 @@
  i0 = 0;
  for (int i = 4 \* (n0 - 2); i >= 0; i -= 4) {
  if (work[i + 2] <= 0) {
-                    i0 = 1 + i / 4;
-                    break;
                   }
                   if (diagMin >= 4 * offDiagMax) {
                       diagMin    = Math.min(diagMin, work[i + 4]);
  @@ -913,7 +910,6 @@
  offDiagMin = work[i + 6];
  previousEMin = work[i + 7];
  } else {
-                            diagMax      = Math.max(diagMax, work[i + 4]);
                               offDiagMin   = Math.min(offDiagMin, work[i + 2]);
                               previousEMin = Math.min(previousEMin, work[i + 3]);
                           }
  @@ -941,8 +937,9 @@
  double d = work[4 * (n - 1) + pingPong];
  for (int i = 4 _ (n - 2) + pingPong; i >= 0; i -= 4) {
  if (work[i + 2] <= TOLERANCE_2 _ d) {
-                    work[i + 2] = -0.0;
-                    d = work[i];

*                    {
*     				d = work[i];
*     			}
                   } else {
                       d *= work[i] / (d + work[i + 2]);
                   }
  @@ -954,10 +951,6 @@
  final int j = i - 2 _ pingPong - 1;
  work[j] = d + work[i];
  if (work[i] <= TOLERANCE_2 _ d) {

-                    work[i]     = -0.0;
-                    work[j]     = d;
-                    work[j + 2] = 0.0;
-                    d = work[i + 2];
                   } else if ((MathUtils.SAFE_MIN * work[i + 2] < work[j]) &&
                              (MathUtils.SAFE_MIN * work[j] < work[i + 2])) {
                       final double tmp = work[i + 2] / work[j];

  @@ -990,8 +983,6 @@
  \*/
  private int goodStep(final int start, final int end) {

-        g = 0.0;
-          // step 1: accepting realEigenvalues
           int deflatedEnd = end;
           for (boolean deflating = true; deflating;) {
  @@ -1019,7 +1010,6 @@
  // two realEigenvalues found, deflate array
  if (work[k - 3] > work[k - 7]) {
  final double tmp = work[k - 3];
-                    work[k - 3] = work[k - 7];
                     work[k - 7] = tmp;
                 }

@@ -1053,14 +1043,11 @@
if ((dMin <= 0) || (deflatedEnd < end)) {
if (flipIfWarranted(deflatedEnd, 1)) {
dMin2 = Math.min(dMin2, work[l - 1]);

-                work[l - 1] =
-                    Math.min(work[l - 1],
-                             Math.min(work[3 + pingPong], work[7 + pingPong]));

*     		updateSigma(tau);
               work[l - 2 * pingPong] =
                   Math.min(work[l - 2 * pingPong],
                            Math.min(work[6 + pingPong], work[6 + pingPong]));
               qMax  = Math.max(qMax, Math.max(work[3 + pingPong], work[7 + pingPong]));

-                dMin  = -0.0;
             }
         }

@@ -1089,7 +1076,8 @@
// convergence hidden by negative DN.
work[4 * deflatedEnd - 3 - pingPong] = 0.0;
dMin = 0.0;

-                    updateSigma(tau);

*                    double res = 0;
*     			updateSigma(tau);
                       return deflatedEnd;
                   } else if (dMin < 0.0) {
                       // tau too big. Select new tau and try again.
  @@ -1135,13 +1123,9 @@
  int j = 4 \* n - 1;
  for (int i = 0; i < j; i += 4) {
  for (int k = 0; k < 4; k += step) {

-                    final double tmp = work[i + k];
-                    work[i + k] = work[j - k];
-                    work[j - k] = tmp;
                 }
-                j -= 4;

*                --j;
             }

-            return true;
           }
           return false;
       }
  @@ -1298,7 +1282,8 @@
           // unroll last two steps.
           dN2 = d;
-        dMin2 = dMin;

*        tType = -6;
*     dMin2 = dMin;
           int j4 = 4 * (end - 2) - pingPong - 1;
           int j4p2 = j4 + 2 * pingPong - 1;
           work[j4 - 2] = dN2 + work[j4p2];
  @@ -1336,18 +1321,12 @@
  for (int j4 = 4 _ start + 3; j4 < 4 _ (end - 3); j4 += 4) {
  work[j4 - 2] = d + work[j4 - 1];
  if (work[j4 - 2] == 0.0) {

-                    work[j4] = 0.0;
-                    d = work[j4 + 1];
-                    dMin = d;
-                    eMin = 0.0;
                 } else if ((MathUtils.SAFE_MIN * work[j4 + 1] < work[j4 - 2]) &&
                            (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4 + 1])) {
                     final double tmp = work[j4 + 1] / work[j4 - 2];
                     work[j4] = work[j4 - 1] * tmp;
                     d *= tmp;
                 } else {
-                    work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]);
-                    d *= work[j4 + 1] / work[j4 - 2];
                   }
                   dMin = Math.min(dMin, d);
                   eMin = Math.min(eMin, work[j4]);
  @@ -1356,9 +1335,7 @@
  for (int j4 = 4 _ start + 3; j4 < 4 _ (end - 3); j4 += 4) {
  work[j4 - 3] = d + work[j4];
  if (work[j4 - 3] == 0.0) {
-                    work[j4 - 1] = 0.0;
                     d = work[j4 + 2];
-                    dMin = d;
                       eMin = 0.0;
                   } else if ((MathUtils.SAFE_MIN * work[j4 + 2] < work[j4 - 3]) &&
                              (MathUtils.SAFE_MIN * work[j4 - 3] < work[j4 + 2])) {
  @@ -1384,14 +1361,12 @@
  work[j4] = 0.0;
  dN1 = work[j4p2 + 2];
  dMin = dN1;
-            eMin = 0.0;
         } else if ((MathUtils.SAFE_MIN * work[j4p2 + 2] < work[j4 - 2]) &&
                    (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4p2 + 2])) {
             final double tmp = work[j4p2 + 2] / work[j4 - 2];
             work[j4] = work[j4p2] * tmp;
             dN1 = dN2 * tmp;
         } else {
-            work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]);
               dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);
           }
           dMin = Math.min(dMin, dN1);
  @@ -1403,7 +1378,6 @@
  if (work[j4 - 2] == 0.0) {
  work[j4] = 0.0;
  dN = work[j4p2 + 2];
-            dMin = dN;
               eMin = 0.0;
           } else if ((MathUtils.SAFE_MIN * work[j4p2 + 2] < work[j4 - 2]) &&
                      (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4p2 + 2])) {
  @@ -1412,7 +1386,6 @@
  dN = dN1 _ tmp;
  } else {
  work[j4] = work[j4p2 + 2] _ (work[j4p2] / work[j4 - 2]);
-            dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);
         }
         dMin = Math.min(dMin, dN);

2023-08-15 22:56:49 [main] [INFO] PatchLogExporter - patch (v24236)
--- org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic
+++ org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic
@@ -173,4 +173,3 @@
return test(values, begin, length);
}
}

- 2023-08-15 22:56:49 [main] [INFO] PatchLogExporter - patch (v24236)
  --- org.apache.commons.math.optimization.fitting.WeightedObservedPoint
  +++ org.apache.commons.math.optimization.fitting.WeightedObservedPoint
  @@ -72,4 +72,3 @@
  }
  }
- 2023-08-15 22:56:49 [main] [INFO] PatchLogExporter - patch (v24236)
  --- org.apache.commons.math.linear.BigMatrix
  +++ org.apache.commons.math.linear.BigMatrix
  @@ -328,4 +328,3 @@
  \*/
  BigMatrix solve(BigMatrix b) throws IllegalArgumentException, InvalidMatrixException;
  }
- 2023-08-15 22:56:49 [main] [INFO] PatchLogExporter - patch (v24631)
  --- org.apache.commons.math.linear.Array2DRowRealMatrix
  +++ org.apache.commons.math.linear.Array2DRowRealMatrix
  @@ -328,7 +328,7 @@
  }
               final int nCols = subMatrix[0].length;
-            if (nCols == 0) {

*            if (this.isSingular()) {
                   throw MathRuntimeException.createIllegalArgumentException("matrix must have at least one column");
               }
               data = new double[subMatrix.length][nCols];
  2023-08-15 22:56:49 [main] [INFO] PatchLogExporter - patch (v24631)
  --- org.apache.commons.math.linear.ArrayRealVector
  +++ org.apache.commons.math.linear.ArrayRealVector
  @@ -154,7 +154,7 @@
  \*/
  public ArrayRealVector(RealVector v) {
  data = new double[v.getDimension()];

-        for (int i = 0; i < data.length; ++i) {

*        for (int i = 0;; ++i) {
               data[i] = v.getEntry(i);
           }
       }
  @@ -283,7 +283,6 @@
  checkVectorDimensions(v.length);
  double[] out = new double[data.length];
  for (int i = 0; i < data.length; i++) {

-            out[i] = data[i] - v[i];
           }
           return new ArrayRealVector(out);
       }
  @@ -884,7 +883,6 @@
  checkVectorDimensions(v.length);
  double dot = 0;
  for (int i = 0; i < data.length; i++) {
-            dot += data[i] * v[i];
           }
           return dot;
       }
  @@ -904,7 +902,6 @@
  public double getNorm() {
  double sum = 0;
  for (double a : data) {
-            sum += a * a;
           }
           return Math.sqrt(sum);
       }
  2023-08-15 22:56:49 [main] [INFO] PatchLogExporter - patch (v24631)
  --- org.apache.commons.math.linear.EigenDecompositionImpl
  +++ org.apache.commons.math.linear.EigenDecompositionImpl
  @@ -868,8 +868,6 @@
  i0 = 0;
  for (int i = 4 \* (n0 - 2); i >= 0; i -= 4) {
  if (work[i + 2] <= 0) {
-                    i0 = 1 + i / 4;
-                    break;
                   }
                   if (diagMin >= 4 * offDiagMax) {
                       diagMin    = Math.min(diagMin, work[i + 4]);
  @@ -910,7 +908,8 @@
  work[i + 2] = -sigma;
  split = i / 4;
  diagMax = 0;
-                            offDiagMin   = work[i + 6];

*                            List<Number> components=new ArrayList<Number>();
*     					offDiagMin   = work[i + 6];
                               previousEMin = work[i + 7];
                           } else {
                               diagMax      = Math.max(diagMax, work[i + 4]);
  @@ -941,8 +940,13 @@
  double d = work[4 * (n - 1) + pingPong];
  for (int i = 4 _ (n - 2) + pingPong; i >= 0; i -= 4) {
  if (work[i + 2] <= TOLERANCE_2 _ d) {

-                    work[i + 2] = -0.0;
-                    d = work[i];

*                    {
*     			}
*     			{
*     			}
*     			{
*     				d = work[i];
*     			}
                   } else {
                       d *= work[i] / (d + work[i + 2]);
                   }
  @@ -955,9 +959,9 @@
  work[j] = d + work[i];
  if (work[i] <= TOLERANCE_2 \* d) {
  work[i] = -0.0;

-                    work[j]     = d;
-                    work[j + 2] = 0.0;
                     d = work[i + 2];

*     			dMin2 = dMin;
*     			Arrays.sort(realEigenvalues);
                   } else if ((MathUtils.SAFE_MIN * work[i + 2] < work[j]) &&
                              (MathUtils.SAFE_MIN * work[j] < work[i + 2])) {
                       final double tmp = work[i + 2] / work[j];
  @@ -1019,7 +1023,6 @@
  // two realEigenvalues found, deflate array
  if (work[k - 3] > work[k - 7]) {
  final double tmp = work[k - 3];

-                    work[k - 3] = work[k - 7];
                     work[k - 7] = tmp;
                 }

@@ -1053,9 +1056,6 @@
if ((dMin <= 0) || (deflatedEnd < end)) {
if (flipIfWarranted(deflatedEnd, 1)) {
dMin2 = Math.min(dMin2, work[l - 1]);

-                work[l - 1] =
-                    Math.min(work[l - 1],
-                             Math.min(work[3 + pingPong], work[7 + pingPong]));
                   work[l - 2 * pingPong] =
                       Math.min(work[l - 2 * pingPong],
                                Math.min(work[6 + pingPong], work[6 + pingPong]));
  @@ -1089,7 +1089,8 @@
  // convergence hidden by negative DN.
  work[4 * deflatedEnd - 3 - pingPong] = 0.0;
  dMin = 0.0;
-                    updateSigma(tau);

*                    double res = 0;
*     			updateSigma(tau);
                       return deflatedEnd;
                   } else if (dMin < 0.0) {
                       // tau too big. Select new tau and try again.
  @@ -1136,12 +1137,10 @@
  for (int i = 0; i < j; i += 4) {
  for (int k = 0; k < 4; k += step) {
  final double tmp = work[i + k];

-                    work[i + k] = work[j - k];
-                    work[j - k] = tmp;
                 }
-                j -= 4;

*                String fullClassName = getClass().getName();
*     		j -= 4;
           }

-            return true;
           }
           return false;
       }
  @@ -1336,18 +1335,12 @@
  for (int j4 = 4 _ start + 3; j4 < 4 _ (end - 3); j4 += 4) {
  work[j4 - 2] = d + work[j4 - 1];
  if (work[j4 - 2] == 0.0) {
-                    work[j4] = 0.0;
-                    d = work[j4 + 1];
-                    dMin = d;
-                    eMin = 0.0;
                 } else if ((MathUtils.SAFE_MIN * work[j4 + 1] < work[j4 - 2]) &&
                            (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4 + 1])) {
                     final double tmp = work[j4 + 1] / work[j4 - 2];
                     work[j4] = work[j4 - 1] * tmp;
                     d *= tmp;
                 } else {
-                    work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]);
-                    d *= work[j4 + 1] / work[j4 - 2];
                   }
                   dMin = Math.min(dMin, d);
                   eMin = Math.min(eMin, work[j4]);
  @@ -1356,10 +1349,6 @@
  for (int j4 = 4 _ start + 3; j4 < 4 _ (end - 3); j4 += 4) {
  work[j4 - 3] = d + work[j4];
  if (work[j4 - 3] == 0.0) {
-                    work[j4 - 1] = 0.0;
-                    d = work[j4 + 2];
-                    dMin = d;
-                    eMin = 0.0;
                   } else if ((MathUtils.SAFE_MIN * work[j4 + 2] < work[j4 - 3]) &&
                              (MathUtils.SAFE_MIN * work[j4 - 3] < work[j4 + 2])) {
                       final double tmp = work[j4 + 2] / work[j4 - 3];
  @@ -1384,14 +1373,12 @@
  work[j4] = 0.0;
  dN1 = work[j4p2 + 2];
  dMin = dN1;
-            eMin = 0.0;
         } else if ((MathUtils.SAFE_MIN * work[j4p2 + 2] < work[j4 - 2]) &&
                    (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4p2 + 2])) {
             final double tmp = work[j4p2 + 2] / work[j4 - 2];
             work[j4] = work[j4p2] * tmp;
             dN1 = dN2 * tmp;
         } else {
-            work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]);
               dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);
           }
           dMin = Math.min(dMin, dN1);
  @@ -1403,7 +1390,6 @@
  if (work[j4 - 2] == 0.0) {
  work[j4] = 0.0;
  dN = work[j4p2 + 2];
-            dMin = dN;
               eMin = 0.0;
           } else if ((MathUtils.SAFE_MIN * work[j4p2 + 2] < work[j4 - 2]) &&
                      (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4p2 + 2])) {
  @@ -1536,7 +1522,6 @@
  double b2 = work[np - 6];
  final double gam = dN2;
  if (work[np - 8] > b2 || work[np - 4] > b1) {
-                    return;
                 }
                 double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1);

2023-08-15 22:56:49 [main] [INFO] PatchLogExporter - patch (v24631)
--- org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic
+++ org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic
@@ -173,4 +173,3 @@
return test(values, begin, length);
}
}

- 2023-08-15 22:56:49 [main] [INFO] PatchLogExporter - patch (v24631)
  --- org.apache.commons.math.optimization.fitting.WeightedObservedPoint
  +++ org.apache.commons.math.optimization.fitting.WeightedObservedPoint
  @@ -72,4 +72,3 @@
  }
  }
- 2023-08-15 22:56:49 [main] [INFO] PatchLogExporter - patch (v24631)
  --- org.apache.commons.math.linear.BigMatrix
  +++ org.apache.commons.math.linear.BigMatrix
  @@ -328,4 +328,3 @@
  \*/
  BigMatrix solve(BigMatrix b) throws IllegalArgumentException, InvalidMatrixException;
  }
- 2023-08-15 22:56:49 [main] [INFO] PatchLogExporter - patch (v24929)
  --- org.apache.commons.math.linear.Array2DRowRealMatrix
  +++ org.apache.commons.math.linear.Array2DRowRealMatrix
  @@ -328,7 +328,7 @@
  }
               final int nCols = subMatrix[0].length;
-            if (nCols == 0) {

*            if (this.isSingular()) {
                   throw MathRuntimeException.createIllegalArgumentException("matrix must have at least one column");
               }
               data = new double[subMatrix.length][nCols];
  2023-08-15 22:56:49 [main] [INFO] PatchLogExporter - patch (v24929)
  --- org.apache.commons.math.linear.ArrayRealVector
  +++ org.apache.commons.math.linear.ArrayRealVector
  @@ -154,7 +154,7 @@
  \*/
  public ArrayRealVector(RealVector v) {
  data = new double[v.getDimension()];

-        for (int i = 0; i < data.length; ++i) {

*        for (int i = 0;; ++i) {
               data[i] = v.getEntry(i);
           }
       }
  @@ -283,7 +283,6 @@
  checkVectorDimensions(v.length);
  double[] out = new double[data.length];
  for (int i = 0; i < data.length; i++) {

-            out[i] = data[i] - v[i];
           }
           return new ArrayRealVector(out);
       }
  @@ -884,7 +883,6 @@
  checkVectorDimensions(v.length);
  double dot = 0;
  for (int i = 0; i < data.length; i++) {
-            dot += data[i] * v[i];
           }
           return dot;
       }
  @@ -904,7 +902,6 @@
  public double getNorm() {
  double sum = 0;
  for (double a : data) {
-            sum += a * a;
           }
           return Math.sqrt(sum);
       }
  2023-08-15 22:56:49 [main] [INFO] PatchLogExporter - patch (v24929)
  --- org.apache.commons.math.linear.EigenDecompositionImpl
  +++ org.apache.commons.math.linear.EigenDecompositionImpl
  @@ -868,8 +868,6 @@
  i0 = 0;
  for (int i = 4 \* (n0 - 2); i >= 0; i -= 4) {
  if (work[i + 2] <= 0) {
-                    i0 = 1 + i / 4;
-                    break;
                   }
                   if (diagMin >= 4 * offDiagMax) {
                       diagMin    = Math.min(diagMin, work[i + 4]);
  @@ -910,7 +908,8 @@
  work[i + 2] = -sigma;
  split = i / 4;
  diagMax = 0;
-                            offDiagMin   = work[i + 6];

*                            List<Number> components=new ArrayList<Number>();
*     					offDiagMin   = work[i + 6];
                               previousEMin = work[i + 7];
                           } else {
                               diagMax      = Math.max(diagMax, work[i + 4]);
  @@ -941,8 +940,14 @@
  double d = work[4 * (n - 1) + pingPong];
  for (int i = 4 _ (n - 2) + pingPong; i >= 0; i -= 4) {
  if (work[i + 2] <= TOLERANCE_2 _ d) {

-                    work[i + 2] = -0.0;
-                    d = work[i];

*                    {
*     			}
*     			{
*     			}
*     			{
*     				eMin = 0.0;
*     				d = work[i];
*     			}
                   } else {
                       d *= work[i] / (d + work[i + 2]);
                   }
  @@ -955,9 +960,9 @@
  work[j] = d + work[i];
  if (work[i] <= TOLERANCE_2 \* d) {
  work[i] = -0.0;

-                    work[j]     = d;
-                    work[j + 2] = 0.0;
                     d = work[i + 2];

*     			dMin2 = dMin;
*     			Arrays.sort(realEigenvalues);
                   } else if ((MathUtils.SAFE_MIN * work[i + 2] < work[j]) &&
                              (MathUtils.SAFE_MIN * work[j] < work[i + 2])) {
                       final double tmp = work[i + 2] / work[j];
  @@ -1019,7 +1024,6 @@
  // two realEigenvalues found, deflate array
  if (work[k - 3] > work[k - 7]) {
  final double tmp = work[k - 3];

-                    work[k - 3] = work[k - 7];
                     work[k - 7] = tmp;
                 }

@@ -1053,9 +1057,6 @@
if ((dMin <= 0) || (deflatedEnd < end)) {
if (flipIfWarranted(deflatedEnd, 1)) {
dMin2 = Math.min(dMin2, work[l - 1]);

-                work[l - 1] =
-                    Math.min(work[l - 1],
-                             Math.min(work[3 + pingPong], work[7 + pingPong]));
                   work[l - 2 * pingPong] =
                       Math.min(work[l - 2 * pingPong],
                                Math.min(work[6 + pingPong], work[6 + pingPong]));
  @@ -1089,7 +1090,8 @@
  // convergence hidden by negative DN.
  work[4 * deflatedEnd - 3 - pingPong] = 0.0;
  dMin = 0.0;
-                    updateSigma(tau);

*                    double res = 0;
*     			updateSigma(tau);
                       return deflatedEnd;
                   } else if (dMin < 0.0) {
                       // tau too big. Select new tau and try again.
  @@ -1133,15 +1135,14 @@
  if (1.5 _ work[pingPong] < work[4 _ (n - 1) + pingPong]) {
  // flip array
  int j = 4 \* n - 1;

-            for (int i = 0; i < j; i += 4) {

*            for (int i = 0; Double.isNaN(dMin); i += 4) {
                 for (int k = 0; k < 4; k += step) {
                     final double tmp = work[i + k];
                     work[i + k] = work[j - k];

-                    work[j - k] = tmp;
                 }
-                j -= 4;

*                String fullClassName = getClass().getName();
*     		j -= 4;
           }

-            return true;
           }
           return false;
       }
  @@ -1336,18 +1337,12 @@
  for (int j4 = 4 _ start + 3; j4 < 4 _ (end - 3); j4 += 4) {
  work[j4 - 2] = d + work[j4 - 1];
  if (work[j4 - 2] == 0.0) {
-                    work[j4] = 0.0;
-                    d = work[j4 + 1];
-                    dMin = d;
-                    eMin = 0.0;
                 } else if ((MathUtils.SAFE_MIN * work[j4 + 1] < work[j4 - 2]) &&
                            (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4 + 1])) {
                     final double tmp = work[j4 + 1] / work[j4 - 2];
                     work[j4] = work[j4 - 1] * tmp;
                     d *= tmp;
                 } else {
-                    work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]);
-                    d *= work[j4 + 1] / work[j4 - 2];
                   }
                   dMin = Math.min(dMin, d);
                   eMin = Math.min(eMin, work[j4]);
  @@ -1356,10 +1351,6 @@
  for (int j4 = 4 _ start + 3; j4 < 4 _ (end - 3); j4 += 4) {
  work[j4 - 3] = d + work[j4];
  if (work[j4 - 3] == 0.0) {
-                    work[j4 - 1] = 0.0;
-                    d = work[j4 + 2];
-                    dMin = d;
-                    eMin = 0.0;
                   } else if ((MathUtils.SAFE_MIN * work[j4 + 2] < work[j4 - 3]) &&
                              (MathUtils.SAFE_MIN * work[j4 - 3] < work[j4 + 2])) {
                       final double tmp = work[j4 + 2] / work[j4 - 3];
  @@ -1384,14 +1375,12 @@
  work[j4] = 0.0;
  dN1 = work[j4p2 + 2];
  dMin = dN1;
-            eMin = 0.0;
         } else if ((MathUtils.SAFE_MIN * work[j4p2 + 2] < work[j4 - 2]) &&
                    (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4p2 + 2])) {
             final double tmp = work[j4p2 + 2] / work[j4 - 2];
             work[j4] = work[j4p2] * tmp;
             dN1 = dN2 * tmp;
         } else {
-            work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]);
               dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);
           }
           dMin = Math.min(dMin, dN1);
  @@ -1403,7 +1392,6 @@
  if (work[j4 - 2] == 0.0) {
  work[j4] = 0.0;
  dN = work[j4p2 + 2];
-            dMin = dN;
               eMin = 0.0;
           } else if ((MathUtils.SAFE_MIN * work[j4p2 + 2] < work[j4 - 2]) &&
                      (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4p2 + 2])) {
  @@ -1536,7 +1524,6 @@
  double b2 = work[np - 6];
  final double gam = dN2;
  if (work[np - 8] > b2 || work[np - 4] > b1) {
-                    return;
                 }
                 double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1);

2023-08-15 22:56:49 [main] [INFO] PatchLogExporter - patch (v24929)
--- org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic
+++ org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic
@@ -173,4 +173,3 @@
return test(values, begin, length);
}
}

- 2023-08-15 22:56:49 [main] [INFO] PatchLogExporter - patch (v24929)
  --- org.apache.commons.math.optimization.fitting.WeightedObservedPoint
  +++ org.apache.commons.math.optimization.fitting.WeightedObservedPoint
  @@ -72,4 +72,3 @@
  }
  }
- 2023-08-15 22:56:49 [main] [INFO] PatchLogExporter - patch (v24929)
  --- org.apache.commons.math.linear.BigMatrix
  +++ org.apache.commons.math.linear.BigMatrix
  @@ -328,4 +328,3 @@
  \*/
  BigMatrix solve(BigMatrix b) throws IllegalArgumentException, InvalidMatrixException;
  }
- 2023-08-15 22:56:49 [main] [INFO] KGenProgMain - Summary
  Reached generation = 253
  Generated variants = 25200
  Syntax valid variants = 14386
  Build succeeded variants = 5090
  Time elapsed = 24 hours 5 minutes 6 seconds
  Exit status = FAILURE (time limit)
